{"problem_statement":"Allow specifying attributes in `impl` mode\nI'm considering `cfg`-gating the use of `bitflags!` in my libraries, and to that end it would be nice if it was possible to apply attributes to the generated `impl`s as well.\r\n\r\nThe naive solution would be:\r\n```rust\r\npub struct Flags(u8);\r\n\r\n#[cfg(feature = \"bitflags\")]\r\nbitflags! {\r\n    impl Flags: u8 {\r\n        \/\/ ...\r\n    }\r\n}\r\n```\r\n\r\nHowever, that works poorly with the `doc_cfg` (and `doc_auto_cfg`) feature, as the attribute is only applied to the macro, and isn't passed down to each output item.\r\n\r\nInstead, I would like to be able to do the following:\r\n```rust\r\n#![feature(doc_cfg)]\r\n\r\npub struct Flags(u8);\r\n\r\n#[cfg(feature = \"bitflags\")]\r\nbitflags! {\r\n    #[doc(cfg(feature = \"bitflags\"))]\r\n    impl Flags: u8 {\r\n        \/\/ ...\r\n    }\r\n}\r\n```\n","test_patch":"diff --git \/dev\/null b\/tests\/compile-pass\/bitflags_impl_attrs.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/tests\/compile-pass\/bitflags_impl_attrs.rs\n@@ -0,0 +1,13 @@\n+extern crate bitflags;\n+\n+struct Example(u64);\n+\n+bitflags::bitflags! {\n+    \/\/\/ Docs on the `impl` block.\n+    #[allow(dead_code)]\n+    impl Example: u64 {\n+        const flag = 0b01;\n+    }\n+}\n+\n+fn main() {}\n","hints_text":"Thanks for the report @madsmtm! Anywhere attributes are allowed to be specified we should support in the macros as much as possible. I think this is just a missing piece of functionality for the impl mode.","base_commit":"9c4b93c931e34a5104f50e20be1bdd15bc593b0e","issue_numbers":["406"],"created_at":"2024-06-24T23:17:40Z","pull_number":411,"instance_id":"bitflags__bitflags-411","patch":"diff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -38,7 +38,7 @@ bitflags! {\n \n See the docs for the `bitflags` macro for the full syntax.\n \n-Also see the [`example_generated`] module for an example of what the `bitflags` macro generates for a flags type.\n+Also see the [`example_generated`](.\/example_generated\/index.html) module for an example of what the `bitflags` macro generates for a flags type.\n \n ### Externally defined flags\n \ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -530,6 +530,7 @@ macro_rules! bitflags {\n         }\n     };\n     (\n+        $(#[$outer:meta])*\n         impl $BitFlags:ident: $T:ty {\n             $(\n                 $(#[$inner:ident $($args:tt)*])*\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -561,6 +562,7 @@ macro_rules! bitflags {\n         )]\n         const _: () = {\n             $crate::__impl_public_bitflags! {\n+                $(#[$outer])*\n                 $BitFlags: $T, $BitFlags {\n                     $(\n                         $(#[$inner $($args)*])*\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -593,6 +595,7 @@ macro_rules! bitflags {\n #[doc(hidden)]\n macro_rules! __impl_bitflags {\n     (\n+        $(#[$outer:meta])*\n         $PublicBitFlags:ident: $T:ty {\n             fn empty() $empty:block\n             fn all() $all:block\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -617,6 +620,7 @@ macro_rules! __impl_bitflags {\n         }\n     ) => {\n         #[allow(dead_code, deprecated, unused_attributes)]\n+        $(#[$outer])*\n         impl $PublicBitFlags {\n             \/\/\/ Get a flags value with all bits unset.\n             #[inline]\ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -26,9 +26,11 @@ macro_rules! __declare_public_bitflags {\n #[doc(hidden)]\n macro_rules! __impl_public_bitflags_forward {\n     (\n+        $(#[$outer:meta])*\n         $PublicBitFlags:ident: $T:ty, $InternalBitFlags:ident\n     ) => {\n         $crate::__impl_bitflags! {\n+            $(#[$outer])*\n             $PublicBitFlags: $T {\n                 fn empty() {\n                     Self($InternalBitFlags::empty())\ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -128,6 +130,7 @@ macro_rules! __impl_public_bitflags_forward {\n #[doc(hidden)]\n macro_rules! __impl_public_bitflags {\n     (\n+        $(#[$outer:meta])*\n         $BitFlags:ident: $T:ty, $PublicBitFlags:ident {\n             $(\n                 $(#[$inner:ident $($args:tt)*])*\ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -136,6 +139,7 @@ macro_rules! __impl_public_bitflags {\n         }\n     ) => {\n         $crate::__impl_bitflags! {\n+            $(#[$outer])*\n             $BitFlags: $T {\n                 fn empty() {\n                     Self(<$T as $crate::Bits>::EMPTY)\ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -271,7 +275,11 @@ macro_rules! __impl_public_bitflags {\n #[macro_export]\n #[doc(hidden)]\n macro_rules! __impl_public_bitflags_iter {\n-    ($BitFlags:ident: $T:ty, $PublicBitFlags:ident) => {\n+    (\n+        $(#[$outer:meta])*\n+        $BitFlags:ident: $T:ty, $PublicBitFlags:ident\n+    ) => {\n+        $(#[$outer])*\n         impl $BitFlags {\n             \/\/\/ Yield a set of contained flags values.\n             \/\/\/\ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -300,6 +308,7 @@ macro_rules! __impl_public_bitflags_iter {\n             }\n         }\n \n+        $(#[$outer:meta])*\n         impl $crate::__private::core::iter::IntoIterator for $BitFlags {\n             type Item = $PublicBitFlags;\n             type IntoIter = $crate::iter::Iter<$PublicBitFlags>;\ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -315,7 +324,12 @@ macro_rules! __impl_public_bitflags_iter {\n #[macro_export]\n #[doc(hidden)]\n macro_rules! __impl_public_bitflags_ops {\n-    ($PublicBitFlags:ident) => {\n+    (\n+        $(#[$outer:meta])*\n+        $PublicBitFlags:ident\n+    ) => {\n+\n+        $(#[$outer])*\n         impl $crate::__private::core::fmt::Binary for $PublicBitFlags {\n             fn fmt(\n                 &self,\ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -326,6 +340,7 @@ macro_rules! __impl_public_bitflags_ops {\n             }\n         }\n \n+        $(#[$outer])*\n         impl $crate::__private::core::fmt::Octal for $PublicBitFlags {\n             fn fmt(\n                 &self,\ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -336,6 +351,7 @@ macro_rules! __impl_public_bitflags_ops {\n             }\n         }\n \n+        $(#[$outer])*\n         impl $crate::__private::core::fmt::LowerHex for $PublicBitFlags {\n             fn fmt(\n                 &self,\ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -346,6 +362,7 @@ macro_rules! __impl_public_bitflags_ops {\n             }\n         }\n \n+        $(#[$outer])*\n         impl $crate::__private::core::fmt::UpperHex for $PublicBitFlags {\n             fn fmt(\n                 &self,\ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -356,6 +373,7 @@ macro_rules! __impl_public_bitflags_ops {\n             }\n         }\n \n+        $(#[$outer])*\n         impl $crate::__private::core::ops::BitOr for $PublicBitFlags {\n             type Output = Self;\n \ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -366,6 +384,7 @@ macro_rules! __impl_public_bitflags_ops {\n             }\n         }\n \n+        $(#[$outer])*\n         impl $crate::__private::core::ops::BitOrAssign for $PublicBitFlags {\n             \/\/\/ The bitwise or (`|`) of the bits in two flags values.\n             #[inline]\ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -374,6 +393,7 @@ macro_rules! __impl_public_bitflags_ops {\n             }\n         }\n \n+        $(#[$outer])*\n         impl $crate::__private::core::ops::BitXor for $PublicBitFlags {\n             type Output = Self;\n \ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -384,6 +404,7 @@ macro_rules! __impl_public_bitflags_ops {\n             }\n         }\n \n+        $(#[$outer])*\n         impl $crate::__private::core::ops::BitXorAssign for $PublicBitFlags {\n             \/\/\/ The bitwise exclusive-or (`^`) of the bits in two flags values.\n             #[inline]\ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -392,6 +413,7 @@ macro_rules! __impl_public_bitflags_ops {\n             }\n         }\n \n+        $(#[$outer])*\n         impl $crate::__private::core::ops::BitAnd for $PublicBitFlags {\n             type Output = Self;\n \ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -402,6 +424,7 @@ macro_rules! __impl_public_bitflags_ops {\n             }\n         }\n \n+        $(#[$outer])*\n         impl $crate::__private::core::ops::BitAndAssign for $PublicBitFlags {\n             \/\/\/ The bitwise and (`&`) of the bits in two flags values.\n             #[inline]\ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -410,6 +433,7 @@ macro_rules! __impl_public_bitflags_ops {\n             }\n         }\n \n+        $(#[$outer])*\n         impl $crate::__private::core::ops::Sub for $PublicBitFlags {\n             type Output = Self;\n \ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -423,6 +447,7 @@ macro_rules! __impl_public_bitflags_ops {\n             }\n         }\n \n+        $(#[$outer])*\n         impl $crate::__private::core::ops::SubAssign for $PublicBitFlags {\n             \/\/\/ The intersection of a source flags value with the complement of a target flags value (`&!`).\n             \/\/\/\ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -434,6 +459,7 @@ macro_rules! __impl_public_bitflags_ops {\n             }\n         }\n \n+        $(#[$outer])*\n         impl $crate::__private::core::ops::Not for $PublicBitFlags {\n             type Output = Self;\n \ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -444,6 +470,7 @@ macro_rules! __impl_public_bitflags_ops {\n             }\n         }\n \n+        $(#[$outer])*\n         impl $crate::__private::core::iter::Extend<$PublicBitFlags> for $PublicBitFlags {\n             \/\/\/ The bitwise or (`|`) of the bits in each flags value.\n             fn extend<T: $crate::__private::core::iter::IntoIterator<Item = Self>>(\ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -456,6 +483,7 @@ macro_rules! __impl_public_bitflags_ops {\n             }\n         }\n \n+        $(#[$outer])*\n         impl $crate::__private::core::iter::FromIterator<$PublicBitFlags> for $PublicBitFlags {\n             \/\/\/ The bitwise or (`|`) of the bits in each flags value.\n             fn from_iter<T: $crate::__private::core::iter::IntoIterator<Item = Self>>(\ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -476,6 +504,7 @@ macro_rules! __impl_public_bitflags_ops {\n #[doc(hidden)]\n macro_rules! __impl_public_bitflags_consts {\n     (\n+        $(#[$outer:meta])*\n         $PublicBitFlags:ident: $T:ty {\n             $(\n                 $(#[$inner:ident $($args:tt)*])*\ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -483,6 +512,7 @@ macro_rules! __impl_public_bitflags_consts {\n             )*\n         }\n     ) => {\n+        $(#[$outer])*\n         impl $PublicBitFlags {\n             $(\n                 $crate::__bitflags_flag!({\ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -500,6 +530,7 @@ macro_rules! __impl_public_bitflags_consts {\n             )*\n         }\n \n+        $(#[$outer])*\n         impl $crate::Flags for $PublicBitFlags {\n             const FLAGS: &'static [$crate::Flag<$PublicBitFlags>] = &[\n                 $(\n","version":"2.5","repo":"bitflags\/bitflags","environment_setup_commit":"9c4b93c931e34a5104f50e20be1bdd15bc593b0e"}
{"problem_statement":"Documenting bitflags: how to get documentation for the generated bitflags\nSome code that I'm writing uses the `#![warn(missing_docs)]` macro to enforce a requirement that all public interfaces have documentation. I haven't been able to figure out how to generate documentation when using the `bitflags!` macro; I also haven't been able to turn off the linter warning using `#![allow(missing_docs)]`.\r\n\r\nIs there a convenient way to add doc comments to a set of flags?\r\n* If so, is there an example somewhere that I can reference? This would be a great thing to include in bitflags documentation.\r\n* If not, then take this as a feature request!\n","test_patch":"diff --git a\/.github\/workflows\/rust.yml b\/.github\/workflows\/rust.yml\n--- a\/.github\/workflows\/rust.yml\n+++ b\/.github\/workflows\/rust.yml\n@@ -84,18 +84,19 @@ jobs:\n           cd .\/tests\/smoke-test\n           cargo +$msrv build\n \n-  mips:\n-    name: Tests \/ MIPS (Big Endian)\n+  miri:\n+    name: \"Miri\"\n     runs-on: ubuntu-latest\n     steps:\n-      - name: Checkout sources\n-        uses: actions\/checkout@8e5e7e5ab8b370d6c329ec480221332ada57f0ab\n-\n-      - name: Install Cross\n-        run: cargo install cross\n-\n+      - uses: actions\/checkout@v3\n+      - name: Install Miri\n+        run: |\n+          rustup toolchain install nightly --component miri\n+          cargo +nightly miri setup\n       - name: Default features\n-        run: cross test --target mips-unknown-linux-gnu\n+        run: cargo +nightly miri test\n+      - name: BE\n+        run: cargo +nightly miri test --target s390x-unknown-linux-gnu\n \n   clippy:\n     name: Clippy\ndiff --git a\/src\/tests\/iter.rs b\/src\/tests\/iter.rs\n--- a\/src\/tests\/iter.rs\n+++ b\/src\/tests\/iter.rs\n@@ -3,6 +3,7 @@ use super::*;\n use crate::Flags;\n \n #[test]\n+#[cfg(not(miri))] \/\/ Very slow in miri\n fn roundtrip() {\n     for a in 0u8..=255 {\n         for b in 0u8..=255 {\ndiff --git a\/src\/tests\/parser.rs b\/src\/tests\/parser.rs\n--- a\/src\/tests\/parser.rs\n+++ b\/src\/tests\/parser.rs\n@@ -6,6 +6,7 @@ use crate::{\n };\n \n #[test]\n+#[cfg(not(miri))] \/\/ Very slow in miri\n fn roundtrip() {\n     let mut s = String::new();\n \ndiff --git a\/tests\/compile-pass\/item_positions.rs b\/tests\/compile-pass\/item_positions.rs\n--- a\/tests\/compile-pass\/item_positions.rs\n+++ b\/tests\/compile-pass\/item_positions.rs\n@@ -1,3 +1,5 @@\n+#![allow(clippy::let_unit_value)]\n+\n #[macro_use]\n extern crate bitflags;\n \ndiff --git \/dev\/null b\/tests\/compile-pass\/missing_docs.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/tests\/compile-pass\/missing_docs.rs\n@@ -0,0 +1,19 @@\n+\/*!\n+Crate-level doc\n+*\/\n+\n+#![deny(missing_docs)]\n+\n+use bitflags::bitflags;\n+\n+bitflags! {\n+    #[allow(missing_docs)]\n+    pub struct MyFlags: u32 {\n+        #[allow(missing_docs)]\n+        const A = 1;\n+        #[allow(missing_docs)]\n+        const B = 2;\n+    }\n+}\n+\n+fn main() {}\ndiff --git a\/tests\/compile.rs b\/tests\/compile.rs\n--- a\/tests\/compile.rs\n+++ b\/tests\/compile.rs\n@@ -2,6 +2,7 @@\n \/\/ an impossible build between error messages emitted on various channels.\n \/\/ Since https:\/\/github.com\/dtolnay\/trybuild\/pull\/170 we always need to have a\n \/\/ `stderr` file for each test so we can't simply ignore the output on different channels.\n+#[cfg(not(miri))]\n #[rustversion::attr(beta, test)]\n #[allow(dead_code)]\n fn fail() {\ndiff --git a\/tests\/compile.rs b\/tests\/compile.rs\n--- a\/tests\/compile.rs\n+++ b\/tests\/compile.rs\n@@ -9,6 +10,7 @@ fn fail() {\n     t.compile_fail(\"tests\/compile-fail\/**\/*.rs\");\n }\n \n+#[cfg(not(miri))]\n #[test]\n fn pass() {\n     let t = trybuild::TestCases::new();\n","hints_text":"https:\/\/play.rust-lang.org\/?version=stable&mode=debug&edition=2021&gist=530756068e54aa56eb519dd66c9fdfc5\r\n\r\nhttps:\/\/play.rust-lang.org\/?version=stable&mode=debug&edition=2021&gist=f782c74e49e8c4c4ae940125265eb7ed\nThanks @rusty-snake! Those would actually make some great compile-pass tests \ud83e\udd14","base_commit":"472e392c0d082c0894b18fb31f4e68e0b145e29c","issue_numbers":["378"],"created_at":"2023-10-09T04:48:32Z","pull_number":380,"instance_id":"bitflags__bitflags-380","patch":"diff --git a\/README.md b\/README.md\n--- a\/README.md\n+++ b\/README.md\n@@ -46,11 +46,17 @@ use bitflags::bitflags;\n \n \/\/ The `bitflags!` macro generates `struct`s that manage a set of flags.\n bitflags! {\n+    \/\/\/ Represents a set of flags.\n     #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n     struct Flags: u32 {\n+        \/\/\/ The value `A`, at bit position `0`.\n         const A = 0b00000001;\n+        \/\/\/ The value `B`, at bit position `1`.\n         const B = 0b00000010;\n+        \/\/\/ The value `C`, at bit position `2`.\n         const C = 0b00000100;\n+\n+        \/\/\/ The combination of `A`, `B`, and `C`.\n         const ABC = Self::A.bits() | Self::B.bits() | Self::C.bits();\n     }\n }\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -481,7 +481,8 @@ macro_rules! bitflags {\n             non_upper_case_globals,\n             clippy::assign_op_pattern,\n             clippy::indexing_slicing,\n-            clippy::same_name_method\n+            clippy::same_name_method,\n+            clippy::iter_without_into_iter,\n         )]\n         const _: () = {\n             \/\/ Declared in a \"hidden\" scope that can't be reached directly\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -553,7 +554,8 @@ macro_rules! bitflags {\n             unused_mut,\n             unused_imports,\n             non_upper_case_globals,\n-            clippy::assign_op_pattern\n+            clippy::assign_op_pattern,\n+            clippy::iter_without_into_iter,\n         )]\n         const _: () = {\n             __impl_public_bitflags! {\n","version":"2.4","repo":"bitflags\/bitflags","environment_setup_commit":"472e392c0d082c0894b18fb31f4e68e0b145e29c"}
{"problem_statement":"Inconsistent debug output for flag with no bits\nIn a bitflags type where one of the named value has the value 0, the debug output for the type sometimes includes that value by name, and sometimes doesn't, apparently depending on whether any unrecognized bits are present. For example, this:\r\n```rust\r\nuse bitflags::bitflags;\r\n\r\nbitflags! {\r\n    #[derive(Debug)]\r\n    pub struct Flags: u32 {\r\n        const RDONLY = 0;\r\n        const WRONLY = 1;\r\n    }\r\n}\r\n\r\nfn main() {\r\n    println!(\"{:?}\", Flags::RDONLY);\r\n    println!(\"{:?}\", Flags::from_bits_retain(0x100));\r\n}\r\n```\r\nprints\r\n```\r\nFlags(0x0)\r\nFlags(RDONLY | 0x100)\r\n```\r\nI don't have an opinion about whether it should print `RDONLY` in both or neither, but printing it in just one is confusing.\n","test_patch":"diff --git a\/src\/external\/bytemuck.rs b\/src\/external\/bytemuck.rs\n--- a\/src\/external\/bytemuck.rs\n+++ b\/src\/external\/bytemuck.rs\n@@ -1,7 +1,7 @@\n #[cfg(test)]\n mod tests {\n     use bytemuck::{Pod, Zeroable};\n-    \n+\n     bitflags! {\n         #[derive(Pod, Zeroable, Clone, Copy)]\n         #[repr(transparent)]\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -422,10 +422,11 @@\n \n #![cfg_attr(not(any(feature = \"std\", test)), no_std)]\n #![cfg_attr(not(test), forbid(unsafe_code))]\n+#![cfg_attr(test, allow(mixed_script_confusables))]\n #![doc(html_root_url = \"https:\/\/docs.rs\/bitflags\/2.3.2\")]\n \n #[doc(inline)]\n-pub use traits::{Flags, Flag, Bits};\n+pub use traits::{Bits, Flag, Flags};\n \n pub mod iter;\n pub mod parser;\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -1045,1105 +1024,4 @@ mod external;\n pub mod example_generated;\n \n #[cfg(test)]\n-mod tests {\n-    use std::{\n-        collections::hash_map::DefaultHasher,\n-        fmt,\n-        hash::{Hash, Hasher},\n-        str,\n-    };\n-\n-    #[derive(Debug, PartialEq, Eq)]\n-    pub struct ManualFlags(u32);\n-\n-    bitflags! {\n-        #[doc = \"> The first principle is that you must not fool yourself \u2014 and\"]\n-        #[doc = \"> you are the easiest person to fool.\"]\n-        #[doc = \"> \"]\n-        #[doc = \"> - Richard Feynman\"]\n-        #[derive(Clone, Copy, Default, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-        struct Flags: u32 {\n-            const A = 0b00000001;\n-            #[doc = \"<pcwalton> macros are way better at generating code than trans is\"]\n-            const B = 0b00000010;\n-            const C = 0b00000100;\n-            #[doc = \"* cmr bed\"]\n-            #[doc = \"* strcat table\"]\n-            #[doc = \"<strcat> wait what?\"]\n-            const ABC = Self::A.bits() | Self::B.bits() | Self::C.bits();\n-        }\n-\n-        #[derive(Clone, Copy, Default, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-        struct _CfgFlags: u32 {\n-            #[cfg(unix)]\n-            const _CFG_A = 0b01;\n-            #[cfg(windows)]\n-            const _CFG_B = 0b01;\n-            #[cfg(unix)]\n-            const _CFG_C = Self::_CFG_A.bits() | 0b10;\n-        }\n-\n-        #[derive(Clone, Copy, Default, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-        struct AnotherSetOfFlags: i8 {\n-            const ANOTHER_FLAG = -1_i8;\n-        }\n-\n-        #[derive(Clone, Copy, Default, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-        struct LongFlags: u32 {\n-            const LONG_A = 0b1111111111111111;\n-        }\n-\n-        impl ManualFlags: u32 {\n-            const A = 0b00000001;\n-            #[doc = \"<pcwalton> macros are way better at generating code than trans is\"]\n-            const B = 0b00000010;\n-            const C = 0b00000100;\n-            #[doc = \"* cmr bed\"]\n-            #[doc = \"* strcat table\"]\n-            #[doc = \"<strcat> wait what?\"]\n-            const ABC = Self::A.bits() | Self::B.bits() | Self::C.bits();\n-        }\n-    }\n-\n-    bitflags! {\n-        #[derive(Debug, PartialEq, Eq)]\n-        struct FmtFlags: u16 {\n-            const \uace0\uc591\uc774 = 0b0000_0001;\n-            const \uac1c = 0b0000_0010;\n-            const \ubb3c\uace0\uae30 = 0b0000_0100;\n-            const \ubb3c\uace0\uae30_\uace0\uc591\uc774 = Self::\uace0\uc591\uc774.bits() | Self::\ubb3c\uace0\uae30.bits();\n-        }\n-    }\n-\n-    impl str::FromStr for FmtFlags {\n-        type Err = crate::parser::ParseError;\n-\n-        fn from_str(flags: &str) -> Result<Self, Self::Err> {\n-            Ok(Self(flags.parse()?))\n-        }\n-    }\n-\n-    impl fmt::Display for FmtFlags {\n-        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-            fmt::Display::fmt(&self.0, f)\n-        }\n-    }\n-\n-    bitflags! {\n-        #[derive(Clone, Copy, Default, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-        struct EmptyFlags: u32 {\n-        }\n-    }\n-\n-    #[test]\n-    fn test_bits() {\n-        assert_eq!(Flags::empty().bits(), 0b00000000);\n-        assert_eq!(Flags::A.bits(), 0b00000001);\n-        assert_eq!(Flags::ABC.bits(), 0b00000111);\n-\n-        assert_eq!(<Flags as crate::Flags>::bits(&Flags::ABC), 0b00000111);\n-\n-        assert_eq!(AnotherSetOfFlags::empty().bits(), 0b00);\n-        assert_eq!(AnotherSetOfFlags::ANOTHER_FLAG.bits(), !0_i8);\n-\n-        assert_eq!(EmptyFlags::empty().bits(), 0b00000000);\n-    }\n-\n-    #[test]\n-    fn test_from_bits() {\n-        assert_eq!(Flags::from_bits(0), Some(Flags::empty()));\n-        assert_eq!(Flags::from_bits(0b1), Some(Flags::A));\n-        assert_eq!(Flags::from_bits(0b10), Some(Flags::B));\n-        assert_eq!(Flags::from_bits(0b11), Some(Flags::A | Flags::B));\n-        assert_eq!(Flags::from_bits(0b1000), None);\n-\n-        assert_eq!(<Flags as crate::Flags>::from_bits(0b11), Some(Flags::A | Flags::B));\n-\n-        assert_eq!(\n-            AnotherSetOfFlags::from_bits(!0_i8),\n-            Some(AnotherSetOfFlags::ANOTHER_FLAG)\n-        );\n-\n-        assert_eq!(EmptyFlags::from_bits(0), Some(EmptyFlags::empty()));\n-        assert_eq!(EmptyFlags::from_bits(0b1), None);\n-    }\n-\n-    #[test]\n-    fn test_from_bits_truncate() {\n-        assert_eq!(Flags::from_bits_truncate(0), Flags::empty());\n-        assert_eq!(Flags::from_bits_truncate(0b1), Flags::A);\n-        assert_eq!(Flags::from_bits_truncate(0b10), Flags::B);\n-        assert_eq!(Flags::from_bits_truncate(0b11), (Flags::A | Flags::B));\n-        assert_eq!(Flags::from_bits_truncate(0b1000), Flags::empty());\n-        assert_eq!(Flags::from_bits_truncate(0b1001), Flags::A);\n-\n-        assert_eq!(<Flags as crate::Flags>::from_bits_truncate(0b11), (Flags::A | Flags::B));\n-\n-        assert_eq!(\n-            AnotherSetOfFlags::from_bits_truncate(0_i8),\n-            AnotherSetOfFlags::empty()\n-        );\n-\n-        assert_eq!(EmptyFlags::from_bits_truncate(0), EmptyFlags::empty());\n-        assert_eq!(EmptyFlags::from_bits_truncate(0b1), EmptyFlags::empty());\n-    }\n-\n-    #[test]\n-    fn test_from_bits_retain() {\n-        let extra = Flags::from_bits_retain(0b1000);\n-        assert_eq!(Flags::from_bits_retain(0), Flags::empty());\n-        assert_eq!(Flags::from_bits_retain(0b1), Flags::A);\n-        assert_eq!(Flags::from_bits_retain(0b10), Flags::B);\n-\n-        assert_eq!(Flags::from_bits_retain(0b11), (Flags::A | Flags::B));\n-        assert_eq!(Flags::from_bits_retain(0b1000), (extra | Flags::empty()));\n-        assert_eq!(Flags::from_bits_retain(0b1001), (extra | Flags::A));\n-\n-        assert_eq!(<Flags as crate::Flags>::from_bits_retain(0b11), (Flags::A | Flags::B));\n-\n-        let extra = EmptyFlags::from_bits_retain(0b1000);\n-        assert_eq!(\n-            EmptyFlags::from_bits_retain(0b1000),\n-            (extra | EmptyFlags::empty())\n-        );\n-    }\n-\n-    #[test]\n-    fn test_is_empty() {\n-        assert!(Flags::empty().is_empty());\n-        assert!(!Flags::A.is_empty());\n-        assert!(!Flags::ABC.is_empty());\n-\n-        assert!(!<Flags as crate::Flags>::is_empty(&Flags::ABC));\n-\n-        assert!(!AnotherSetOfFlags::ANOTHER_FLAG.is_empty());\n-\n-        assert!(EmptyFlags::empty().is_empty());\n-        assert!(EmptyFlags::all().is_empty());\n-    }\n-\n-    #[test]\n-    fn test_is_all() {\n-        assert!(Flags::all().is_all());\n-        assert!(!Flags::A.is_all());\n-        assert!(Flags::ABC.is_all());\n-\n-        let extra = Flags::from_bits_retain(0b1000);\n-        assert!(!extra.is_all());\n-        assert!(!(Flags::A | extra).is_all());\n-        assert!((Flags::ABC | extra).is_all());\n-\n-        assert!(<Flags as crate::Flags>::is_all(&Flags::all()));\n-\n-        assert!(AnotherSetOfFlags::ANOTHER_FLAG.is_all());\n-\n-        assert!(EmptyFlags::all().is_all());\n-        assert!(EmptyFlags::empty().is_all());\n-    }\n-\n-    #[test]\n-    fn test_two_empties_do_not_intersect() {\n-        let e1 = Flags::empty();\n-        let e2 = Flags::empty();\n-        assert!(!e1.intersects(e2));\n-\n-        assert!(!<Flags as crate::Flags>::intersects(&e1, e2));\n-\n-        assert!(AnotherSetOfFlags::ANOTHER_FLAG.intersects(AnotherSetOfFlags::ANOTHER_FLAG));\n-    }\n-\n-    #[test]\n-    fn test_empty_does_not_intersect_with_full() {\n-        let e1 = Flags::empty();\n-        let e2 = Flags::ABC;\n-        assert!(!e1.intersects(e2));\n-\n-        assert!(!<Flags as crate::Flags>::intersects(&e1, e2));\n-    }\n-\n-    #[test]\n-    fn test_disjoint_intersects() {\n-        let e1 = Flags::A;\n-        let e2 = Flags::B;\n-        assert!(!e1.intersects(e2));\n-\n-        assert!(!<Flags as crate::Flags>::intersects(&e1, e2));\n-    }\n-\n-    #[test]\n-    fn test_overlapping_intersects() {\n-        let e1 = Flags::A;\n-        let e2 = Flags::A | Flags::B;\n-        assert!(e1.intersects(e2));\n-\n-        assert!(<Flags as crate::Flags>::intersects(&e1, e2));\n-    }\n-\n-    #[test]\n-    fn test_contains() {\n-        let e1 = Flags::A;\n-        let e2 = Flags::A | Flags::B;\n-        assert!(!e1.contains(e2));\n-        assert!(e2.contains(e1));\n-        assert!(Flags::ABC.contains(e2));\n-\n-        assert!(<Flags as crate::Flags>::contains(&Flags::ABC, e2));\n-\n-        assert!(AnotherSetOfFlags::ANOTHER_FLAG.contains(AnotherSetOfFlags::ANOTHER_FLAG));\n-\n-        assert!(EmptyFlags::empty().contains(EmptyFlags::empty()));\n-    }\n-\n-    #[test]\n-    fn test_insert() {\n-        let mut e1 = Flags::A;\n-        let e2 = Flags::A | Flags::B;\n-        e1.insert(e2);\n-        assert_eq!(e1, e2);\n-\n-        let mut e1 = Flags::A;\n-        let e2 = Flags::A | Flags::B;\n-        <Flags as crate::Flags>::insert(&mut e1, e2);\n-        assert_eq!(e1, e2);\n-\n-        let mut e3 = AnotherSetOfFlags::empty();\n-        e3.insert(AnotherSetOfFlags::ANOTHER_FLAG);\n-        assert_eq!(e3, AnotherSetOfFlags::ANOTHER_FLAG);\n-    }\n-\n-    #[test]\n-    fn test_remove() {\n-        let mut e1 = Flags::A | Flags::B;\n-        let e2 = Flags::A | Flags::C;\n-        e1.remove(e2);\n-        assert_eq!(e1, Flags::B);\n-\n-        let mut e1 = Flags::A | Flags::B;\n-        let e2 = Flags::A | Flags::C;\n-        <Flags as crate::Flags>::remove(&mut e1, e2);\n-        assert_eq!(e1, Flags::B);\n-\n-        let mut e3 = AnotherSetOfFlags::ANOTHER_FLAG;\n-        e3.remove(AnotherSetOfFlags::ANOTHER_FLAG);\n-        assert_eq!(e3, AnotherSetOfFlags::empty());\n-    }\n-\n-    #[test]\n-    fn test_operators() {\n-        let e1 = Flags::A | Flags::C;\n-        let e2 = Flags::B | Flags::C;\n-        assert_eq!((e1 | e2), Flags::ABC); \/\/ union\n-        assert_eq!((e1 & e2), Flags::C); \/\/ intersection\n-        assert_eq!((e1 - e2), Flags::A); \/\/ set difference\n-        assert_eq!(!e2, Flags::A); \/\/ set complement\n-        assert_eq!(e1 ^ e2, Flags::A | Flags::B); \/\/ toggle\n-        let mut e3 = e1;\n-        e3.toggle(e2);\n-        assert_eq!(e3, Flags::A | Flags::B);\n-\n-        let mut m4 = AnotherSetOfFlags::empty();\n-        m4.toggle(AnotherSetOfFlags::empty());\n-        assert_eq!(m4, AnotherSetOfFlags::empty());\n-    }\n-\n-    #[test]\n-    fn test_operators_unchecked() {\n-        let extra = Flags::from_bits_retain(0b1000);\n-        let e1 = Flags::A | Flags::C | extra;\n-        let e2 = Flags::B | Flags::C;\n-        assert_eq!((e1 | e2), (Flags::ABC | extra)); \/\/ union\n-        assert_eq!((e1 & e2), Flags::C); \/\/ intersection\n-        assert_eq!((e1 - e2), (Flags::A | extra)); \/\/ set difference\n-        assert_eq!(!e2, Flags::A); \/\/ set complement\n-        assert_eq!(!e1, Flags::B); \/\/ set complement\n-        assert_eq!(e1 ^ e2, Flags::A | Flags::B | extra); \/\/ toggle\n-        let mut e3 = e1;\n-        e3.toggle(e2);\n-        assert_eq!(e3, Flags::A | Flags::B | extra);\n-    }\n-\n-    #[test]\n-    fn test_set_ops_basic() {\n-        let ab = Flags::A.union(Flags::B);\n-        let ac = Flags::A.union(Flags::C);\n-        let bc = Flags::B.union(Flags::C);\n-        assert_eq!(ab.bits(), 0b011);\n-        assert_eq!(bc.bits(), 0b110);\n-        assert_eq!(ac.bits(), 0b101);\n-\n-        assert_eq!(ab, Flags::B.union(Flags::A));\n-        assert_eq!(ac, Flags::C.union(Flags::A));\n-        assert_eq!(bc, Flags::C.union(Flags::B));\n-\n-        assert_eq!(ac, <Flags as crate::Flags>::union(Flags::A, Flags::C));\n-\n-        assert_eq!(ac, Flags::A | Flags::C);\n-        assert_eq!(bc, Flags::B | Flags::C);\n-        assert_eq!(ab.union(bc), Flags::ABC);\n-\n-        assert_eq!(ac, Flags::A | Flags::C);\n-        assert_eq!(bc, Flags::B | Flags::C);\n-\n-        assert_eq!(ac.union(bc), ac | bc);\n-        assert_eq!(ac.union(bc), Flags::ABC);\n-        assert_eq!(bc.union(ac), Flags::ABC);\n-\n-        assert_eq!(ac.intersection(bc), ac & bc);\n-        assert_eq!(ac.intersection(bc), Flags::C);\n-        assert_eq!(bc.intersection(ac), Flags::C);\n-\n-        assert_eq!(Flags::C, <Flags as crate::Flags>::intersection(ac, bc));\n-\n-        assert_eq!(ac.difference(bc), ac - bc);\n-        assert_eq!(bc.difference(ac), bc - ac);\n-        assert_eq!(ac.difference(bc), Flags::A);\n-        assert_eq!(bc.difference(ac), Flags::B);\n-\n-        assert_eq!(bc, <Flags as crate::Flags>::difference(bc, Flags::A));\n-\n-        assert_eq!(bc.complement(), !bc);\n-        assert_eq!(bc.complement(), Flags::A);\n-\n-        assert_eq!(Flags::A, <Flags as crate::Flags>::complement(bc));\n-\n-        assert_eq!(ac.symmetric_difference(bc), Flags::A.union(Flags::B));\n-        assert_eq!(bc.symmetric_difference(ac), Flags::A.union(Flags::B));\n-\n-        assert_eq!(ab, <Flags as crate::Flags>::symmetric_difference(ac, bc));\n-    }\n-\n-    #[test]\n-    fn test_set_ops_const() {\n-        \/\/ These just test that these compile and don't cause use-site panics\n-        \/\/ (would be possible if we had some sort of UB)\n-        const INTERSECT: Flags = Flags::all().intersection(Flags::C);\n-        const UNION: Flags = Flags::A.union(Flags::C);\n-        const DIFFERENCE: Flags = Flags::all().difference(Flags::A);\n-        const COMPLEMENT: Flags = Flags::C.complement();\n-        const SYM_DIFFERENCE: Flags = UNION.symmetric_difference(DIFFERENCE);\n-        assert_eq!(INTERSECT, Flags::C);\n-        assert_eq!(UNION, Flags::A | Flags::C);\n-        assert_eq!(DIFFERENCE, Flags::all() - Flags::A);\n-        assert_eq!(COMPLEMENT, !Flags::C);\n-        assert_eq!(\n-            SYM_DIFFERENCE,\n-            (Flags::A | Flags::C) ^ (Flags::all() - Flags::A)\n-        );\n-    }\n-\n-    #[test]\n-    fn test_set_ops_unchecked() {\n-        let extra = Flags::from_bits_retain(0b1000);\n-        let e1 = Flags::A.union(Flags::C).union(extra);\n-        let e2 = Flags::B.union(Flags::C);\n-        assert_eq!(e1.bits(), 0b1101);\n-        assert_eq!(e1.union(e2), (Flags::ABC | extra));\n-        assert_eq!(e1.intersection(e2), Flags::C);\n-        assert_eq!(e1.difference(e2), Flags::A | extra);\n-        assert_eq!(e2.difference(e1), Flags::B);\n-        assert_eq!(e2.complement(), Flags::A);\n-        assert_eq!(e1.complement(), Flags::B);\n-        assert_eq!(e1.symmetric_difference(e2), Flags::A | Flags::B | extra); \/\/ toggle\n-    }\n-\n-    #[test]\n-    fn test_set_ops_exhaustive() {\n-        \/\/ Define a flag that contains gaps to help exercise edge-cases,\n-        \/\/ especially around \"unknown\" flags (e.g. ones outside of `all()`\n-        \/\/ `from_bits_retain`).\n-        \/\/ - when lhs and rhs both have different sets of unknown flags.\n-        \/\/ - unknown flags at both ends, and in the middle\n-        \/\/ - cases with \"gaps\".\n-        bitflags! {\n-            #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n-            struct Test: u16 {\n-                \/\/ Intentionally no `A`\n-                const B = 0b000000010;\n-                \/\/ Intentionally no `C`\n-                const D = 0b000001000;\n-                const E = 0b000010000;\n-                const F = 0b000100000;\n-                const G = 0b001000000;\n-                \/\/ Intentionally no `H`\n-                const I = 0b100000000;\n-            }\n-        }\n-        let iter_test_flags = || (0..=0b111_1111_1111).map(|bits| Test::from_bits_retain(bits));\n-\n-        for a in iter_test_flags() {\n-            assert_eq!(\n-                a.complement(),\n-                Test::from_bits_truncate(!a.bits()),\n-                \"wrong result: !({:?})\",\n-                a,\n-            );\n-            assert_eq!(a.complement(), !a, \"named != op: !({:?})\", a);\n-            for b in iter_test_flags() {\n-                \/\/ Check that the named operations produce the expected bitwise\n-                \/\/ values.\n-                assert_eq!(\n-                    a.union(b).bits(),\n-                    a.bits() | b.bits(),\n-                    \"wrong result: `{:?}` | `{:?}`\",\n-                    a,\n-                    b,\n-                );\n-                assert_eq!(\n-                    a.intersection(b).bits(),\n-                    a.bits() & b.bits(),\n-                    \"wrong result: `{:?}` & `{:?}`\",\n-                    a,\n-                    b,\n-                );\n-                assert_eq!(\n-                    a.symmetric_difference(b).bits(),\n-                    a.bits() ^ b.bits(),\n-                    \"wrong result: `{:?}` ^ `{:?}`\",\n-                    a,\n-                    b,\n-                );\n-                assert_eq!(\n-                    a.difference(b).bits(),\n-                    a.bits() & !b.bits(),\n-                    \"wrong result: `{:?}` - `{:?}`\",\n-                    a,\n-                    b,\n-                );\n-                \/\/ Note: Difference is checked as both `a - b` and `b - a`\n-                assert_eq!(\n-                    b.difference(a).bits(),\n-                    b.bits() & !a.bits(),\n-                    \"wrong result: `{:?}` - `{:?}`\",\n-                    b,\n-                    a,\n-                );\n-                \/\/ Check that the named set operations are equivalent to the\n-                \/\/ bitwise equivalents\n-                assert_eq!(a.union(b), a | b, \"named != op: `{:?}` | `{:?}`\", a, b,);\n-                assert_eq!(\n-                    a.intersection(b),\n-                    a & b,\n-                    \"named != op: `{:?}` & `{:?}`\",\n-                    a,\n-                    b,\n-                );\n-                assert_eq!(\n-                    a.symmetric_difference(b),\n-                    a ^ b,\n-                    \"named != op: `{:?}` ^ `{:?}`\",\n-                    a,\n-                    b,\n-                );\n-                assert_eq!(a.difference(b), a - b, \"named != op: `{:?}` - `{:?}`\", a, b,);\n-                \/\/ Note: Difference is checked as both `a - b` and `b - a`\n-                assert_eq!(b.difference(a), b - a, \"named != op: `{:?}` - `{:?}`\", b, a,);\n-                \/\/ Verify that the operations which should be symmetric are\n-                \/\/ actually symmetric.\n-                assert_eq!(a.union(b), b.union(a), \"asymmetry: `{:?}` | `{:?}`\", a, b,);\n-                assert_eq!(\n-                    a.intersection(b),\n-                    b.intersection(a),\n-                    \"asymmetry: `{:?}` & `{:?}`\",\n-                    a,\n-                    b,\n-                );\n-                assert_eq!(\n-                    a.symmetric_difference(b),\n-                    b.symmetric_difference(a),\n-                    \"asymmetry: `{:?}` ^ `{:?}`\",\n-                    a,\n-                    b,\n-                );\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_set() {\n-        let mut e1 = Flags::A | Flags::C;\n-        e1.set(Flags::B, true);\n-        e1.set(Flags::C, false);\n-\n-        assert_eq!(e1, Flags::A | Flags::B);\n-    }\n-\n-    #[test]\n-    fn test_assignment_operators() {\n-        let mut m1 = Flags::empty();\n-        let e1 = Flags::A | Flags::C;\n-        \/\/ union\n-        m1 |= Flags::A;\n-        assert_eq!(m1, Flags::A);\n-        \/\/ intersection\n-        m1 &= e1;\n-        assert_eq!(m1, Flags::A);\n-        \/\/ set difference\n-        m1 -= m1;\n-        assert_eq!(m1, Flags::empty());\n-        \/\/ toggle\n-        m1 ^= e1;\n-        assert_eq!(m1, e1);\n-    }\n-\n-    #[test]\n-    fn test_const_fn() {\n-        const _M1: Flags = Flags::empty();\n-\n-        const M2: Flags = Flags::A;\n-        assert_eq!(M2, Flags::A);\n-\n-        const M3: Flags = Flags::C;\n-        assert_eq!(M3, Flags::C);\n-    }\n-\n-    #[test]\n-    fn test_extend() {\n-        let mut flags;\n-\n-        flags = Flags::empty();\n-        flags.extend([].iter().cloned());\n-        assert_eq!(flags, Flags::empty());\n-\n-        flags = Flags::empty();\n-        flags.extend([Flags::A, Flags::B].iter().cloned());\n-        assert_eq!(flags, Flags::A | Flags::B);\n-\n-        flags = Flags::A;\n-        flags.extend([Flags::A, Flags::B].iter().cloned());\n-        assert_eq!(flags, Flags::A | Flags::B);\n-\n-        flags = Flags::B;\n-        flags.extend([Flags::A, Flags::ABC].iter().cloned());\n-        assert_eq!(flags, Flags::ABC);\n-    }\n-\n-    #[test]\n-    fn test_from_iterator() {\n-        assert_eq!([].iter().cloned().collect::<Flags>(), Flags::empty());\n-        assert_eq!(\n-            [Flags::A, Flags::B].iter().cloned().collect::<Flags>(),\n-            Flags::A | Flags::B\n-        );\n-        assert_eq!(\n-            [Flags::A, Flags::ABC].iter().cloned().collect::<Flags>(),\n-            Flags::ABC\n-        );\n-    }\n-\n-    #[test]\n-    fn test_lt() {\n-        let mut a = Flags::empty();\n-        let mut b = Flags::empty();\n-\n-        assert!(!(a < b) && !(b < a));\n-        b = Flags::B;\n-        assert!(a < b);\n-        a = Flags::C;\n-        assert!(!(a < b) && b < a);\n-        b = Flags::C | Flags::B;\n-        assert!(a < b);\n-    }\n-\n-    #[test]\n-    fn test_ord() {\n-        let mut a = Flags::empty();\n-        let mut b = Flags::empty();\n-\n-        assert!(a <= b && a >= b);\n-        a = Flags::A;\n-        assert!(a > b && a >= b);\n-        assert!(b < a && b <= a);\n-        b = Flags::B;\n-        assert!(b > a && b >= a);\n-        assert!(a < b && a <= b);\n-    }\n-\n-    fn hash<T: Hash>(t: &T) -> u64 {\n-        let mut s = DefaultHasher::new();\n-        t.hash(&mut s);\n-        s.finish()\n-    }\n-\n-    #[test]\n-    fn test_hash() {\n-        let mut x = Flags::empty();\n-        let mut y = Flags::empty();\n-        assert_eq!(hash(&x), hash(&y));\n-        x = Flags::all();\n-        y = Flags::ABC;\n-        assert_eq!(hash(&x), hash(&y));\n-    }\n-\n-    #[test]\n-    fn test_default() {\n-        assert_eq!(Flags::empty(), Flags::default());\n-    }\n-\n-    #[test]\n-    fn test_debug() {\n-        assert_eq!(format!(\"{:?}\", Flags::A | Flags::B), \"Flags(A | B)\");\n-        assert_eq!(format!(\"{:?}\", Flags::empty()), \"Flags(0x0)\");\n-        assert_eq!(format!(\"{:?}\", Flags::ABC), \"Flags(A | B | C)\");\n-\n-        let extra = Flags::from_bits_retain(0xb8);\n-\n-        assert_eq!(format!(\"{:?}\", extra), \"Flags(0xb8)\");\n-        assert_eq!(format!(\"{:?}\", Flags::A | extra), \"Flags(A | 0xb8)\");\n-\n-        assert_eq!(\n-            format!(\"{:?}\", Flags::ABC | extra),\n-            \"Flags(A | B | C | ABC | 0xb8)\"\n-        );\n-\n-        assert_eq!(format!(\"{:?}\", EmptyFlags::empty()), \"EmptyFlags(0x0)\");\n-    }\n-\n-    #[test]\n-    fn test_display_from_str_roundtrip() {\n-        fn format_parse_case<T: fmt::Debug + fmt::Display + str::FromStr + PartialEq>(flags: T) where <T as str::FromStr>::Err: fmt::Display {\n-            assert_eq!(flags, {\n-                match flags.to_string().parse::<T>() {\n-                    Ok(flags) => flags,\n-                    Err(e) => panic!(\"failed to parse `{}`: {}\", flags, e),\n-                }\n-            });\n-        }\n-\n-        fn parse_case<T: fmt::Debug + str::FromStr + PartialEq>(expected: T, flags: &str) where <T as str::FromStr>::Err: fmt::Display + fmt::Debug {\n-            assert_eq!(expected, flags.parse::<T>().unwrap());\n-        }\n-\n-        bitflags! {\n-            #[derive(Debug, Eq, PartialEq)]\n-            pub struct MultiBitFmtFlags: u8 {\n-                const A = 0b0000_0001u8;\n-                const B = 0b0001_1110u8;\n-            }\n-        }\n-\n-        impl fmt::Display for MultiBitFmtFlags {\n-            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-                fmt::Display::fmt(&self.0, f)\n-            }\n-        }\n-\n-        impl str::FromStr for MultiBitFmtFlags {\n-            type Err = crate::parser::ParseError;\n-\n-            fn from_str(s: &str) -> Result<Self, Self::Err> {\n-                Ok(MultiBitFmtFlags(s.parse()?))\n-            }\n-        }\n-\n-        format_parse_case(FmtFlags::empty());\n-        format_parse_case(FmtFlags::all());\n-        format_parse_case(FmtFlags::\uace0\uc591\uc774);\n-        format_parse_case(FmtFlags::\uace0\uc591\uc774 | FmtFlags::\uac1c);\n-        format_parse_case(FmtFlags::\ubb3c\uace0\uae30_\uace0\uc591\uc774);\n-        format_parse_case(FmtFlags::from_bits_retain(0xb8));\n-        format_parse_case(FmtFlags::from_bits_retain(0x20));\n-        format_parse_case(MultiBitFmtFlags::from_bits_retain(3));\n-\n-        parse_case(FmtFlags::empty(), \"\");\n-        parse_case(FmtFlags::empty(), \" \\r\\n\\t\");\n-        parse_case(FmtFlags::empty(), \"0x0\");\n-\n-        parse_case(FmtFlags::\uace0\uc591\uc774, \"\uace0\uc591\uc774\");\n-        parse_case(FmtFlags::\uace0\uc591\uc774, \"  \uace0\uc591\uc774  \");\n-        parse_case(FmtFlags::\uace0\uc591\uc774, \"\uace0\uc591\uc774 | \uace0\uc591\uc774 | \uace0\uc591\uc774\");\n-        parse_case(FmtFlags::\uace0\uc591\uc774, \"0x01\");\n-\n-        parse_case(FmtFlags::\uace0\uc591\uc774 | FmtFlags::\uac1c, \"\uace0\uc591\uc774 | \uac1c\");\n-        parse_case(FmtFlags::\uace0\uc591\uc774 | FmtFlags::\uac1c, \"\uace0\uc591\uc774|\uac1c\");\n-        parse_case(FmtFlags::\uace0\uc591\uc774 | FmtFlags::\uac1c, \"\\n\uace0\uc591\uc774|\uac1c \");\n-\n-        parse_case(FmtFlags::\uace0\uc591\uc774 | FmtFlags::\ubb3c\uace0\uae30, \"\ubb3c\uace0\uae30_\uace0\uc591\uc774\");\n-    }\n-\n-    #[test]\n-    fn test_from_str_err() {\n-        fn parse_case(pat: &str, flags: &str) {\n-            let err = flags.parse::<FmtFlags>().unwrap_err().to_string();\n-            assert!(err.contains(pat), \"`{}` not found in error `{}`\", pat, err);\n-        }\n-\n-        parse_case(\"empty flag\", \"|\");\n-        parse_case(\"empty flag\", \"|||\");\n-        parse_case(\"empty flag\", \"\uace0\uc591\uc774 |\");\n-        parse_case(\"unrecognized named flag\", \"NOT_A_FLAG\");\n-        parse_case(\"unrecognized named flag\", \"\uace0\uc591\uc774 \uac1c\");\n-        parse_case(\"unrecognized named flag\", \"\uace0\uc591\uc774 | NOT_A_FLAG\");\n-        parse_case(\"invalid hex flag\", \"0xhi\");\n-        parse_case(\"invalid hex flag\", \"\uace0\uc591\uc774 | 0xhi\");\n-    }\n-\n-    #[test]\n-    fn test_binary() {\n-        assert_eq!(format!(\"{:b}\", Flags::ABC), \"111\");\n-        assert_eq!(format!(\"{:#b}\", Flags::ABC), \"0b111\");\n-        let extra = Flags::from_bits_retain(0b1010000);\n-        assert_eq!(format!(\"{:b}\", Flags::ABC | extra), \"1010111\");\n-        assert_eq!(format!(\"{:#b}\", Flags::ABC | extra), \"0b1010111\");\n-    }\n-\n-    #[test]\n-    fn test_octal() {\n-        assert_eq!(format!(\"{:o}\", LongFlags::LONG_A), \"177777\");\n-        assert_eq!(format!(\"{:#o}\", LongFlags::LONG_A), \"0o177777\");\n-        let extra = LongFlags::from_bits_retain(0o5000000);\n-        assert_eq!(format!(\"{:o}\", LongFlags::LONG_A | extra), \"5177777\");\n-        assert_eq!(format!(\"{:#o}\", LongFlags::LONG_A | extra), \"0o5177777\");\n-    }\n-\n-    #[test]\n-    fn test_lowerhex() {\n-        assert_eq!(format!(\"{:x}\", LongFlags::LONG_A), \"ffff\");\n-        assert_eq!(format!(\"{:#x}\", LongFlags::LONG_A), \"0xffff\");\n-        let extra = LongFlags::from_bits_retain(0xe00000);\n-        assert_eq!(format!(\"{:x}\", LongFlags::LONG_A | extra), \"e0ffff\");\n-        assert_eq!(format!(\"{:#x}\", LongFlags::LONG_A | extra), \"0xe0ffff\");\n-    }\n-\n-    #[test]\n-    fn test_upperhex() {\n-        assert_eq!(format!(\"{:X}\", LongFlags::LONG_A), \"FFFF\");\n-        assert_eq!(format!(\"{:#X}\", LongFlags::LONG_A), \"0xFFFF\");\n-        let extra = LongFlags::from_bits_retain(0xe00000);\n-        assert_eq!(format!(\"{:X}\", LongFlags::LONG_A | extra), \"E0FFFF\");\n-        assert_eq!(format!(\"{:#X}\", LongFlags::LONG_A | extra), \"0xE0FFFF\");\n-    }\n-\n-    mod submodule {\n-        bitflags! {\n-            #[derive(Clone, Copy)]\n-            pub struct PublicFlags: i8 {\n-                const X = 0;\n-            }\n-\n-            #[derive(Clone, Copy)]\n-            struct PrivateFlags: i8 {\n-                const Y = 0;\n-            }\n-        }\n-\n-        #[test]\n-        fn test_private() {\n-            let _ = PrivateFlags::Y;\n-        }\n-    }\n-\n-    #[test]\n-    fn test_public() {\n-        let _ = submodule::PublicFlags::X;\n-    }\n-\n-    mod t1 {\n-        mod foo {\n-            pub type Bar = i32;\n-        }\n-\n-        bitflags! {\n-            \/\/\/ baz\n-            #[derive(Clone, Copy)]\n-            struct Flags: foo::Bar {\n-                const A = 0b00000001;\n-                #[cfg(foo)]\n-                const B = 0b00000010;\n-                #[cfg(foo)]\n-                const C = 0b00000010;\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_in_function() {\n-        bitflags! {\n-            #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n-            struct Flags: u8 {\n-                const A = 1;\n-                #[cfg(any())] \/\/ false\n-                const B = 2;\n-            }\n-        }\n-        assert_eq!(Flags::all(), Flags::A);\n-        assert_eq!(format!(\"{:?}\", Flags::A), \"Flags(A)\");\n-    }\n-\n-    #[test]\n-    fn test_deprecated() {\n-        bitflags! {\n-            #[derive(Clone, Copy)]\n-            pub struct TestFlags: u32 {\n-                #[deprecated(note = \"Use something else.\")]\n-                const ONE = 1;\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_pub_crate() {\n-        mod module {\n-            bitflags! {\n-                #[derive(Clone, Copy)]\n-                pub (crate) struct Test: u8 {\n-                    const FOO = 1;\n-                }\n-            }\n-        }\n-\n-        assert_eq!(module::Test::FOO.bits(), 1);\n-    }\n-\n-    #[test]\n-    fn test_pub_in_module() {\n-        mod module {\n-            mod submodule {\n-                bitflags! {\n-                    \/\/ `pub (in super)` means only the module `module` will\n-                    \/\/ be able to access this.\n-                    #[derive(Clone, Copy)]\n-                    pub (in super) struct Test: u8 {\n-                        const FOO = 1;\n-                    }\n-                }\n-            }\n-\n-            mod test {\n-                \/\/ Note: due to `pub (in super)`,\n-                \/\/ this cannot be accessed directly by the testing code.\n-                pub(super) fn value() -> u8 {\n-                    super::submodule::Test::FOO.bits()\n-                }\n-            }\n-\n-            pub fn value() -> u8 {\n-                test::value()\n-            }\n-        }\n-\n-        assert_eq!(module::value(), 1)\n-    }\n-\n-    #[test]\n-    fn test_zero_value_flags() {\n-        bitflags! {\n-            #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n-            struct Flags: u32 {\n-                const NONE = 0b0;\n-                const SOME = 0b1;\n-            }\n-        }\n-\n-        assert!(Flags::empty().contains(Flags::NONE));\n-        assert!(Flags::SOME.contains(Flags::NONE));\n-        assert!(Flags::NONE.is_empty());\n-\n-        assert_eq!(format!(\"{:?}\", Flags::SOME), \"Flags(NONE | SOME)\");\n-    }\n-\n-    #[test]\n-    fn test_empty_bitflags() {\n-        bitflags! {}\n-    }\n-\n-    #[test]\n-    fn test_u128_bitflags() {\n-        bitflags! {\n-            #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n-            struct Flags: u128 {\n-                const A = 0x0000_0000_0000_0000_0000_0000_0000_0001;\n-                const B = 0x0000_0000_0000_1000_0000_0000_0000_0000;\n-                const C = 0x8000_0000_0000_0000_0000_0000_0000_0000;\n-                const ABC = Self::A.bits() | Self::B.bits() | Self::C.bits();\n-            }\n-        }\n-\n-        assert_eq!(Flags::ABC, Flags::A | Flags::B | Flags::C);\n-        assert_eq!(Flags::A.bits(), 0x0000_0000_0000_0000_0000_0000_0000_0001);\n-        assert_eq!(Flags::B.bits(), 0x0000_0000_0000_1000_0000_0000_0000_0000);\n-        assert_eq!(Flags::C.bits(), 0x8000_0000_0000_0000_0000_0000_0000_0000);\n-        assert_eq!(Flags::ABC.bits(), 0x8000_0000_0000_1000_0000_0000_0000_0001);\n-        assert_eq!(format!(\"{:?}\", Flags::A), \"Flags(A)\");\n-        assert_eq!(format!(\"{:?}\", Flags::B), \"Flags(B)\");\n-        assert_eq!(format!(\"{:?}\", Flags::C), \"Flags(C)\");\n-        assert_eq!(format!(\"{:?}\", Flags::ABC), \"Flags(A | B | C)\");\n-    }\n-\n-    #[test]\n-    fn test_from_bits_edge_cases() {\n-        bitflags! {\n-            #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n-            struct Flags: u8 {\n-                const A = 0b00000001;\n-                const BC = 0b00000110;\n-            }\n-        }\n-\n-        let flags = Flags::from_bits(0b00000100);\n-        assert_eq!(flags, None);\n-        let flags = Flags::from_bits(0b00000101);\n-        assert_eq!(flags, None);\n-    }\n-\n-    #[test]\n-    fn test_from_bits_truncate_edge_cases() {\n-        bitflags! {\n-            #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n-            struct Flags: u8 {\n-                const A = 0b00000001;\n-                const BC = 0b00000110;\n-            }\n-        }\n-\n-        let flags = Flags::from_bits_truncate(0b00000100);\n-        assert_eq!(flags, Flags::empty());\n-        let flags = Flags::from_bits_truncate(0b00000101);\n-        assert_eq!(flags, Flags::A);\n-    }\n-\n-    #[test]\n-    fn test_iter() {\n-        bitflags! {\n-            #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n-            struct Flags: u32 {\n-                const ONE  = 0b001;\n-                const TWO  = 0b010;\n-                const THREE = 0b100;\n-                #[cfg(windows)]\n-                const FOUR_WIN = 0b1000;\n-                #[cfg(unix)]\n-                const FOUR_UNIX = 0b10000;\n-                const FIVE = 0b01000100;\n-            }\n-        }\n-\n-        let count = {\n-            #[cfg(any(unix, windows))]\n-            {\n-                5\n-            }\n-\n-            #[cfg(not(any(unix, windows)))]\n-            {\n-                4\n-            }\n-        };\n-\n-        let flags = Flags::all();\n-        assert_eq!(flags.into_iter().count(), count);\n-\n-        for flag in flags.into_iter() {\n-            assert!(flags.contains(flag));\n-        }\n-\n-        let mut iter = flags.iter_names();\n-\n-        assert_eq!(iter.next().unwrap(), (\"ONE\", Flags::ONE));\n-        assert_eq!(iter.next().unwrap(), (\"TWO\", Flags::TWO));\n-        assert_eq!(iter.next().unwrap(), (\"THREE\", Flags::THREE));\n-\n-        #[cfg(unix)]\n-        {\n-            assert_eq!(iter.next().unwrap(), (\"FOUR_UNIX\", Flags::FOUR_UNIX));\n-        }\n-        #[cfg(windows)]\n-        {\n-            assert_eq!(iter.next().unwrap(), (\"FOUR_WIN\", Flags::FOUR_WIN));\n-        }\n-\n-        assert_eq!(iter.next().unwrap(), (\"FIVE\", Flags::FIVE));\n-\n-        assert_eq!(iter.next(), None);\n-\n-        let flags = Flags::empty();\n-        assert_eq!(flags.into_iter().count(), 0);\n-\n-        let flags = Flags::ONE | Flags::THREE;\n-        assert_eq!(flags.into_iter().count(), 2);\n-\n-        let mut iter = flags.iter_names();\n-\n-        assert_eq!(iter.next().unwrap(), (\"ONE\", Flags::ONE));\n-        assert_eq!(iter.next().unwrap(), (\"THREE\", Flags::THREE));\n-        assert_eq!(iter.next(), None);\n-\n-        let flags = Flags::from_bits_retain(0b1000_0000);\n-        assert_eq!(flags.into_iter().count(), 1);\n-        assert_eq!(flags.iter_names().count(), 0);\n-    }\n-\n-    #[test]\n-    fn into_iter_from_iter_roundtrip() {\n-        let flags = Flags::ABC | Flags::from_bits_retain(0b1000_0000);\n-\n-        assert_eq!(flags, flags.into_iter().collect::<Flags>());\n-    }\n-\n-    #[test]\n-    fn test_from_name() {\n-        let flags = Flags::all();\n-\n-        let mut rebuilt = Flags::empty();\n-\n-        for (name, value) in flags.iter_names() {\n-            assert_eq!(value, Flags::from_name(name).unwrap());\n-\n-            rebuilt |= Flags::from_name(name).unwrap();\n-        }\n-\n-        assert_eq!(flags, rebuilt);\n-    }\n-\n-    #[test]\n-    fn bits_types() {\n-        bitflags! {\n-            pub struct I8: i8 {\n-                const A = 1;\n-            }\n-\n-            pub struct I16: i16 {\n-                const A = 1;\n-            }\n-\n-            pub struct I32: i32 {\n-                const A = 1;\n-            }\n-\n-            pub struct I64: i64 {\n-                const A = 1;\n-            }\n-\n-            pub struct I128: i128 {\n-                const A = 1;\n-            }\n-\n-            pub struct Isize: isize {\n-                const A = 1;\n-            }\n-\n-            pub struct U8: u8 {\n-                const A = 1;\n-            }\n-\n-            pub struct U16: u16 {\n-                const A = 1;\n-            }\n-\n-            pub struct U32: u32 {\n-                const A = 1;\n-            }\n-\n-            pub struct U64: u64 {\n-                const A = 1;\n-            }\n-\n-            pub struct U128: u128 {\n-                const A = 1;\n-            }\n-\n-            pub struct Usize: usize {\n-                const A = 1;\n-            }\n-        }\n-    }\n-}\n+mod tests;\ndiff --git \/dev\/null b\/src\/tests.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/src\/tests.rs\n@@ -0,0 +1,107 @@\n+mod all;\n+mod bits;\n+mod complement;\n+mod contains;\n+mod difference;\n+mod empty;\n+mod eq;\n+mod extend;\n+mod flags;\n+mod fmt;\n+mod from_bits;\n+mod from_bits_retain;\n+mod from_bits_truncate;\n+mod from_name;\n+mod insert;\n+mod intersection;\n+mod intersects;\n+mod is_all;\n+mod is_empty;\n+mod iter;\n+mod parser;\n+mod remove;\n+mod symmetric_difference;\n+mod union;\n+\n+bitflags! {\n+    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Clone, Copy)]\n+    pub struct TestFlags: u8 {\n+        \/\/\/ 1\n+        const A = 1;\n+\n+        \/\/\/ 1 << 1\n+        const B = 1 << 1;\n+\n+        \/\/\/ 1 << 2\n+        const C = 1 << 2;\n+\n+        \/\/\/ 1 | (1 << 1) | (1 << 2)\n+        const ABC = Self::A.bits() | Self::B.bits() | Self::C.bits();\n+    }\n+\n+    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Clone, Copy)]\n+    pub struct TestFlagsInvert: u8 {\n+        \/\/\/ 1 | (1 << 1) | (1 << 2)\n+        const ABC = Self::A.bits() | Self::B.bits() | Self::C.bits();\n+\n+        \/\/\/ 1\n+        const A = 1;\n+\n+        \/\/\/ 1 << 1\n+        const B = 1 << 1;\n+\n+        \/\/\/ 1 << 2\n+        const C = 1 << 2;\n+    }\n+\n+    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Clone, Copy)]\n+    pub struct TestZero: u8 {\n+        \/\/\/ 0\n+        const ZERO = 0;\n+    }\n+\n+    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Clone, Copy)]\n+    pub struct TestZeroOne: u8 {\n+        \/\/\/ 0\n+        const ZERO = 0;\n+\n+        \/\/\/ 1\n+        const ONE = 1;\n+    }\n+\n+    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Clone, Copy)]\n+    pub struct TestUnicode: u8 {\n+        \/\/\/ 1\n+        const \u4e00 = 1;\n+\n+        \/\/\/ 2\n+        const \u4e8c = 1 << 1;\n+    }\n+\n+    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Clone, Copy)]\n+    pub struct TestEmpty: u8 {}\n+\n+    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Clone, Copy)]\n+    pub struct TestOverlapping: u8 {\n+        \/\/\/ 1 | (1 << 1)\n+        const AB = 1 | (1 << 1);\n+\n+        \/\/\/ (1 << 1) | (1 << 2)\n+        const BC = (1 << 1) | (1 << 2);\n+    }\n+\n+    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Clone, Copy)]\n+    pub struct TestOverlappingFull: u8 {\n+        \/\/\/ 1\n+        const A = 1;\n+\n+        \/\/\/ 1\n+        const B = 1;\n+\n+        \/\/\/ 1\n+        const C = 1;\n+\n+        \/\/\/ 2\n+        const D = 1 << 1;\n+    }\n+}\ndiff --git \/dev\/null b\/src\/tests\/all.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/src\/tests\/all.rs\n@@ -0,0 +1,21 @@\n+use super::*;\n+\n+use crate::Flags;\n+\n+#[test]\n+fn cases() {\n+    case(1 | 1 << 1 | 1 << 2, TestFlags::all);\n+\n+    case(0, TestZero::all);\n+\n+    case(0, TestEmpty::all);\n+}\n+\n+#[track_caller]\n+fn case<T: Flags>(expected: T::Bits, inherent: impl FnOnce() -> T)\n+where\n+    <T as Flags>::Bits: std::fmt::Debug + PartialEq,\n+{\n+    assert_eq!(expected, inherent().bits(), \"T::all()\");\n+    assert_eq!(expected, T::all().bits(), \"Flags::all()\");\n+}\ndiff --git \/dev\/null b\/src\/tests\/bits.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/src\/tests\/bits.rs\n@@ -0,0 +1,30 @@\n+use super::*;\n+\n+use crate::Flags;\n+\n+#[test]\n+fn cases() {\n+    case(0, TestFlags::empty(), TestFlags::bits);\n+\n+    case(1, TestFlags::A, TestFlags::bits);\n+    case(1 | 1 << 1 | 1 << 2, TestFlags::ABC, TestFlags::bits);\n+\n+    case(!0, TestFlags::from_bits_retain(u8::MAX), TestFlags::bits);\n+    case(1 << 3, TestFlags::from_bits_retain(1 << 3), TestFlags::bits);\n+\n+    case(1 << 3, TestZero::from_bits_retain(1 << 3), TestZero::bits);\n+\n+    case(1 << 3, TestEmpty::from_bits_retain(1 << 3), TestEmpty::bits);\n+}\n+\n+#[track_caller]\n+fn case<T: Flags + std::fmt::Debug>(\n+    expected: T::Bits,\n+    value: T,\n+    inherent: impl FnOnce(&T) -> T::Bits,\n+) where\n+    T::Bits: std::fmt::Debug + PartialEq,\n+{\n+    assert_eq!(expected, inherent(&value), \"{:?}.bits()\", value);\n+    assert_eq!(expected, Flags::bits(&value), \"Flags::bits({:?})\", value);\n+}\ndiff --git \/dev\/null b\/src\/tests\/complement.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/src\/tests\/complement.rs\n@@ -0,0 +1,52 @@\n+use super::*;\n+\n+use crate::Flags;\n+\n+#[test]\n+fn cases() {\n+    case(0, TestFlags::all(), TestFlags::complement);\n+    case(0, TestFlags::from_bits_retain(!0), TestFlags::complement);\n+\n+    case(1 | 1 << 1, TestFlags::C, TestFlags::complement);\n+    case(\n+        1 | 1 << 1,\n+        TestFlags::C | TestFlags::from_bits_retain(1 << 3),\n+        TestFlags::complement,\n+    );\n+\n+    case(\n+        1 | 1 << 1 | 1 << 2,\n+        TestFlags::empty(),\n+        TestFlags::complement,\n+    );\n+    case(\n+        1 | 1 << 1 | 1 << 2,\n+        TestFlags::from_bits_retain(1 << 3),\n+        TestFlags::complement,\n+    );\n+\n+    case(0, TestZero::empty(), TestZero::complement);\n+\n+    case(0, TestEmpty::empty(), TestEmpty::complement);\n+\n+    \/\/ Complement doesn't detect overlapping bits in multi-bit flags\n+    case(0, TestOverlapping::AB, TestOverlapping::complement);\n+}\n+\n+#[track_caller]\n+fn case<T: Flags + std::fmt::Debug + std::ops::Not<Output = T> + Copy>(\n+    expected: T::Bits,\n+    value: T,\n+    inherent: impl FnOnce(T) -> T,\n+) where\n+    T::Bits: std::fmt::Debug + PartialEq,\n+{\n+    assert_eq!(expected, inherent(value).bits(), \"{:?}.complement()\", value);\n+    assert_eq!(\n+        expected,\n+        Flags::complement(value).bits(),\n+        \"Flags::complement({:?})\",\n+        value\n+    );\n+    assert_eq!(expected, (!value).bits(), \"!{:?}\", value);\n+}\ndiff --git \/dev\/null b\/src\/tests\/contains.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/src\/tests\/contains.rs\n@@ -0,0 +1,97 @@\n+use super::*;\n+\n+use crate::Flags;\n+\n+#[test]\n+fn cases() {\n+    case(\n+        TestFlags::empty(),\n+        &[\n+            (TestFlags::empty(), true),\n+            (TestFlags::A, false),\n+            (TestFlags::B, false),\n+            (TestFlags::C, false),\n+            (TestFlags::from_bits_retain(1 << 3), false),\n+        ],\n+        TestFlags::contains,\n+    );\n+\n+    case(\n+        TestFlags::A,\n+        &[\n+            (TestFlags::empty(), true),\n+            (TestFlags::A, true),\n+            (TestFlags::B, false),\n+            (TestFlags::C, false),\n+            (TestFlags::ABC, false),\n+            (TestFlags::from_bits_retain(1 << 3), false),\n+            (TestFlags::from_bits_retain(1 | (1 << 3)), false),\n+        ],\n+        TestFlags::contains,\n+    );\n+\n+    case(\n+        TestFlags::ABC,\n+        &[\n+            (TestFlags::empty(), true),\n+            (TestFlags::A, true),\n+            (TestFlags::B, true),\n+            (TestFlags::C, true),\n+            (TestFlags::ABC, true),\n+            (TestFlags::from_bits_retain(1 << 3), false),\n+        ],\n+        TestFlags::contains,\n+    );\n+\n+    case(\n+        TestFlags::from_bits_retain(1 << 3),\n+        &[\n+            (TestFlags::empty(), true),\n+            (TestFlags::A, false),\n+            (TestFlags::B, false),\n+            (TestFlags::C, false),\n+            (TestFlags::from_bits_retain(1 << 3), true),\n+        ],\n+        TestFlags::contains,\n+    );\n+\n+    case(\n+        TestZero::ZERO,\n+        &[(TestZero::ZERO, true)],\n+        TestZero::contains,\n+    );\n+\n+    case(\n+        TestOverlapping::AB,\n+        &[\n+            (TestOverlapping::AB, true),\n+            (TestOverlapping::BC, false),\n+            (TestOverlapping::from_bits_retain(1 << 1), true),\n+        ],\n+        TestOverlapping::contains,\n+    );\n+}\n+\n+#[track_caller]\n+fn case<T: Flags + std::fmt::Debug + Copy>(\n+    value: T,\n+    inputs: &[(T, bool)],\n+    mut inherent: impl FnMut(&T, T) -> bool,\n+) {\n+    for (input, expected) in inputs {\n+        assert_eq!(\n+            *expected,\n+            inherent(&value, *input),\n+            \"{:?}.contains({:?})\",\n+            value,\n+            input\n+        );\n+        assert_eq!(\n+            *expected,\n+            Flags::contains(&value, *input),\n+            \"Flags::contains({:?}, {:?})\",\n+            value,\n+            input\n+        );\n+    }\n+}\ndiff --git \/dev\/null b\/src\/tests\/difference.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/src\/tests\/difference.rs\n@@ -0,0 +1,81 @@\n+use super::*;\n+\n+use crate::Flags;\n+\n+#[test]\n+fn cases() {\n+    case(\n+        TestFlags::A | TestFlags::B,\n+        &[\n+            (TestFlags::A, 1 << 1),\n+            (TestFlags::B, 1),\n+            (TestFlags::from_bits_retain(1 << 3), 1 | 1 << 1),\n+        ],\n+        TestFlags::difference,\n+    );\n+\n+    case(\n+        TestFlags::from_bits_retain(1 | 1 << 3),\n+        &[\n+            (TestFlags::A, 1 << 3),\n+            (TestFlags::from_bits_retain(1 << 3), 1),\n+        ],\n+        TestFlags::difference,\n+    );\n+\n+    assert_eq!(\n+        0b1111_1110,\n+        (TestFlags::from_bits_retain(!0).difference(TestFlags::A)).bits()\n+    );\n+\n+    \/\/ The `!` operator unsets bits that don't correspond to known flags\n+    assert_eq!(\n+        1 << 1 | 1 << 2,\n+        (TestFlags::from_bits_retain(!0) & !TestFlags::A).bits()\n+    );\n+}\n+\n+#[track_caller]\n+fn case<T: Flags + std::fmt::Debug + std::ops::Sub<Output = T> + std::ops::SubAssign + Copy>(\n+    value: T,\n+    inputs: &[(T, T::Bits)],\n+    mut inherent: impl FnMut(T, T) -> T,\n+) where\n+    T::Bits: std::fmt::Debug + PartialEq + Copy,\n+{\n+    for (input, expected) in inputs {\n+        assert_eq!(\n+            *expected,\n+            inherent(value, *input).bits(),\n+            \"{:?}.difference({:?})\",\n+            value,\n+            input\n+        );\n+        assert_eq!(\n+            *expected,\n+            Flags::difference(value, *input).bits(),\n+            \"Flags::difference({:?}, {:?})\",\n+            value,\n+            input\n+        );\n+        assert_eq!(\n+            *expected,\n+            (value - *input).bits(),\n+            \"{:?} - {:?}\",\n+            value,\n+            input\n+        );\n+        assert_eq!(\n+            *expected,\n+            {\n+                let mut value = value;\n+                value -= *input;\n+                value\n+            }\n+            .bits(),\n+            \"{:?} -= {:?}\",\n+            value,\n+            input,\n+        );\n+    }\n+}\ndiff --git \/dev\/null b\/src\/tests\/empty.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/src\/tests\/empty.rs\n@@ -0,0 +1,21 @@\n+use super::*;\n+\n+use crate::Flags;\n+\n+#[test]\n+fn cases() {\n+    case(0, TestFlags::empty);\n+\n+    case(0, TestZero::empty);\n+\n+    case(0, TestEmpty::empty);\n+}\n+\n+#[track_caller]\n+fn case<T: Flags>(expected: T::Bits, inherent: impl FnOnce() -> T)\n+where\n+    <T as Flags>::Bits: std::fmt::Debug + PartialEq,\n+{\n+    assert_eq!(expected, inherent().bits(), \"T::empty()\");\n+    assert_eq!(expected, T::empty().bits(), \"Flags::empty()\");\n+}\ndiff --git \/dev\/null b\/src\/tests\/eq.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/src\/tests\/eq.rs\n@@ -0,0 +1,10 @@\n+use super::*;\n+\n+#[test]\n+fn cases() {\n+    assert_eq!(TestFlags::empty(), TestFlags::empty());\n+    assert_eq!(TestFlags::all(), TestFlags::all());\n+\n+    assert!(TestFlags::from_bits_retain(1) < TestFlags::from_bits_retain(2));\n+    assert!(TestFlags::from_bits_retain(2) > TestFlags::from_bits_retain(1));\n+}\ndiff --git \/dev\/null b\/src\/tests\/extend.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/src\/tests\/extend.rs\n@@ -0,0 +1,18 @@\n+use super::*;\n+\n+#[test]\n+fn cases() {\n+    let mut flags = TestFlags::empty();\n+\n+    flags.extend(TestFlags::A);\n+\n+    assert_eq!(TestFlags::A, flags);\n+\n+    flags.extend(TestFlags::A | TestFlags::B | TestFlags::C);\n+\n+    assert_eq!(TestFlags::ABC, flags);\n+\n+    flags.extend(TestFlags::from_bits_retain(1 << 5));\n+\n+    assert_eq!(TestFlags::ABC | TestFlags::from_bits_retain(1 << 5), flags);\n+}\ndiff --git \/dev\/null b\/src\/tests\/flags.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/src\/tests\/flags.rs\n@@ -0,0 +1,23 @@\n+use super::*;\n+\n+use crate::Flags;\n+\n+#[test]\n+fn cases() {\n+    let flags = TestFlags::FLAGS\n+        .iter()\n+        .map(|flag| (flag.name(), flag.value().bits()))\n+        .collect::<Vec<_>>();\n+\n+    assert_eq!(\n+        vec![\n+            (\"A\", 1u8),\n+            (\"B\", 1 << 1),\n+            (\"C\", 1 << 2),\n+            (\"ABC\", 1 | 1 << 1 | 1 << 2),\n+        ],\n+        flags,\n+    );\n+\n+    assert_eq!(0, TestEmpty::FLAGS.iter().count());\n+}\ndiff --git \/dev\/null b\/src\/tests\/fmt.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/src\/tests\/fmt.rs\n@@ -0,0 +1,70 @@\n+use super::*;\n+\n+#[test]\n+fn cases() {\n+    case(TestFlags::empty(), \"TestFlags(0x0)\", \"0\", \"0\", \"0\", \"0\");\n+    case(TestFlags::A, \"TestFlags(A)\", \"1\", \"1\", \"1\", \"1\");\n+    case(\n+        TestFlags::all(),\n+        \"TestFlags(A | B | C)\",\n+        \"7\",\n+        \"7\",\n+        \"7\",\n+        \"111\",\n+    );\n+    case(\n+        TestFlags::from_bits_retain(1 << 3),\n+        \"TestFlags(0x8)\",\n+        \"8\",\n+        \"8\",\n+        \"10\",\n+        \"1000\",\n+    );\n+    case(\n+        TestFlags::A | TestFlags::from_bits_retain(1 << 3),\n+        \"TestFlags(A | 0x8)\",\n+        \"9\",\n+        \"9\",\n+        \"11\",\n+        \"1001\",\n+    );\n+\n+    case(TestZero::ZERO, \"TestZero(0x0)\", \"0\", \"0\", \"0\", \"0\");\n+    case(\n+        TestZero::ZERO | TestZero::from_bits_retain(1),\n+        \"TestZero(0x1)\",\n+        \"1\",\n+        \"1\",\n+        \"1\",\n+        \"1\",\n+    );\n+\n+    case(TestZeroOne::ONE, \"TestZeroOne(ONE)\", \"1\", \"1\", \"1\", \"1\");\n+\n+    case(\n+        TestOverlapping::from_bits_retain(1 << 1),\n+        \"TestOverlapping(0x2)\",\n+        \"2\",\n+        \"2\",\n+        \"2\",\n+        \"10\",\n+    );\n+}\n+\n+#[track_caller]\n+fn case<\n+    T: std::fmt::Debug + std::fmt::UpperHex + std::fmt::LowerHex + std::fmt::Octal + std::fmt::Binary,\n+>(\n+    value: T,\n+    debug: &str,\n+    uhex: &str,\n+    lhex: &str,\n+    oct: &str,\n+    bin: &str,\n+) {\n+    assert_eq!(debug, format!(\"{:?}\", value));\n+    assert_eq!(uhex, format!(\"{:X}\", value));\n+    assert_eq!(lhex, format!(\"{:x}\", value));\n+    assert_eq!(oct, format!(\"{:o}\", value));\n+    assert_eq!(bin, format!(\"{:b}\", value));\n+}\ndiff --git \/dev\/null b\/src\/tests\/from_bits.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/src\/tests\/from_bits.rs\n@@ -0,0 +1,43 @@\n+use super::*;\n+\n+use crate::Flags;\n+\n+#[test]\n+fn cases() {\n+    case(Some(0), 0, TestFlags::from_bits);\n+    case(Some(1), 1, TestFlags::from_bits);\n+    case(\n+        Some(1 | 1 << 1 | 1 << 2),\n+        1 | 1 << 1 | 1 << 2,\n+        TestFlags::from_bits,\n+    );\n+\n+    case(None, 1 << 3, TestFlags::from_bits);\n+    case(None, 1 | 1 << 3, TestFlags::from_bits);\n+\n+    case(Some(1 | 1 << 1), 1 | 1 << 1, TestOverlapping::from_bits);\n+\n+    case(None, 1 << 1, TestOverlapping::from_bits);\n+}\n+\n+#[track_caller]\n+fn case<T: Flags>(\n+    expected: Option<T::Bits>,\n+    input: T::Bits,\n+    inherent: impl FnOnce(T::Bits) -> Option<T>,\n+) where\n+    <T as Flags>::Bits: std::fmt::Debug + PartialEq,\n+{\n+    assert_eq!(\n+        expected,\n+        inherent(input).map(|f| f.bits()),\n+        \"T::from_bits({:?})\",\n+        input\n+    );\n+    assert_eq!(\n+        expected,\n+        T::from_bits(input).map(|f| f.bits()),\n+        \"Flags::from_bits({:?})\",\n+        input\n+    );\n+}\ndiff --git \/dev\/null b\/src\/tests\/from_bits_retain.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/src\/tests\/from_bits_retain.rs\n@@ -0,0 +1,36 @@\n+use super::*;\n+\n+use crate::Flags;\n+\n+#[test]\n+fn cases() {\n+    case(0, TestFlags::from_bits_retain);\n+    case(1, TestFlags::from_bits_retain);\n+    case(1 | 1 << 1 | 1 << 2, TestFlags::from_bits_retain);\n+\n+    case(1 << 3, TestFlags::from_bits_retain);\n+    case(1 | 1 << 3, TestFlags::from_bits_retain);\n+\n+    case(1 | 1 << 1, TestOverlapping::from_bits_retain);\n+\n+    case(1 << 1, TestOverlapping::from_bits_retain);\n+}\n+\n+#[track_caller]\n+fn case<T: Flags>(input: T::Bits, inherent: impl FnOnce(T::Bits) -> T)\n+where\n+    <T as Flags>::Bits: std::fmt::Debug + PartialEq,\n+{\n+    assert_eq!(\n+        input,\n+        inherent(input).bits(),\n+        \"T::from_bits_retain({:?})\",\n+        input\n+    );\n+    assert_eq!(\n+        input,\n+        T::from_bits_retain(input).bits(),\n+        \"Flags::from_bits_retain({:?})\",\n+        input\n+    );\n+}\ndiff --git \/dev\/null b\/src\/tests\/from_bits_truncate.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/src\/tests\/from_bits_truncate.rs\n@@ -0,0 +1,40 @@\n+use super::*;\n+\n+use crate::Flags;\n+\n+#[test]\n+fn cases() {\n+    case(0, 0, TestFlags::from_bits_truncate);\n+    case(1, 1, TestFlags::from_bits_truncate);\n+    case(\n+        1 | 1 << 1 | 1 << 2,\n+        1 | 1 << 1 | 1 << 2,\n+        TestFlags::from_bits_truncate,\n+    );\n+\n+    case(0, 1 << 3, TestFlags::from_bits_truncate);\n+    case(1, 1 | 1 << 3, TestFlags::from_bits_truncate);\n+\n+    case(1 | 1 << 1, 1 | 1 << 1, TestOverlapping::from_bits_truncate);\n+\n+    case(0, 1 << 1, TestOverlapping::from_bits_truncate);\n+}\n+\n+#[track_caller]\n+fn case<T: Flags>(expected: T::Bits, input: T::Bits, inherent: impl FnOnce(T::Bits) -> T)\n+where\n+    <T as Flags>::Bits: std::fmt::Debug + PartialEq,\n+{\n+    assert_eq!(\n+        expected,\n+        inherent(input).bits(),\n+        \"T::from_bits_truncate({:?})\",\n+        input\n+    );\n+    assert_eq!(\n+        expected,\n+        T::from_bits_truncate(input).bits(),\n+        \"Flags::from_bits_truncate({:?})\",\n+        input\n+    );\n+}\ndiff --git \/dev\/null b\/src\/tests\/from_name.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/src\/tests\/from_name.rs\n@@ -0,0 +1,38 @@\n+use super::*;\n+\n+use crate::Flags;\n+\n+#[test]\n+fn cases() {\n+    case(Some(1), \"A\", TestFlags::from_name);\n+    case(Some(1 << 1), \"B\", TestFlags::from_name);\n+    case(Some(1 | 1 << 1 | 1 << 2), \"ABC\", TestFlags::from_name);\n+\n+    case(None, \"\", TestFlags::from_name);\n+    case(None, \"a\", TestFlags::from_name);\n+    case(None, \"0x1\", TestFlags::from_name);\n+    case(None, \"A | B\", TestFlags::from_name);\n+\n+    case(Some(0), \"ZERO\", TestZero::from_name);\n+\n+    case(Some(2), \"\u4e8c\", TestUnicode::from_name);\n+}\n+\n+#[track_caller]\n+fn case<T: Flags>(expected: Option<T::Bits>, input: &str, inherent: impl FnOnce(&str) -> Option<T>)\n+where\n+    <T as Flags>::Bits: std::fmt::Debug + PartialEq,\n+{\n+    assert_eq!(\n+        expected,\n+        inherent(input).map(|f| f.bits()),\n+        \"T::from_name({:?})\",\n+        input\n+    );\n+    assert_eq!(\n+        expected,\n+        T::from_name(input).map(|f| f.bits()),\n+        \"Flags::from_name({:?})\",\n+        input\n+    );\n+}\ndiff --git \/dev\/null b\/src\/tests\/insert.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/src\/tests\/insert.rs\n@@ -0,0 +1,91 @@\n+use super::*;\n+\n+use crate::Flags;\n+\n+#[test]\n+fn cases() {\n+    case(\n+        TestFlags::empty(),\n+        &[\n+            (TestFlags::A, 1),\n+            (TestFlags::A | TestFlags::B, 1 | 1 << 1),\n+            (TestFlags::empty(), 0),\n+            (TestFlags::from_bits_retain(1 << 3), 1 << 3),\n+        ],\n+        TestFlags::insert,\n+        TestFlags::set,\n+    );\n+\n+    case(\n+        TestFlags::A,\n+        &[\n+            (TestFlags::A, 1),\n+            (TestFlags::empty(), 1),\n+            (TestFlags::B, 1 | 1 << 1),\n+        ],\n+        TestFlags::insert,\n+        TestFlags::set,\n+    );\n+}\n+\n+#[track_caller]\n+fn case<T: Flags + std::fmt::Debug + Copy>(\n+    value: T,\n+    inputs: &[(T, T::Bits)],\n+    mut inherent_insert: impl FnMut(&mut T, T),\n+    mut inherent_set: impl FnMut(&mut T, T, bool),\n+) where\n+    T::Bits: std::fmt::Debug + PartialEq + Copy,\n+{\n+    for (input, expected) in inputs {\n+        assert_eq!(\n+            *expected,\n+            {\n+                let mut value = value;\n+                inherent_insert(&mut value, *input);\n+                value\n+            }\n+            .bits(),\n+            \"{:?}.insert({:?})\",\n+            value,\n+            input\n+        );\n+        assert_eq!(\n+            *expected,\n+            {\n+                let mut value = value;\n+                Flags::insert(&mut value, *input);\n+                value\n+            }\n+            .bits(),\n+            \"Flags::insert({:?}, {:?})\",\n+            value,\n+            input\n+        );\n+\n+        assert_eq!(\n+            *expected,\n+            {\n+                let mut value = value;\n+                inherent_set(&mut value, *input, true);\n+                value\n+            }\n+            .bits(),\n+            \"{:?}.set({:?}, true)\",\n+            value,\n+            input\n+        );\n+        assert_eq!(\n+            *expected,\n+            {\n+                let mut value = value;\n+                Flags::set(&mut value, *input, true);\n+                value\n+            }\n+            .bits(),\n+            \"Flags::set({:?}, {:?}, true)\",\n+            value,\n+            input\n+        );\n+    }\n+}\ndiff --git \/dev\/null b\/src\/tests\/intersection.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/src\/tests\/intersection.rs\n@@ -0,0 +1,79 @@\n+use super::*;\n+\n+use crate::Flags;\n+\n+#[test]\n+fn cases() {\n+    case(\n+        TestFlags::empty(),\n+        &[(TestFlags::empty(), 0), (TestFlags::all(), 0)],\n+        TestFlags::intersection,\n+    );\n+\n+    case(\n+        TestFlags::all(),\n+        &[\n+            (TestFlags::all(), 1 | 1 << 1 | 1 << 2),\n+            (TestFlags::A, 1),\n+            (TestFlags::from_bits_retain(1 << 3), 0),\n+        ],\n+        TestFlags::intersection,\n+    );\n+\n+    case(\n+        TestFlags::from_bits_retain(1 << 3),\n+        &[(TestFlags::from_bits_retain(1 << 3), 1 << 3)],\n+        TestFlags::intersection,\n+    );\n+\n+    case(\n+        TestOverlapping::AB,\n+        &[(TestOverlapping::BC, 1 << 1)],\n+        TestOverlapping::intersection,\n+    );\n+}\n+\n+#[track_caller]\n+fn case<T: Flags + std::fmt::Debug + std::ops::BitAnd<Output = T> + std::ops::BitAndAssign + Copy>(\n+    value: T,\n+    inputs: &[(T, T::Bits)],\n+    mut inherent: impl FnMut(T, T) -> T,\n+) where\n+    T::Bits: std::fmt::Debug + PartialEq + Copy,\n+{\n+    for (input, expected) in inputs {\n+        assert_eq!(\n+            *expected,\n+            inherent(value, *input).bits(),\n+            \"{:?}.intersection({:?})\",\n+            value,\n+            input\n+        );\n+        assert_eq!(\n+            *expected,\n+            Flags::intersection(value, *input).bits(),\n+            \"Flags::intersection({:?}, {:?})\",\n+            value,\n+            input\n+        );\n+        assert_eq!(\n+            *expected,\n+            (value & *input).bits(),\n+            \"{:?} & {:?}\",\n+            value,\n+            input\n+        );\n+        assert_eq!(\n+            *expected,\n+            {\n+                let mut value = value;\n+                value &= *input;\n+                value\n+            }\n+            .bits(),\n+            \"{:?} &= {:?}\",\n+            value,\n+            input,\n+        );\n+    }\n+}\ndiff --git \/dev\/null b\/src\/tests\/intersects.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/src\/tests\/intersects.rs\n@@ -0,0 +1,91 @@\n+use super::*;\n+\n+use crate::Flags;\n+\n+#[test]\n+fn cases() {\n+    case(\n+        TestFlags::empty(),\n+        &[\n+            (TestFlags::empty(), false),\n+            (TestFlags::A, false),\n+            (TestFlags::B, false),\n+            (TestFlags::C, false),\n+            (TestFlags::from_bits_retain(1 << 3), false),\n+        ],\n+        TestFlags::intersects,\n+    );\n+\n+    case(\n+        TestFlags::A,\n+        &[\n+            (TestFlags::empty(), false),\n+            (TestFlags::A, true),\n+            (TestFlags::B, false),\n+            (TestFlags::C, false),\n+            (TestFlags::ABC, true),\n+            (TestFlags::from_bits_retain(1 << 3), false),\n+            (TestFlags::from_bits_retain(1 | (1 << 3)), true),\n+        ],\n+        TestFlags::intersects,\n+    );\n+\n+    case(\n+        TestFlags::ABC,\n+        &[\n+            (TestFlags::empty(), false),\n+            (TestFlags::A, true),\n+            (TestFlags::B, true),\n+            (TestFlags::C, true),\n+            (TestFlags::ABC, true),\n+            (TestFlags::from_bits_retain(1 << 3), false),\n+        ],\n+        TestFlags::intersects,\n+    );\n+\n+    case(\n+        TestFlags::from_bits_retain(1 << 3),\n+        &[\n+            (TestFlags::empty(), false),\n+            (TestFlags::A, false),\n+            (TestFlags::B, false),\n+            (TestFlags::C, false),\n+            (TestFlags::from_bits_retain(1 << 3), true),\n+        ],\n+        TestFlags::intersects,\n+    );\n+\n+    case(\n+        TestOverlapping::AB,\n+        &[\n+            (TestOverlapping::AB, true),\n+            (TestOverlapping::BC, true),\n+            (TestOverlapping::from_bits_retain(1 << 1), true),\n+        ],\n+        TestOverlapping::intersects,\n+    );\n+}\n+\n+#[track_caller]\n+fn case<T: Flags + std::fmt::Debug + Copy>(\n+    value: T,\n+    inputs: &[(T, bool)],\n+    mut inherent: impl FnMut(&T, T) -> bool,\n+) {\n+    for (input, expected) in inputs {\n+        assert_eq!(\n+            *expected,\n+            inherent(&value, *input),\n+            \"{:?}.intersects({:?})\",\n+            value,\n+            input\n+        );\n+        assert_eq!(\n+            *expected,\n+            Flags::intersects(&value, *input),\n+            \"Flags::intersects({:?}, {:?})\",\n+            value,\n+            input\n+        );\n+    }\n+}\ndiff --git \/dev\/null b\/src\/tests\/is_all.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/src\/tests\/is_all.rs\n@@ -0,0 +1,32 @@\n+use super::*;\n+\n+use crate::Flags;\n+\n+#[test]\n+fn cases() {\n+    case(false, TestFlags::empty(), TestFlags::is_all);\n+    case(false, TestFlags::A, TestFlags::is_all);\n+\n+    case(true, TestFlags::ABC, TestFlags::is_all);\n+\n+    case(\n+        true,\n+        TestFlags::ABC | TestFlags::from_bits_retain(1 << 3),\n+        TestFlags::is_all,\n+    );\n+\n+    case(true, TestZero::empty(), TestZero::is_all);\n+\n+    case(true, TestEmpty::empty(), TestEmpty::is_all);\n+}\n+\n+#[track_caller]\n+fn case<T: Flags + std::fmt::Debug>(expected: bool, value: T, inherent: impl FnOnce(&T) -> bool) {\n+    assert_eq!(expected, inherent(&value), \"{:?}.is_all()\", value);\n+    assert_eq!(\n+        expected,\n+        Flags::is_all(&value),\n+        \"Flags::is_all({:?})\",\n+        value\n+    );\n+}\ndiff --git \/dev\/null b\/src\/tests\/is_empty.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/src\/tests\/is_empty.rs\n@@ -0,0 +1,31 @@\n+use super::*;\n+\n+use crate::Flags;\n+\n+#[test]\n+fn cases() {\n+    case(true, TestFlags::empty(), TestFlags::is_empty);\n+\n+    case(false, TestFlags::A, TestFlags::is_empty);\n+    case(false, TestFlags::ABC, TestFlags::is_empty);\n+    case(\n+        false,\n+        TestFlags::from_bits_retain(1 << 3),\n+        TestFlags::is_empty,\n+    );\n+\n+    case(true, TestZero::empty(), TestZero::is_empty);\n+\n+    case(true, TestEmpty::empty(), TestEmpty::is_empty);\n+}\n+\n+#[track_caller]\n+fn case<T: Flags + std::fmt::Debug>(expected: bool, value: T, inherent: impl FnOnce(&T) -> bool) {\n+    assert_eq!(expected, inherent(&value), \"{:?}.is_empty()\", value);\n+    assert_eq!(\n+        expected,\n+        Flags::is_empty(&value),\n+        \"Flags::is_empty({:?})\",\n+        value\n+    );\n+}\ndiff --git \/dev\/null b\/src\/tests\/iter.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/src\/tests\/iter.rs\n@@ -0,0 +1,186 @@\n+use super::*;\n+\n+use crate::Flags;\n+\n+#[test]\n+fn roundtrip() {\n+    for a in 0u8..=255 {\n+        for b in 0u8..=255 {\n+            let f = TestFlags::from_bits_retain(a | b);\n+\n+            assert_eq!(f, f.iter().collect::<TestFlags>());\n+            assert_eq!(\n+                TestFlags::from_bits_truncate(f.bits()),\n+                f.iter_names().map(|(_, f)| f).collect::<TestFlags>()\n+            );\n+        }\n+    }\n+}\n+\n+mod collect {\n+    use super::*;\n+\n+    #[test]\n+    fn cases() {\n+        assert_eq!(0, [].into_iter().collect::<TestFlags>().bits());\n+\n+        assert_eq!(1, [TestFlags::A,].into_iter().collect::<TestFlags>().bits());\n+\n+        assert_eq!(\n+            1 | 1 << 1 | 1 << 2,\n+            [TestFlags::A, TestFlags::B | TestFlags::C,]\n+                .into_iter()\n+                .collect::<TestFlags>()\n+                .bits()\n+        );\n+\n+        assert_eq!(\n+            1 | 1 << 3,\n+            [\n+                TestFlags::from_bits_retain(1 << 3),\n+                TestFlags::empty(),\n+                TestFlags::A,\n+            ]\n+            .into_iter()\n+            .collect::<TestFlags>()\n+            .bits()\n+        );\n+    }\n+}\n+\n+mod iter {\n+    use super::*;\n+\n+    #[test]\n+    fn cases() {\n+        case(&[], TestFlags::empty(), TestFlags::iter);\n+\n+        case(&[1], TestFlags::A, TestFlags::iter);\n+        case(&[1, 1 << 1], TestFlags::A | TestFlags::B, TestFlags::iter);\n+        case(\n+            &[1, 1 << 1, 1 << 3],\n+            TestFlags::A | TestFlags::B | TestFlags::from_bits_retain(1 << 3),\n+            TestFlags::iter,\n+        );\n+\n+        case(&[1, 1 << 1, 1 << 2], TestFlags::ABC, TestFlags::iter);\n+        case(\n+            &[1, 1 << 1, 1 << 2, 1 << 3],\n+            TestFlags::ABC | TestFlags::from_bits_retain(1 << 3),\n+            TestFlags::iter,\n+        );\n+\n+        case(\n+            &[1 | 1 << 1 | 1 << 2],\n+            TestFlagsInvert::ABC,\n+            TestFlagsInvert::iter,\n+        );\n+\n+        case(&[], TestZero::ZERO, TestZero::iter);\n+    }\n+\n+    #[track_caller]\n+    fn case<T: Flags + std::fmt::Debug + IntoIterator<Item = T> + Copy>(\n+        expected: &[T::Bits],\n+        value: T,\n+        inherent: impl FnOnce(&T) -> crate::iter::Iter<T>,\n+    ) where\n+        T::Bits: std::fmt::Debug + PartialEq,\n+    {\n+        assert_eq!(\n+            expected,\n+            inherent(&value).map(|f| f.bits()).collect::<Vec<_>>(),\n+            \"{:?}.iter()\",\n+            value\n+        );\n+        assert_eq!(\n+            expected,\n+            Flags::iter(&value).map(|f| f.bits()).collect::<Vec<_>>(),\n+            \"Flags::iter({:?})\",\n+            value\n+        );\n+        assert_eq!(\n+            expected,\n+            value.into_iter().map(|f| f.bits()).collect::<Vec<_>>(),\n+            \"{:?}.into_iter()\",\n+            value\n+        );\n+    }\n+}\n+\n+mod iter_names {\n+    use super::*;\n+\n+    #[test]\n+    fn cases() {\n+        case(&[], TestFlags::empty(), TestFlags::iter_names);\n+\n+        case(&[(\"A\", 1)], TestFlags::A, TestFlags::iter_names);\n+        case(\n+            &[(\"A\", 1), (\"B\", 1 << 1)],\n+            TestFlags::A | TestFlags::B,\n+            TestFlags::iter_names,\n+        );\n+        case(\n+            &[(\"A\", 1), (\"B\", 1 << 1)],\n+            TestFlags::A | TestFlags::B | TestFlags::from_bits_retain(1 << 3),\n+            TestFlags::iter_names,\n+        );\n+\n+        case(\n+            &[(\"A\", 1), (\"B\", 1 << 1), (\"C\", 1 << 2)],\n+            TestFlags::ABC,\n+            TestFlags::iter_names,\n+        );\n+        case(\n+            &[(\"A\", 1), (\"B\", 1 << 1), (\"C\", 1 << 2)],\n+            TestFlags::ABC | TestFlags::from_bits_retain(1 << 3),\n+            TestFlags::iter_names,\n+        );\n+\n+        case(\n+            &[(\"ABC\", 1 | 1 << 1 | 1 << 2)],\n+            TestFlagsInvert::ABC,\n+            TestFlagsInvert::iter_names,\n+        );\n+\n+        case(&[], TestZero::ZERO, TestZero::iter_names);\n+\n+        case(\n+            &[(\"A\", 1)],\n+            TestOverlappingFull::A,\n+            TestOverlappingFull::iter_names,\n+        );\n+        case(\n+            &[(\"A\", 1), (\"D\", 1 << 1)],\n+            TestOverlappingFull::A | TestOverlappingFull::D,\n+            TestOverlappingFull::iter_names,\n+        );\n+    }\n+\n+    #[track_caller]\n+    fn case<T: Flags + std::fmt::Debug>(\n+        expected: &[(&'static str, T::Bits)],\n+        value: T,\n+        inherent: impl FnOnce(&T) -> crate::iter::IterNames<T>,\n+    ) where\n+        T::Bits: std::fmt::Debug + PartialEq,\n+    {\n+        assert_eq!(\n+            expected,\n+            inherent(&value)\n+                .map(|(n, f)| (n, f.bits()))\n+                .collect::<Vec<_>>(),\n+            \"{:?}.iter_names()\",\n+            value\n+        );\n+        assert_eq!(\n+            expected,\n+            Flags::iter_names(&value)\n+                .map(|(n, f)| (n, f.bits()))\n+                .collect::<Vec<_>>(),\n+            \"Flags::iter_names({:?})\",\n+            value\n+        );\n+    }\n+}\ndiff --git \/dev\/null b\/src\/tests\/parser.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/src\/tests\/parser.rs\n@@ -0,0 +1,115 @@\n+use super::*;\n+\n+use crate::{\n+    parser::{from_str, to_writer},\n+    Flags,\n+};\n+\n+#[test]\n+fn roundtrip() {\n+    let mut s = String::new();\n+\n+    for a in 0u8..=255 {\n+        for b in 0u8..=255 {\n+            let f = TestFlags::from_bits_retain(a | b);\n+\n+            s.clear();\n+            to_writer(&f, &mut s).unwrap();\n+\n+            assert_eq!(f, from_str::<TestFlags>(&s).unwrap());\n+        }\n+    }\n+}\n+\n+mod from_str {\n+    use super::*;\n+\n+    #[test]\n+    fn valid() {\n+        assert_eq!(0, from_str::<TestFlags>(\"\").unwrap().bits());\n+\n+        assert_eq!(1, from_str::<TestFlags>(\"A\").unwrap().bits());\n+        assert_eq!(1, from_str::<TestFlags>(\" A \").unwrap().bits());\n+        assert_eq!(\n+            1 | 1 << 1 | 1 << 2,\n+            from_str::<TestFlags>(\"A | B | C\").unwrap().bits()\n+        );\n+        assert_eq!(\n+            1 | 1 << 1 | 1 << 2,\n+            from_str::<TestFlags>(\"A\\n|\\tB\\r\\n|   C \").unwrap().bits()\n+        );\n+        assert_eq!(\n+            1 | 1 << 1 | 1 << 2,\n+            from_str::<TestFlags>(\"A|B|C\").unwrap().bits()\n+        );\n+\n+        assert_eq!(1 << 3, from_str::<TestFlags>(\"0x8\").unwrap().bits());\n+        assert_eq!(1 | 1 << 3, from_str::<TestFlags>(\"A | 0x8\").unwrap().bits());\n+        assert_eq!(\n+            1 | 1 << 1 | 1 << 3,\n+            from_str::<TestFlags>(\"0x1 | 0x8 | B\").unwrap().bits()\n+        );\n+\n+        assert_eq!(\n+            1 | 1 << 1,\n+            from_str::<TestUnicode>(\"\u4e00 | \u4e8c\").unwrap().bits()\n+        );\n+    }\n+\n+    #[test]\n+    fn invalid() {\n+        assert!(from_str::<TestFlags>(\"a\")\n+            .unwrap_err()\n+            .to_string()\n+            .starts_with(\"unrecognized named flag\"));\n+        assert!(from_str::<TestFlags>(\"A & B\")\n+            .unwrap_err()\n+            .to_string()\n+            .starts_with(\"unrecognized named flag\"));\n+\n+        assert!(from_str::<TestFlags>(\"0xg\")\n+            .unwrap_err()\n+            .to_string()\n+            .starts_with(\"invalid hex flag\"));\n+        assert!(from_str::<TestFlags>(\"0xffffffffffff\")\n+            .unwrap_err()\n+            .to_string()\n+            .starts_with(\"invalid hex flag\"));\n+    }\n+}\n+\n+mod to_writer {\n+    use super::*;\n+\n+    #[test]\n+    fn cases() {\n+        assert_eq!(\"\", write(TestFlags::empty()));\n+        assert_eq!(\"A\", write(TestFlags::A));\n+        assert_eq!(\"A | B | C\", write(TestFlags::all()));\n+        assert_eq!(\"0x8\", write(TestFlags::from_bits_retain(1 << 3)));\n+        assert_eq!(\n+            \"A | 0x8\",\n+            write(TestFlags::A | TestFlags::from_bits_retain(1 << 3))\n+        );\n+\n+        assert_eq!(\"\", write(TestZero::ZERO));\n+\n+        assert_eq!(\"ABC\", write(TestFlagsInvert::all()));\n+\n+        assert_eq!(\"A\", write(TestOverlappingFull::C));\n+        assert_eq!(\n+            \"A | D\",\n+            write(TestOverlappingFull::C | TestOverlappingFull::D)\n+        );\n+    }\n+\n+    fn write<F: Flags>(value: F) -> String\n+    where\n+        F::Bits: crate::parser::WriteHex,\n+    {\n+        let mut s = String::new();\n+\n+        to_writer(&value, &mut s).unwrap();\n+        s\n+    }\n+}\ndiff --git \/dev\/null b\/src\/tests\/remove.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/src\/tests\/remove.rs\n@@ -0,0 +1,100 @@\n+use super::*;\n+\n+use crate::Flags;\n+\n+#[test]\n+fn cases() {\n+    case(\n+        TestFlags::empty(),\n+        &[\n+            (TestFlags::A, 0),\n+            (TestFlags::empty(), 0),\n+            (TestFlags::from_bits_retain(1 << 3), 0),\n+        ],\n+        TestFlags::remove,\n+        TestFlags::set,\n+    );\n+\n+    case(\n+        TestFlags::A,\n+        &[\n+            (TestFlags::A, 0),\n+            (TestFlags::empty(), 1),\n+            (TestFlags::B, 1),\n+        ],\n+        TestFlags::remove,\n+        TestFlags::set,\n+    );\n+\n+    case(\n+        TestFlags::ABC,\n+        &[\n+            (TestFlags::A, 1 << 1 | 1 << 2),\n+            (TestFlags::A | TestFlags::C, 1 << 1),\n+        ],\n+        TestFlags::remove,\n+        TestFlags::set,\n+    );\n+}\n+\n+#[track_caller]\n+fn case<T: Flags + std::fmt::Debug + Copy>(\n+    value: T,\n+    inputs: &[(T, T::Bits)],\n+    mut inherent_remove: impl FnMut(&mut T, T),\n+    mut inherent_set: impl FnMut(&mut T, T, bool),\n+) where\n+    T::Bits: std::fmt::Debug + PartialEq + Copy,\n+{\n+    for (input, expected) in inputs {\n+        assert_eq!(\n+            *expected,\n+            {\n+                let mut value = value;\n+                inherent_remove(&mut value, *input);\n+                value\n+            }\n+            .bits(),\n+            \"{:?}.remove({:?})\",\n+            value,\n+            input\n+        );\n+        assert_eq!(\n+            *expected,\n+            {\n+                let mut value = value;\n+                Flags::remove(&mut value, *input);\n+                value\n+            }\n+            .bits(),\n+            \"Flags::remove({:?}, {:?})\",\n+            value,\n+            input\n+        );\n+\n+        assert_eq!(\n+            *expected,\n+            {\n+                let mut value = value;\n+                inherent_set(&mut value, *input, false);\n+                value\n+            }\n+            .bits(),\n+            \"{:?}.set({:?}, false)\",\n+            value,\n+            input\n+        );\n+        assert_eq!(\n+            *expected,\n+            {\n+                let mut value = value;\n+                Flags::set(&mut value, *input, false);\n+                value\n+            }\n+            .bits(),\n+            \"Flags::set({:?}, {:?}, false)\",\n+            value,\n+            input\n+        );\n+    }\n+}\ndiff --git \/dev\/null b\/src\/tests\/symmetric_difference.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/src\/tests\/symmetric_difference.rs\n@@ -0,0 +1,110 @@\n+use super::*;\n+\n+use crate::Flags;\n+\n+#[test]\n+fn cases() {\n+    case(\n+        TestFlags::empty(),\n+        &[\n+            (TestFlags::empty(), 0),\n+            (TestFlags::all(), 1 | 1 << 1 | 1 << 2),\n+            (TestFlags::from_bits_retain(1 << 3), 1 << 3),\n+        ],\n+        TestFlags::symmetric_difference,\n+        TestFlags::toggle,\n+    );\n+\n+    case(\n+        TestFlags::A,\n+        &[\n+            (TestFlags::empty(), 1),\n+            (TestFlags::A, 0),\n+            (TestFlags::all(), 1 << 1 | 1 << 2),\n+        ],\n+        TestFlags::symmetric_difference,\n+        TestFlags::toggle,\n+    );\n+\n+    case(\n+        TestFlags::A | TestFlags::B | TestFlags::from_bits_retain(1 << 3),\n+        &[\n+            (TestFlags::ABC, 1 << 2 | 1 << 3),\n+            (TestFlags::from_bits_retain(1 << 3), 1 | 1 << 1),\n+        ],\n+        TestFlags::symmetric_difference,\n+        TestFlags::toggle,\n+    );\n+}\n+\n+#[track_caller]\n+fn case<T: Flags + std::fmt::Debug + std::ops::BitXor<Output = T> + std::ops::BitXorAssign + Copy>(\n+    value: T,\n+    inputs: &[(T, T::Bits)],\n+    mut inherent_sym_diff: impl FnMut(T, T) -> T,\n+    mut inherent_toggle: impl FnMut(&mut T, T),\n+) where\n+    T::Bits: std::fmt::Debug + PartialEq + Copy,\n+{\n+    for (input, expected) in inputs {\n+        assert_eq!(\n+            *expected,\n+            inherent_sym_diff(value, *input).bits(),\n+            \"{:?}.symmetric_difference({:?})\",\n+            value,\n+            input\n+        );\n+        assert_eq!(\n+            *expected,\n+            Flags::symmetric_difference(value, *input).bits(),\n+            \"Flags::symmetric_difference({:?}, {:?})\",\n+            value,\n+            input\n+        );\n+        assert_eq!(\n+            *expected,\n+            (value ^ *input).bits(),\n+            \"{:?} ^ {:?}\",\n+            value,\n+            input\n+        );\n+        assert_eq!(\n+            *expected,\n+            {\n+                let mut value = value;\n+                value ^= *input;\n+                value\n+            }\n+            .bits(),\n+            \"{:?} ^= {:?}\",\n+            value,\n+            input,\n+        );\n+\n+        assert_eq!(\n+            *expected,\n+            {\n+                let mut value = value;\n+                inherent_toggle(&mut value, *input);\n+                value\n+            }\n+            .bits(),\n+            \"{:?}.toggle({:?})\",\n+            value,\n+            input,\n+        );\n+\n+        assert_eq!(\n+            *expected,\n+            {\n+                let mut value = value;\n+                Flags::toggle(&mut value, *input);\n+                value\n+            }\n+            .bits(),\n+            \"{:?}.toggle({:?})\",\n+            value,\n+            input,\n+        );\n+    }\n+}\ndiff --git \/dev\/null b\/src\/tests\/union.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/src\/tests\/union.rs\n@@ -0,0 +1,71 @@\n+use super::*;\n+\n+use crate::Flags;\n+\n+#[test]\n+fn cases() {\n+    case(\n+        TestFlags::empty(),\n+        &[\n+            (TestFlags::A, 1),\n+            (TestFlags::all(), 1 | 1 << 1 | 1 << 2),\n+            (TestFlags::empty(), 0),\n+            (TestFlags::from_bits_retain(1 << 3), 1 << 3),\n+        ],\n+        TestFlags::union,\n+    );\n+\n+    case(\n+        TestFlags::A | TestFlags::C,\n+        &[\n+            (TestFlags::A | TestFlags::B, 1 | 1 << 1 | 1 << 2),\n+            (TestFlags::A, 1 | 1 << 2),\n+        ],\n+        TestFlags::union,\n+    );\n+}\n+\n+#[track_caller]\n+fn case<T: Flags + std::fmt::Debug + std::ops::BitOr<Output = T> + std::ops::BitOrAssign + Copy>(\n+    value: T,\n+    inputs: &[(T, T::Bits)],\n+    mut inherent: impl FnMut(T, T) -> T,\n+) where\n+    T::Bits: std::fmt::Debug + PartialEq + Copy,\n+{\n+    for (input, expected) in inputs {\n+        assert_eq!(\n+            *expected,\n+            inherent(value, *input).bits(),\n+            \"{:?}.union({:?})\",\n+            value,\n+            input\n+        );\n+        assert_eq!(\n+            *expected,\n+            Flags::union(value, *input).bits(),\n+            \"Flags::union({:?}, {:?})\",\n+            value,\n+            input\n+        );\n+        assert_eq!(\n+            *expected,\n+            (value | *input).bits(),\n+            \"{:?} | {:?}\",\n+            value,\n+            input\n+        );\n+        assert_eq!(\n+            *expected,\n+            {\n+                let mut value = value;\n+                value |= *input;\n+                value\n+            }\n+            .bits(),\n+            \"{:?} |= {:?}\",\n+            value,\n+            input,\n+        );\n+    }\n+}\ndiff --git a\/tests\/basic.rs b\/tests\/basic.rs\n--- a\/tests\/basic.rs\n+++ b\/tests\/basic.rs\n@@ -3,19 +3,77 @@\n use bitflags::bitflags;\n \n bitflags! {\n-    \/\/\/ baz\n-    #[derive(Debug, PartialEq, Eq)]\n-    struct Flags: u32 {\n+    pub struct I8: i8 {\n+        const A = 0b00000001;\n+        const B = 0b00000010;\n+        const C = 0b00000100;\n+    }\n+\n+    pub struct I16: i16 {\n+        const A = 0b00000001;\n+        const B = 0b00000010;\n+        const C = 0b00000100;\n+    }\n+\n+    pub struct I32: i32 {\n+        const A = 0b00000001;\n+        const B = 0b00000010;\n+        const C = 0b00000100;\n+    }\n+\n+    pub struct I64: i64 {\n+        const A = 0b00000001;\n+        const B = 0b00000010;\n+        const C = 0b00000100;\n+    }\n+\n+    pub struct I128: i128 {\n+        const A = 0b00000001;\n+        const B = 0b00000010;\n+        const C = 0b00000100;\n+    }\n+\n+    pub struct Isize: isize {\n         const A = 0b00000001;\n-        #[doc = \"bar\"]\n         const B = 0b00000010;\n         const C = 0b00000100;\n-        #[doc = \"foo\"]\n-        const ABC = Flags::A.bits() | Flags::B.bits() | Flags::C.bits();\n     }\n }\n \n-#[test]\n-fn basic() {\n-    assert_eq!(Flags::ABC, Flags::A | Flags::B | Flags::C);\n+bitflags! {\n+    pub struct U8: u8 {\n+        const A = 0b00000001;\n+        const B = 0b00000010;\n+        const C = 0b00000100;\n+    }\n+\n+    pub struct U16: u16 {\n+        const A = 0b00000001;\n+        const B = 0b00000010;\n+        const C = 0b00000100;\n+    }\n+\n+    pub struct U32: u32 {\n+        const A = 0b00000001;\n+        const B = 0b00000010;\n+        const C = 0b00000100;\n+    }\n+\n+    pub struct U64: u64 {\n+        const A = 0b00000001;\n+        const B = 0b00000010;\n+        const C = 0b00000100;\n+    }\n+\n+    pub struct U128: u128 {\n+        const A = 0b00000001;\n+        const B = 0b00000010;\n+        const C = 0b00000100;\n+    }\n+\n+    pub struct Usize: usize {\n+        const A = 0b00000001;\n+        const B = 0b00000010;\n+        const C = 0b00000100;\n+    }\n }\ndiff --git a\/tests\/compile-fail\/bitflags_custom_bits.stderr b\/tests\/compile-fail\/bitflags_custom_bits.stderr\n--- a\/tests\/compile-fail\/bitflags_custom_bits.stderr\n+++ b\/tests\/compile-fail\/bitflags_custom_bits.stderr\n@@ -34,443 +34,3 @@ error[E0308]: mismatched types\n                   found type parameter `W`\n note: method defined here\n    --> $RUST\/core\/src\/fmt\/mod.rs\n-\n-error[E0277]: can't compare `MyInt` with `_` in const contexts\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n-    |\n-132 | \/ bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^ no implementation for `MyInt == _`\n-    |\n-    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n-note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n-    |\n-132 | \/ bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: can't compare `MyInt` with `_` in const contexts\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n-    |\n-132 | \/ bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^ no implementation for `MyInt == _`\n-    |\n-    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n-note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n-    |\n-132 | \/ bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: the trait bound `MyInt: BitAnd` is not satisfied\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n-    |\n-132 | \/ bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^ no implementation for `MyInt & MyInt`\n-    |\n-    = help: the trait `~const BitAnd` is not implemented for `MyInt`\n-note: the trait `BitAnd` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n-    |\n-132 | \/ bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: can't compare `MyInt` with `_` in const contexts\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n-    |\n-132 | \/ bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^ no implementation for `MyInt == _`\n-    |\n-    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n-note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n-    |\n-132 | \/ bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: the trait bound `MyInt: BitOr` is not satisfied\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n-    |\n-132 | \/ bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^ no implementation for `MyInt | MyInt`\n-    |\n-    = help: the trait `~const BitOr` is not implemented for `MyInt`\n-note: the trait `BitOr` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n-    |\n-132 | \/ bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: can't compare `MyInt` with `_` in const contexts\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n-    |\n-132 | \/ bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^ no implementation for `MyInt == _`\n-    |\n-    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n-note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n-    |\n-132 | \/ bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: the trait bound `MyInt: BitOr` is not satisfied\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n-    |\n-132 | \/ bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^ no implementation for `MyInt | MyInt`\n-    |\n-    = help: the trait `~const BitOr` is not implemented for `MyInt`\n-note: the trait `BitOr` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n-    |\n-132 | \/ bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: can't compare `MyInt` with `_` in const contexts\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n-    |\n-132 | \/ bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^ no implementation for `MyInt == _`\n-    |\n-    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n-note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n-    |\n-132 | \/ bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: the trait bound `MyInt: BitAnd` is not satisfied\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n-    |\n-132 | \/ bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^ no implementation for `MyInt & MyInt`\n-    |\n-    = help: the trait `~const BitAnd` is not implemented for `MyInt`\n-note: the trait `BitAnd` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n-    |\n-132 | \/ bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: the trait bound `MyInt: BitAnd` is not satisfied\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n-    |\n-132 | \/ bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^ no implementation for `MyInt & MyInt`\n-    |\n-    = help: the trait `~const BitAnd` is not implemented for `MyInt`\n-note: the trait `BitAnd` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n-    |\n-132 | \/ bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: can't compare `MyInt` with `_` in const contexts\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n-    |\n-132 | \/ bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^ no implementation for `MyInt == _`\n-    |\n-    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n-note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n-    |\n-132 | \/ bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: the trait bound `MyInt: BitAnd` is not satisfied\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n-    |\n-132 | \/ bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^ no implementation for `MyInt & MyInt`\n-    |\n-    = help: the trait `~const BitAnd` is not implemented for `MyInt`\n-note: the trait `BitAnd` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n-    |\n-132 | \/ bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: the trait bound `MyInt: BitOr` is not satisfied\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n-    |\n-132 | \/ bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^ no implementation for `MyInt | MyInt`\n-    |\n-    = help: the trait `~const BitOr` is not implemented for `MyInt`\n-note: the trait `BitOr` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n-    |\n-132 | \/ bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: the trait bound `MyInt: BitAnd` is not satisfied\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n-    |\n-132 | \/ bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^ no implementation for `MyInt & MyInt`\n-    |\n-    = help: the trait `~const BitAnd` is not implemented for `MyInt`\n-note: the trait `BitAnd` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n-    |\n-132 | \/ bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: the trait bound `MyInt: Not` is not satisfied\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n-    |\n-132 | \/ bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^ the trait `~const Not` is not implemented for `MyInt`\n-    |\n-note: the trait `Not` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n-    |\n-132 | \/ bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: the trait bound `MyInt: BitXor` is not satisfied\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n-    |\n-132 | \/ bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^ no implementation for `MyInt ^ MyInt`\n-    |\n-    = help: the trait `~const BitXor` is not implemented for `MyInt`\n-note: the trait `BitXor` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n-    |\n-132 | \/ bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: the trait bound `MyInt: Not` is not satisfied\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n-    |\n-132 | \/ bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^ the trait `~const Not` is not implemented for `MyInt`\n-    |\n-note: the trait `Not` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n-    |\n-132 | \/ bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n","hints_text":"The value `0` isn\u2019t recommended as a flag value because it behaves surprisingly with formatting, and with `is_any`.\nIf you do want to define a zero-valued flag I\u2019d suggest defining the constant outside of the `bitflags!` macro.","base_commit":"09f71f492d0f76d63cd286c3869c70676297e204","issue_numbers":["364"],"created_at":"2023-06-26T07:21:41Z","pull_number":366,"instance_id":"bitflags__bitflags-366","patch":"diff --git a\/examples\/custom_bits_type.rs b\/examples\/custom_bits_type.rs\n--- a\/examples\/custom_bits_type.rs\n+++ b\/examples\/custom_bits_type.rs\n@@ -1,6 +1,6 @@\n use std::ops::{BitAnd, BitOr, BitXor, Not};\n \n-use bitflags::{Flags, Flag, Bits};\n+use bitflags::{Bits, Flag, Flags};\n \n \/\/ Define a custom container that can be used in flags types\n \/\/ Note custom bits types can't be used in `bitflags!`\ndiff --git a\/examples\/custom_bits_type.rs b\/examples\/custom_bits_type.rs\n--- a\/examples\/custom_bits_type.rs\n+++ b\/examples\/custom_bits_type.rs\n@@ -25,7 +25,11 @@ impl BitAnd for CustomBits {\n     type Output = Self;\n \n     fn bitand(self, other: Self) -> Self {\n-        CustomBits([self.0[0] & other.0[0], self.0[1] & other.0[1], self.0[2] & other.0[2]])\n+        CustomBits([\n+            self.0[0] & other.0[0],\n+            self.0[1] & other.0[1],\n+            self.0[2] & other.0[2],\n+        ])\n     }\n }\n \ndiff --git a\/examples\/custom_bits_type.rs b\/examples\/custom_bits_type.rs\n--- a\/examples\/custom_bits_type.rs\n+++ b\/examples\/custom_bits_type.rs\n@@ -33,7 +37,11 @@ impl BitOr for CustomBits {\n     type Output = Self;\n \n     fn bitor(self, other: Self) -> Self {\n-        CustomBits([self.0[0] | other.0[0], self.0[1] | other.0[1], self.0[2] | other.0[2]])\n+        CustomBits([\n+            self.0[0] | other.0[0],\n+            self.0[1] | other.0[1],\n+            self.0[2] | other.0[2],\n+        ])\n     }\n }\n \ndiff --git a\/examples\/custom_bits_type.rs b\/examples\/custom_bits_type.rs\n--- a\/examples\/custom_bits_type.rs\n+++ b\/examples\/custom_bits_type.rs\n@@ -41,7 +49,11 @@ impl BitXor for CustomBits {\n     type Output = Self;\n \n     fn bitxor(self, other: Self) -> Self {\n-        CustomBits([self.0[0] & other.0[0], self.0[1] & other.0[1], self.0[2] & other.0[2]])\n+        CustomBits([\n+            self.0[0] & other.0[0],\n+            self.0[1] & other.0[1],\n+            self.0[2] & other.0[2],\n+        ])\n     }\n }\n \ndiff --git a\/examples\/macro_free.rs b\/examples\/macro_free.rs\n--- a\/examples\/macro_free.rs\n+++ b\/examples\/macro_free.rs\n@@ -4,7 +4,7 @@\n \n use std::{fmt, str};\n \n-use bitflags::{Flags, Flag};\n+use bitflags::{Flag, Flags};\n \n \/\/ First: Define your flags type. It just needs to be `Sized + 'static`.\n pub struct ManualFlags(u32);\ndiff --git a\/examples\/macro_free.rs b\/examples\/macro_free.rs\n--- a\/examples\/macro_free.rs\n+++ b\/examples\/macro_free.rs\n@@ -54,5 +54,8 @@ impl fmt::Display for ManualFlags {\n }\n \n fn main() {\n-    println!(\"{}\", ManualFlags::A.union(ManualFlags::B).union(ManualFlags::C));\n+    println!(\n+        \"{}\",\n+        ManualFlags::A.union(ManualFlags::B).union(ManualFlags::C)\n+    );\n }\ndiff --git a\/src\/example_generated.rs b\/src\/example_generated.rs\n--- a\/src\/example_generated.rs\n+++ b\/src\/example_generated.rs\n@@ -38,6 +38,10 @@ __impl_public_bitflags_forward! {\n     Flags: u32, Field0\n }\n \n+__impl_public_bitflags_ops! {\n+    Flags\n+}\n+\n __impl_public_bitflags_iter! {\n     Flags: u32, Flags\n }\ndiff --git a\/src\/external.rs b\/src\/external.rs\n--- a\/src\/external.rs\n+++ b\/src\/external.rs\n@@ -153,9 +153,7 @@ macro_rules! __impl_external_bitflags_serde {\n             fn deserialize<D: $crate::__private::serde::Deserializer<'de>>(\n                 deserializer: D,\n             ) -> $crate::__private::core::result::Result<Self, D::Error> {\n-                let flags: $PublicBitFlags = $crate::serde::deserialize(\n-                    deserializer,\n-                )?;\n+                let flags: $PublicBitFlags = $crate::serde::deserialize(deserializer)?;\n \n                 Ok(flags.0)\n             }\ndiff --git a\/src\/external.rs b\/src\/external.rs\n--- a\/src\/external.rs\n+++ b\/src\/external.rs\n@@ -235,20 +233,16 @@ macro_rules! __impl_external_bitflags_bytemuck {\n     ) => {\n         \/\/ SAFETY: $InternalBitFlags is guaranteed to have the same ABI as $T,\n         \/\/ and $T implements Pod\n-        unsafe impl $crate::__private::bytemuck::Pod for $InternalBitFlags\n-        where\n-            $T: $crate::__private::bytemuck::Pod,\n+        unsafe impl $crate::__private::bytemuck::Pod for $InternalBitFlags where\n+            $T: $crate::__private::bytemuck::Pod\n         {\n-\n         }\n \n         \/\/ SAFETY: $InternalBitFlags is guaranteed to have the same ABI as $T,\n         \/\/ and $T implements Zeroable\n-        unsafe impl $crate::__private::bytemuck::Zeroable for $InternalBitFlags\n-        where\n-            $T: $crate::__private::bytemuck::Zeroable,\n+        unsafe impl $crate::__private::bytemuck::Zeroable for $InternalBitFlags where\n+            $T: $crate::__private::bytemuck::Zeroable\n         {\n-\n         }\n     };\n }\ndiff --git a\/src\/external\/arbitrary.rs b\/src\/external\/arbitrary.rs\n--- a\/src\/external\/arbitrary.rs\n+++ b\/src\/external\/arbitrary.rs\n@@ -3,11 +3,9 @@\n use crate::Flags;\n \n \/\/\/ Get a random known flags value.\n-pub fn arbitrary<'a, B: Flags>(\n-    u: &mut arbitrary::Unstructured<'a>,\n-) -> arbitrary::Result<B>\n+pub fn arbitrary<'a, B: Flags>(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<B>\n where\n-    B::Bits: arbitrary::Arbitrary<'a>\n+    B::Bits: arbitrary::Arbitrary<'a>,\n {\n     B::from_bits(u.arbitrary()?).ok_or_else(|| arbitrary::Error::IncorrectFormat)\n }\ndiff --git a\/src\/external\/serde.rs b\/src\/external\/serde.rs\n--- a\/src\/external\/serde.rs\n+++ b\/src\/external\/serde.rs\n@@ -1,17 +1,17 @@\n \/\/! Specialized serialization for flags types using `serde`.\n \n+use crate::{\n+    parser::{self, ParseHex, WriteHex},\n+    Flags,\n+};\n use core::{fmt, str};\n-use crate::{Flags, parser::{self, ParseHex, WriteHex}};\n use serde::{\n     de::{Error, Visitor},\n     Deserialize, Deserializer, Serialize, Serializer,\n };\n \n \/\/\/ Serialize a set of flags as a human-readable string or their underlying bits.\n-pub fn serialize<B: Flags, S: Serializer>(\n-    flags: &B,\n-    serializer: S,\n-) -> Result<S::Ok, S::Error>\n+pub fn serialize<B: Flags, S: Serializer>(flags: &B, serializer: S) -> Result<S::Ok, S::Error>\n where\n     B::Bits: WriteHex + Serialize,\n {\ndiff --git a\/src\/external\/serde.rs b\/src\/external\/serde.rs\n--- a\/src\/external\/serde.rs\n+++ b\/src\/external\/serde.rs\n@@ -26,13 +26,7 @@ where\n }\n \n \/\/\/ Deserialize a set of flags from a human-readable string or their underlying bits.\n-pub fn deserialize<\n-    'de,\n-    B: Flags,\n-    D: Deserializer<'de>,\n->(\n-    deserializer: D,\n-) -> Result<B, D::Error>\n+pub fn deserialize<'de, B: Flags, D: Deserializer<'de>>(deserializer: D) -> Result<B, D::Error>\n where\n     B::Bits: ParseHex + Deserialize<'de>,\n {\ndiff --git a\/src\/internal.rs b\/src\/internal.rs\n--- a\/src\/internal.rs\n+++ b\/src\/internal.rs\n@@ -56,7 +56,7 @@ macro_rules! __impl_internal_bitflags {\n                 if self.is_empty() {\n                     \/\/ If no flags are set then write an empty hex flag to avoid\n                     \/\/ writing an empty string. In some contexts, like serialization,\n-                    \/\/ an empty string is preferrable, but it may be unexpected in\n+                    \/\/ an empty string is preferable, but it may be unexpected in\n                     \/\/ others for a format not to produce any output.\n                     \/\/\n                     \/\/ We can remove this `0x0` and remain compatible with `FromStr`,\ndiff --git a\/src\/internal.rs b\/src\/internal.rs\n--- a\/src\/internal.rs\n+++ b\/src\/internal.rs\n@@ -106,6 +106,10 @@ macro_rules! __impl_internal_bitflags {\n             }\n         }\n \n+        __impl_public_bitflags_ops! {\n+            $InternalBitFlags\n+        }\n+\n         __impl_public_bitflags_iter! {\n             $InternalBitFlags: $T, $PublicBitFlags\n         }\ndiff --git a\/src\/iter.rs b\/src\/iter.rs\n--- a\/src\/iter.rs\n+++ b\/src\/iter.rs\n@@ -1,6 +1,6 @@\n \/\/! Iterating over set flag values.\n \n-use crate::{Flags, Flag};\n+use crate::{Flag, Flags};\n \n \/\/\/ An iterator over a set of flags.\n \/\/\/\ndiff --git a\/src\/iter.rs b\/src\/iter.rs\n--- a\/src\/iter.rs\n+++ b\/src\/iter.rs\n@@ -23,9 +23,9 @@ impl<B: Flags> Iter<B> {\n \n impl<B: 'static> Iter<B> {\n     #[doc(hidden)]\n-    pub const fn __private_const_new(flags: &'static [Flag<B>], source: B, state: B) -> Self {\n+    pub const fn __private_const_new(flags: &'static [Flag<B>], source: B, remaining: B) -> Self {\n         Iter {\n-            inner: IterNames::__private_const_new(flags, source, state),\n+            inner: IterNames::__private_const_new(flags, source, remaining),\n             done: false,\n         }\n     }\ndiff --git a\/src\/iter.rs b\/src\/iter.rs\n--- a\/src\/iter.rs\n+++ b\/src\/iter.rs\n@@ -33,18 +33,18 @@ impl<B: 'static> Iter<B> {\n \n impl<B: Flags> Iterator for Iter<B> {\n     type Item = B;\n-    \n+\n     fn next(&mut self) -> Option<Self::Item> {\n         match self.inner.next() {\n             Some((_, flag)) => Some(flag),\n             None if !self.done => {\n                 self.done = true;\n-                \n+\n                 \/\/ After iterating through valid names, if there are any bits left over\n                 \/\/ then return one final value that includes them. This makes `into_iter`\n                 \/\/ and `from_iter` roundtrip\n                 if !self.inner.remaining().is_empty() {\n-                    Some(B::from_bits_retain(self.inner.state.bits()))\n+                    Some(B::from_bits_retain(self.inner.remaining.bits()))\n                 } else {\n                     None\n                 }\ndiff --git a\/src\/iter.rs b\/src\/iter.rs\n--- a\/src\/iter.rs\n+++ b\/src\/iter.rs\n@@ -61,7 +61,7 @@ pub struct IterNames<B: 'static> {\n     flags: &'static [Flag<B>],\n     idx: usize,\n     source: B,\n-    state: B,\n+    remaining: B,\n }\n \n impl<B: Flags> IterNames<B> {\ndiff --git a\/src\/iter.rs b\/src\/iter.rs\n--- a\/src\/iter.rs\n+++ b\/src\/iter.rs\n@@ -70,7 +70,7 @@ impl<B: Flags> IterNames<B> {\n         IterNames {\n             flags: B::FLAGS,\n             idx: 0,\n-            state: B::from_bits_retain(flags.bits()),\n+            remaining: B::from_bits_retain(flags.bits()),\n             source: B::from_bits_retain(flags.bits()),\n         }\n     }\ndiff --git a\/src\/iter.rs b\/src\/iter.rs\n--- a\/src\/iter.rs\n+++ b\/src\/iter.rs\n@@ -78,11 +78,11 @@ impl<B: Flags> IterNames<B> {\n \n impl<B: 'static> IterNames<B> {\n     #[doc(hidden)]\n-    pub const fn __private_const_new(flags: &'static [Flag<B>], source: B, state: B) -> Self {\n+    pub const fn __private_const_new(flags: &'static [Flag<B>], source: B, remaining: B) -> Self {\n         IterNames {\n             flags,\n             idx: 0,\n-            state,\n+            remaining,\n             source,\n         }\n     }\ndiff --git a\/src\/iter.rs b\/src\/iter.rs\n--- a\/src\/iter.rs\n+++ b\/src\/iter.rs\n@@ -93,17 +93,17 @@ impl<B: 'static> IterNames<B> {\n     \/\/\/ check whether or not there are any bits that didn't correspond\n     \/\/\/ to a valid flag remaining.\n     pub fn remaining(&self) -> &B {\n-        &self.state\n+        &self.remaining\n     }\n }\n \n impl<B: Flags> Iterator for IterNames<B> {\n     type Item = (&'static str, B);\n-    \n+\n     fn next(&mut self) -> Option<Self::Item> {\n         while let Some(flag) = self.flags.get(self.idx) {\n             \/\/ Short-circuit if our state is empty\n-            if self.state.is_empty() {\n+            if self.remaining.is_empty() {\n                 return None;\n             }\n \ndiff --git a\/src\/iter.rs b\/src\/iter.rs\n--- a\/src\/iter.rs\n+++ b\/src\/iter.rs\n@@ -111,23 +111,23 @@ impl<B: Flags> Iterator for IterNames<B> {\n \n             let bits = flag.value().bits();\n \n-            \/\/ NOTE: We check whether the flag exists in self, but remove it from\n-            \/\/ a different value. This ensure that overlapping flags are handled\n-            \/\/ properly. Take the following example:\n+            \/\/ If the flag is set in the original source _and_ it has bits that haven't\n+            \/\/ been covered by a previous flag yet then yield it. These conditions cover\n+            \/\/ two cases for multi-bit flags:\n             \/\/\n-            \/\/ const A: 0b00000001;\n-            \/\/ const B: 0b00000101;\n-            \/\/\n-            \/\/ Given the bits 0b00000101, both A and B are set. But if we removed A\n-            \/\/ as we encountered it we'd be left with 0b00000100, which doesn't\n-            \/\/ correspond to a valid flag on its own.\n-            if self.source.contains(B::from_bits_retain(bits)) {\n-                self.state.remove(B::from_bits_retain(bits));\n+            \/\/ 1. When flags partially overlap, such as `0b00000001` and `0b00000101`, we'll\n+            \/\/ yield both flags.\n+            \/\/ 2. When flags fully overlap, such as in convenience flags that are a shorthand for others,\n+            \/\/ we won't yield both flags.\n+            if self.source.contains(B::from_bits_retain(bits))\n+                && self.remaining.intersects(B::from_bits_retain(bits))\n+            {\n+                self.remaining.remove(B::from_bits_retain(bits));\n \n                 return Some((flag.name(), B::from_bits_retain(bits)));\n             }\n         }\n-        \n+\n         None\n     }\n }\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -623,6 +624,10 @@ macro_rules! bitflags {\n                 $BitFlags: $T, InternalBitFlags\n             }\n \n+            __impl_public_bitflags_ops! {\n+                $BitFlags\n+            }\n+\n             __impl_public_bitflags_iter! {\n                 $BitFlags: $T, $BitFlags\n             }\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -671,6 +676,10 @@ macro_rules! bitflags {\n                 }\n             }\n \n+            __impl_public_bitflags_ops! {\n+                $BitFlags\n+            }\n+\n             __impl_public_bitflags_iter! {\n                 $BitFlags: $T, $BitFlags\n             }\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -714,11 +723,7 @@ macro_rules! __impl_bitflags {\n             fn complement($complement0:ident) $complement:block\n         }\n     ) => {\n-        #[allow(\n-            dead_code,\n-            deprecated,\n-            unused_attributes\n-        )]\n+        #[allow(dead_code, deprecated, unused_attributes)]\n         impl $PublicBitFlags {\n             \/\/\/ Returns an empty set of flags.\n             #[inline]\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -804,6 +809,8 @@ macro_rules! __impl_bitflags {\n             }\n \n             \/\/\/ Inserts the specified flags in-place.\n+            \/\/\/\n+            \/\/\/ This method is equivalent to `union`.\n             #[inline]\n             pub fn insert(&mut self, other: Self) {\n                 let $insert0 = self;\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -812,6 +819,8 @@ macro_rules! __impl_bitflags {\n             }\n \n             \/\/\/ Removes the specified flags in-place.\n+            \/\/\/\n+            \/\/\/ This method is equivalent to `difference`.\n             #[inline]\n             pub fn remove(&mut self, other: Self) {\n                 let $remove0 = self;\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -820,6 +829,8 @@ macro_rules! __impl_bitflags {\n             }\n \n             \/\/\/ Toggles the specified flags in-place.\n+            \/\/\/\n+            \/\/\/ This method is equivalent to `symmetric_difference`.\n             #[inline]\n             pub fn toggle(&mut self, other: Self) {\n                 let $toggle0 = self;\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -839,13 +850,8 @@ macro_rules! __impl_bitflags {\n             \/\/\/ Returns the intersection between the flags in `self` and\n             \/\/\/ `other`.\n             \/\/\/\n-            \/\/\/ Specifically, the returned set contains only the flags which are\n-            \/\/\/ present in *both* `self` *and* `other`.\n-            \/\/\/\n-            \/\/\/ This is equivalent to using the `&` operator (e.g.\n-            \/\/\/ [`ops::BitAnd`]), as in `flags & other`.\n-            \/\/\/\n-            \/\/\/ [`ops::BitAnd`]: https:\/\/doc.rust-lang.org\/std\/ops\/trait.BitAnd.html\n+            \/\/\/ Calculating `self` bitwise and (`&`) other, including\n+            \/\/\/ any bits that don't correspond to a defined flag.\n             #[inline]\n             #[must_use]\n             pub const fn intersection(self, other: Self) -> Self {\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -856,15 +862,8 @@ macro_rules! __impl_bitflags {\n \n             \/\/\/ Returns the union of between the flags in `self` and `other`.\n             \/\/\/\n-            \/\/\/ Specifically, the returned set contains all flags which are\n-            \/\/\/ present in *either* `self` *or* `other`, including any which are\n-            \/\/\/ present in both (see [`Self::symmetric_difference`] if that\n-            \/\/\/ is undesirable).\n-            \/\/\/\n-            \/\/\/ This is equivalent to using the `|` operator (e.g.\n-            \/\/\/ [`ops::BitOr`]), as in `flags | other`.\n-            \/\/\/\n-            \/\/\/ [`ops::BitOr`]: https:\/\/doc.rust-lang.org\/std\/ops\/trait.BitOr.html\n+            \/\/\/ Calculates `self` bitwise or (`|`) `other`, including\n+            \/\/\/ any bits that don't correspond to a defined flag.\n             #[inline]\n             #[must_use]\n             pub const fn union(self, other: Self) -> Self {\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -875,16 +874,13 @@ macro_rules! __impl_bitflags {\n \n             \/\/\/ Returns the difference between the flags in `self` and `other`.\n             \/\/\/\n-            \/\/\/ Specifically, the returned set contains all flags present in\n-            \/\/\/ `self`, except for the ones present in `other`.\n-            \/\/\/\n-            \/\/\/ It is also conceptually equivalent to the \"bit-clear\" operation:\n-            \/\/\/ `flags & !other` (and this syntax is also supported).\n-            \/\/\/\n-            \/\/\/ This is equivalent to using the `-` operator (e.g.\n-            \/\/\/ [`ops::Sub`]), as in `flags - other`.\n+            \/\/\/ Calculates `self` bitwise and (`&!`) the bitwise negation of `other`,\n+            \/\/\/ including any bits that don't correspond to a defined flag.\n             \/\/\/\n-            \/\/\/ [`ops::Sub`]: https:\/\/doc.rust-lang.org\/std\/ops\/trait.Sub.html\n+            \/\/\/ This method is _not_ equivalent to `a & !b` when there are bits set that\n+            \/\/\/ don't correspond to a defined flag. The `!` operator will unset any\n+            \/\/\/ bits that don't correspond to a flag, so they'll always be unset by `a &! b`,\n+            \/\/\/ but respected by `a.difference(b)`.\n             #[inline]\n             #[must_use]\n             pub const fn difference(self, other: Self) -> Self {\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -893,19 +889,11 @@ macro_rules! __impl_bitflags {\n                 $difference\n             }\n \n-            \/\/\/ Returns the [symmetric difference][sym-diff] between the flags\n+            \/\/\/ Returns the symmetric difference between the flags\n             \/\/\/ in `self` and `other`.\n             \/\/\/\n-            \/\/\/ Specifically, the returned set contains the flags present which\n-            \/\/\/ are present in `self` or `other`, but that are not present in\n-            \/\/\/ both. Equivalently, it contains the flags present in *exactly\n-            \/\/\/ one* of the sets `self` and `other`.\n-            \/\/\/\n-            \/\/\/ This is equivalent to using the `^` operator (e.g.\n-            \/\/\/ [`ops::BitXor`]), as in `flags ^ other`.\n-            \/\/\/\n-            \/\/\/ [sym-diff]: https:\/\/en.wikipedia.org\/wiki\/Symmetric_difference\n-            \/\/\/ [`ops::BitXor`]: https:\/\/doc.rust-lang.org\/std\/ops\/trait.BitXor.html\n+            \/\/\/ Calculates `self` bitwise exclusive or (`^`) `other`,\n+            \/\/\/ including any bits that don't correspond to a defined flag.\n             #[inline]\n             #[must_use]\n             pub const fn symmetric_difference(self, other: Self) -> Self {\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -916,17 +904,8 @@ macro_rules! __impl_bitflags {\n \n             \/\/\/ Returns the complement of this set of flags.\n             \/\/\/\n-            \/\/\/ Specifically, the returned set contains all the flags which are\n-            \/\/\/ not set in `self`, but which are allowed for this type.\n-            \/\/\/\n-            \/\/\/ Alternatively, it can be thought of as the set difference\n-            \/\/\/ between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n-            \/\/\/\n-            \/\/\/ This is equivalent to using the `!` operator (e.g.\n-            \/\/\/ [`ops::Not`]), as in `!flags`.\n-            \/\/\/\n-            \/\/\/ [`Self::all()`]: Self::all\n-            \/\/\/ [`ops::Not`]: https:\/\/doc.rust-lang.org\/std\/ops\/trait.Not.html\n+            \/\/\/ Calculates the bitwise negation (`!`) of `self`,\n+            \/\/\/ **unsetting** any bits that don't correspond to a defined flag.\n             #[inline]\n             #[must_use]\n             pub const fn complement(self) -> Self {\ndiff --git a\/src\/parser.rs b\/src\/parser.rs\n--- a\/src\/parser.rs\n+++ b\/src\/parser.rs\n@@ -30,7 +30,7 @@\n \n use core::fmt::{self, Write};\n \n-use crate::{Flags, Bits};\n+use crate::{Bits, Flags};\n \n \/\/\/ Write a set of flags to a writer.\n \/\/\/\ndiff --git a\/src\/parser.rs b\/src\/parser.rs\n--- a\/src\/parser.rs\n+++ b\/src\/parser.rs\n@@ -48,7 +48,7 @@ where\n     \/\/ followed by a hex number of any remaining bits that are set\n     \/\/ but don't correspond to any flags.\n \n-    \/\/ Iterate over the valid flags\n+    \/\/ Iterate over known flag values\n     let mut first = true;\n     let mut iter = flags.iter_names();\n     for (name, _) in &mut iter {\ndiff --git a\/src\/parser.rs b\/src\/parser.rs\n--- a\/src\/parser.rs\n+++ b\/src\/parser.rs\n@@ -110,7 +110,8 @@ where\n         \/\/ If the flag starts with `0x` then it's a hex number\n         \/\/ Parse it directly to the underlying bits type\n         let parsed_flag = if let Some(flag) = flag.strip_prefix(\"0x\") {\n-            let bits = <B::Bits>::parse_hex(flag).map_err(|_| ParseError::invalid_hex_flag(flag))?;\n+            let bits =\n+                <B::Bits>::parse_hex(flag).map_err(|_| ParseError::invalid_hex_flag(flag))?;\n \n             B::from_bits_retain(bits)\n         }\ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -117,8 +117,6 @@ macro_rules! __impl_public_bitflags_forward {\n                 }\n             }\n         }\n-\n-        __impl_public_bitflags_ops!($PublicBitFlags);\n     };\n }\n \ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -203,31 +201,33 @@ macro_rules! __impl_public_bitflags {\n                 }\n \n                 fn is_empty(f) {\n-                    f.0 == Self::empty().0\n+                    f.bits() == <$T as $crate::Bits>::EMPTY\n                 }\n \n                 fn is_all(f) {\n-                    Self::all().0 | f.0 == f.0\n+                    \/\/ NOTE: We check against `Self::all` here, not `Self::Bits::ALL`\n+                    \/\/ because the set of all flags may not use all bits\n+                    Self::all().bits() | f.bits() == f.bits()\n                 }\n \n                 fn intersects(f, other) {\n-                    !(Self(f.0 & other.0)).is_empty()\n+                    f.bits() & other.bits() != <$T as $crate::Bits>::EMPTY\n                 }\n \n                 fn contains(f, other) {\n-                    (f.0 & other.0) == other.0\n+                    f.bits() & other.bits() == other.bits()\n                 }\n \n                 fn insert(f, other) {\n-                    f.0 = f.0 | other.0;\n+                    *f = Self::from_bits_retain(f.bits() | other.bits());\n                 }\n \n                 fn remove(f, other) {\n-                    f.0 = f.0 & !other.0;\n+                    *f = Self::from_bits_retain(f.bits() & !other.bits());\n                 }\n \n                 fn toggle(f, other) {\n-                    f.0 = f.0 ^ other.0;\n+                    *f = Self::from_bits_retain(f.bits() ^ other.bits());\n                 }\n \n                 fn set(f, other, value) {\ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -239,28 +239,26 @@ macro_rules! __impl_public_bitflags {\n                 }\n \n                 fn intersection(f, other) {\n-                    Self(f.0 & other.0)\n+                    Self::from_bits_retain(f.bits() & other.bits())\n                 }\n \n                 fn union(f, other) {\n-                    Self(f.0 | other.0)\n+                    Self::from_bits_retain(f.bits() | other.bits())\n                 }\n \n                 fn difference(f, other) {\n-                    Self(f.0 & !other.0)\n+                    Self::from_bits_retain(f.bits() & !other.bits())\n                 }\n \n                 fn symmetric_difference(f, other) {\n-                    Self(f.0 ^ other.0)\n+                    Self::from_bits_retain(f.bits() ^ other.bits())\n                 }\n \n                 fn complement(f) {\n-                    Self::from_bits_truncate(!f.0)\n+                    Self::from_bits_truncate(!f.bits())\n                 }\n             }\n         }\n-\n-        __impl_public_bitflags_ops!($BitFlags);\n     };\n }\n \ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -273,13 +271,21 @@ macro_rules! __impl_public_bitflags_iter {\n             \/\/\/ Iterate over enabled flag values.\n             #[inline]\n             pub const fn iter(&self) -> $crate::iter::Iter<$PublicBitFlags> {\n-                $crate::iter::Iter::__private_const_new(<$PublicBitFlags as $crate::Flags>::FLAGS, $PublicBitFlags::from_bits_retain(self.bits()), $PublicBitFlags::from_bits_retain(self.bits()))\n+                $crate::iter::Iter::__private_const_new(\n+                    <$PublicBitFlags as $crate::Flags>::FLAGS,\n+                    $PublicBitFlags::from_bits_retain(self.bits()),\n+                    $PublicBitFlags::from_bits_retain(self.bits()),\n+                )\n             }\n \n             \/\/\/ Iterate over enabled flag values with their stringified names.\n             #[inline]\n             pub const fn iter_names(&self) -> $crate::iter::IterNames<$PublicBitFlags> {\n-                $crate::iter::IterNames::__private_const_new(<$PublicBitFlags as $crate::Flags>::FLAGS, $PublicBitFlags::from_bits_retain(self.bits()), $PublicBitFlags::from_bits_retain(self.bits()))\n+                $crate::iter::IterNames::__private_const_new(\n+                    <$PublicBitFlags as $crate::Flags>::FLAGS,\n+                    $PublicBitFlags::from_bits_retain(self.bits()),\n+                    $PublicBitFlags::from_bits_retain(self.bits()),\n+                )\n             }\n         }\n \ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -300,25 +306,37 @@ macro_rules! __impl_public_bitflags_iter {\n macro_rules! __impl_public_bitflags_ops {\n     ($PublicBitFlags:ident) => {\n         impl $crate::__private::core::fmt::Binary for $PublicBitFlags {\n-            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n+            fn fmt(\n+                &self,\n+                f: &mut $crate::__private::core::fmt::Formatter,\n+            ) -> $crate::__private::core::fmt::Result {\n                 $crate::__private::core::fmt::Binary::fmt(&self.0, f)\n             }\n         }\n \n         impl $crate::__private::core::fmt::Octal for $PublicBitFlags {\n-            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n+            fn fmt(\n+                &self,\n+                f: &mut $crate::__private::core::fmt::Formatter,\n+            ) -> $crate::__private::core::fmt::Result {\n                 $crate::__private::core::fmt::Octal::fmt(&self.0, f)\n             }\n         }\n \n         impl $crate::__private::core::fmt::LowerHex for $PublicBitFlags {\n-            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n+            fn fmt(\n+                &self,\n+                f: &mut $crate::__private::core::fmt::Formatter,\n+            ) -> $crate::__private::core::fmt::Result {\n                 $crate::__private::core::fmt::LowerHex::fmt(&self.0, f)\n             }\n         }\n \n         impl $crate::__private::core::fmt::UpperHex for $PublicBitFlags {\n-            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n+            fn fmt(\n+                &self,\n+                f: &mut $crate::__private::core::fmt::Formatter,\n+            ) -> $crate::__private::core::fmt::Result {\n                 $crate::__private::core::fmt::UpperHex::fmt(&self.0, f)\n             }\n         }\ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -337,7 +355,7 @@ macro_rules! __impl_public_bitflags_ops {\n             \/\/\/ Adds the set of flags.\n             #[inline]\n             fn bitor_assign(&mut self, other: Self) {\n-                self.0 = self.0 | other.0;\n+                *self = Self::from_bits_retain(self.bits()).union(other);\n             }\n         }\n \ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -355,7 +373,7 @@ macro_rules! __impl_public_bitflags_ops {\n             \/\/\/ Toggles the set of flags.\n             #[inline]\n             fn bitxor_assign(&mut self, other: Self) {\n-                self.0 = self.0 ^ other.0\n+                *self = Self::from_bits_retain(self.bits()).symmetric_difference(other);\n             }\n         }\n \ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -373,7 +391,7 @@ macro_rules! __impl_public_bitflags_ops {\n             \/\/\/ Disables all flags disabled in the set.\n             #[inline]\n             fn bitand_assign(&mut self, other: Self) {\n-                self.0 = self.0 & other.0;\n+                *self = Self::from_bits_retain(self.bits()).intersection(other);\n             }\n         }\n \ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -391,7 +409,7 @@ macro_rules! __impl_public_bitflags_ops {\n             \/\/\/ Disables all flags enabled in the set.\n             #[inline]\n             fn sub_assign(&mut self, other: Self) {\n-                self.0 = self.0 & !other.0;\n+                *self = Self::from_bits_retain(self.bits()).difference(other);\n             }\n         }\n \ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -406,7 +424,10 @@ macro_rules! __impl_public_bitflags_ops {\n         }\n \n         impl $crate::__private::core::iter::Extend<$PublicBitFlags> for $PublicBitFlags {\n-            fn extend<T: $crate::__private::core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n+            fn extend<T: $crate::__private::core::iter::IntoIterator<Item = Self>>(\n+                &mut self,\n+                iterator: T,\n+            ) {\n                 for item in iterator {\n                     self.insert(item)\n                 }\ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -414,7 +435,9 @@ macro_rules! __impl_public_bitflags_ops {\n         }\n \n         impl $crate::__private::core::iter::FromIterator<$PublicBitFlags> for $PublicBitFlags {\n-            fn from_iter<T: $crate::__private::core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n+            fn from_iter<T: $crate::__private::core::iter::IntoIterator<Item = Self>>(\n+                iterator: T,\n+            ) -> Self {\n                 use $crate::__private::core::iter::Extend;\n \n                 let mut result = Self::empty();\ndiff --git a\/src\/traits.rs b\/src\/traits.rs\n--- a\/src\/traits.rs\n+++ b\/src\/traits.rs\n@@ -1,6 +1,12 @@\n-use core::{fmt, ops::{BitAnd, BitOr, BitXor, Not}};\n+use core::{\n+    fmt,\n+    ops::{BitAnd, BitOr, BitXor, Not},\n+};\n \n-use crate::{parser::{ParseError, ParseHex, WriteHex}, iter};\n+use crate::{\n+    iter,\n+    parser::{ParseError, ParseHex, WriteHex},\n+};\n \n \/\/\/ Metadata for an individual flag.\n pub struct Flag<B> {\ndiff --git a\/src\/traits.rs b\/src\/traits.rs\n--- a\/src\/traits.rs\n+++ b\/src\/traits.rs\n@@ -97,7 +103,7 @@ pub trait Flags: Sized + 'static {\n     fn from_name(name: &str) -> Option<Self> {\n         for flag in Self::FLAGS {\n             if flag.name() == name {\n-                return Some(Self::from_bits_retain(flag.value().bits()))\n+                return Some(Self::from_bits_retain(flag.value().bits()));\n             }\n         }\n \ndiff --git a\/src\/traits.rs b\/src\/traits.rs\n--- a\/src\/traits.rs\n+++ b\/src\/traits.rs\n@@ -143,6 +149,8 @@ pub trait Flags: Sized + 'static {\n     }\n \n     \/\/\/ Inserts the specified flags in-place.\n+    \/\/\/\n+    \/\/\/ This method is equivalent to `union`.\n     fn insert(&mut self, other: Self)\n     where\n         Self: Sized,\ndiff --git a\/src\/traits.rs b\/src\/traits.rs\n--- a\/src\/traits.rs\n+++ b\/src\/traits.rs\n@@ -151,6 +159,8 @@ pub trait Flags: Sized + 'static {\n     }\n \n     \/\/\/ Removes the specified flags in-place.\n+    \/\/\/\n+    \/\/\/ This method is equivalent to `difference`.\n     fn remove(&mut self, other: Self)\n     where\n         Self: Sized,\ndiff --git a\/src\/traits.rs b\/src\/traits.rs\n--- a\/src\/traits.rs\n+++ b\/src\/traits.rs\n@@ -159,6 +169,8 @@ pub trait Flags: Sized + 'static {\n     }\n \n     \/\/\/ Toggles the specified flags in-place.\n+    \/\/\/\n+    \/\/\/ This method is equivalent to `symmetric_difference`.\n     fn toggle(&mut self, other: Self)\n     where\n         Self: Sized,\ndiff --git a\/src\/traits.rs b\/src\/traits.rs\n--- a\/src\/traits.rs\n+++ b\/src\/traits.rs\n@@ -178,57 +190,32 @@ pub trait Flags: Sized + 'static {\n         }\n     }\n \n-    \/\/\/ Returns the intersection between the flags in `self` and\n-    \/\/\/ `other`.\n-    \/\/\/\n-    \/\/\/ Specifically, the returned set contains only the flags which are\n-    \/\/\/ present in *both* `self` *and* `other`.\n+    \/\/\/ Returns the intersection between the flags in `self` and `other`.\n     #[must_use]\n     fn intersection(self, other: Self) -> Self {\n         Self::from_bits_retain(self.bits() & other.bits())\n     }\n \n     \/\/\/ Returns the union of between the flags in `self` and `other`.\n-    \/\/\/\n-    \/\/\/ Specifically, the returned set contains all flags which are\n-    \/\/\/ present in *either* `self` *or* `other`, including any which are\n-    \/\/\/ present in both (see [`Self::symmetric_difference`] if that\n-    \/\/\/ is undesirable).\n     #[must_use]\n     fn union(self, other: Self) -> Self {\n         Self::from_bits_retain(self.bits() | other.bits())\n     }\n \n     \/\/\/ Returns the difference between the flags in `self` and `other`.\n-    \/\/\/\n-    \/\/\/ Specifically, the returned set contains all flags present in\n-    \/\/\/ `self`, except for the ones present in `other`.\n-    \/\/\/\n-    \/\/\/ It is also conceptually equivalent to the \"bit-clear\" operation:\n-    \/\/\/ `flags & !other` (and this syntax is also supported).\n     #[must_use]\n     fn difference(self, other: Self) -> Self {\n         Self::from_bits_retain(self.bits() & !other.bits())\n     }\n \n-    \/\/\/ Returns the [symmetric difference][sym-diff] between the flags\n+    \/\/\/ Returns the symmetric difference between the flags\n     \/\/\/ in `self` and `other`.\n-    \/\/\/\n-    \/\/\/ Specifically, the returned set contains the flags present which\n-    \/\/\/ are present in `self` or `other`, but that are not present in\n-    \/\/\/ both. Equivalently, it contains the flags present in *exactly\n-    \/\/\/ one* of the sets `self` and `other`.\n-    \/\/\/\n-    \/\/\/ [sym-diff]: https:\/\/en.wikipedia.org\/wiki\/Symmetric_difference\n     #[must_use]\n     fn symmetric_difference(self, other: Self) -> Self {\n         Self::from_bits_retain(self.bits() ^ other.bits())\n     }\n \n     \/\/\/ Returns the complement of this set of flags.\n-    \/\/\/\n-    \/\/\/ Specifically, the returned set contains all the flags which are\n-    \/\/\/ not set in `self`, but which are allowed for this type.\n     #[must_use]\n     fn complement(self) -> Self {\n         Self::from_bits_truncate(!self.bits())\n","version":"2.3","repo":"bitflags\/bitflags","environment_setup_commit":"09f71f492d0f76d63cd286c3869c70676297e204"}
{"problem_statement":"Clippy warnings around \"manual implementation of an assign operation\"\nHi.\r\n\r\nI've run into a new clippy lint warnings such as the following:\r\n\r\n> manual implementation of an assign operation\r\n> for further information visit https:\/\/rust-lang.github.io\/rust-clippy\/master\/index.html#assign_op_pattern\r\n> `#[warn(clippy::assign_op_pattern)]` on by default\r\n\r\nI'm following the example from the docs page for the use of the macro (more or less, as below). Can you enlighten me as to why this lint notification is appearing here and if there is some way to fix it? I know I can silence the warnings, it's just annoying to see it pop up whenever I run into it.\r\n\r\n```rust\r\nbitflags! {\r\n    pub struct MemoryAccess: u8 {\r\n        \/\/\/ None.\r\n        const N = 1 << 0;\r\n        \/\/\/ Public read.\r\n        const R = 1 << 1;\r\n        \/\/\/ Public write.\r\n        const W = 1 << 2;\r\n        \/\/\/ Private read.\r\n        const PR = 1 << 3;\r\n        \/\/\/ Private write.\r\n        const PW = 1 << 4;\r\n        \/\/\/ Execute.\r\n        const EX = 1 << 5;\r\n    }\r\n}\r\n```\r\n\r\nThanks!\n","test_patch":"diff --git a\/.github\/workflows\/rust.yml b\/.github\/workflows\/rust.yml\n--- a\/.github\/workflows\/rust.yml\n+++ b\/.github\/workflows\/rust.yml\n@@ -81,6 +81,23 @@ jobs:\n       - name: Default features\n         run: cross test --target mips-unknown-linux-gnu\n \n+  clippy:\n+    name: Clippy\n+    runs-on: ubuntu-latest\n+    steps:\n+      - name: Checkout sources\n+        uses: actions\/checkout@8e5e7e5ab8b370d6c329ec480221332ada57f0ab\n+\n+      - name: Install Clippy\n+        run: |\n+          rustup update beta\n+          rustup component add clippy --toolchain beta\n+\n+      - name: Default features\n+        run: |\n+          cd .\/tests\/smoke-test\n+          cargo +beta clippy\n+\n   embedded:\n     name: Build (embedded)\n     runs-on: ubuntu-latest\ndiff --git a\/tests\/compile-fail\/bitflags_custom_bits.rs b\/tests\/compile-fail\/bitflags_custom_bits.rs\n--- a\/tests\/compile-fail\/bitflags_custom_bits.rs\n+++ b\/tests\/compile-fail\/bitflags_custom_bits.rs\n@@ -19,7 +19,7 @@ use std::{\n     },\n };\n \n-use bitflags::{bitflags, Bits, parser::{ParseError, FromHex}};\n+use bitflags::{bitflags, Bits, parser::{ParseError, WriteHex, ParseHex}};\n \n \/\/ Ideally we'd actually want this to work, but currently need something like `num`'s `Zero`\n \/\/ With some design work it could be made possible\ndiff --git a\/tests\/compile-fail\/bitflags_custom_bits.rs b\/tests\/compile-fail\/bitflags_custom_bits.rs\n--- a\/tests\/compile-fail\/bitflags_custom_bits.rs\n+++ b\/tests\/compile-fail\/bitflags_custom_bits.rs\n@@ -117,12 +117,18 @@ impl Binary for MyInt {\n     }\n }\n \n-impl FromHex for MyInt {\n-    fn from_hex(input: &str) -> Result<Self, ParseError> {\n+impl ParseHex for MyInt {\n+    fn parse_hex(input: &str) -> Result<Self, ParseError> {\n         Ok(MyInt(u8::from_str_radix(input, 16).map_err(|_| ParseError::invalid_hex_flag(input))?))\n     }\n }\n \n+impl WriteHex for MyInt {\n+    fn write_hex<W: fmt::Write>(&self, writer: W) -> fmt::Result {\n+        LowerHex::fmt(&self.0, writer)\n+    }\n+}\n+\n bitflags! {\n     struct Flags128: MyInt {\n         const A = MyInt(0b0000_0001u8);\ndiff --git a\/tests\/compile-fail\/bitflags_custom_bits.stderr b\/tests\/compile-fail\/bitflags_custom_bits.stderr\n--- a\/tests\/compile-fail\/bitflags_custom_bits.stderr\n+++ b\/tests\/compile-fail\/bitflags_custom_bits.stderr\n@@ -1,7 +1,7 @@\n error[E0277]: the trait bound `MyInt: bitflags::traits::Primitive` is not satisfied\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:127:22\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:133:22\n     |\n-127 |     struct Flags128: MyInt {\n+133 |     struct Flags128: MyInt {\n     |                      ^^^^^ the trait `bitflags::traits::Primitive` is not implemented for `MyInt`\n     |\n     = help: the following other types implement trait `bitflags::traits::Primitive`:\ndiff --git a\/tests\/compile-fail\/bitflags_custom_bits.stderr b\/tests\/compile-fail\/bitflags_custom_bits.stderr\n--- a\/tests\/compile-fail\/bitflags_custom_bits.stderr\n+++ b\/tests\/compile-fail\/bitflags_custom_bits.stderr\n@@ -20,442 +20,457 @@ note: required by a bound in `PublicFlags::Primitive`\n     |     type Primitive: Primitive;\n     |                     ^^^^^^^^^ required by this bound in `PublicFlags::Primitive`\n \n+error[E0308]: mismatched types\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:128:32\n+    |\n+127 |     fn write_hex<W: fmt::Write>(&self, writer: W) -> fmt::Result {\n+    |                  - this type parameter\n+128 |         LowerHex::fmt(&self.0, writer)\n+    |         -------------          ^^^^^^ expected `&mut Formatter<'_>`, found type parameter `W`\n+    |         |\n+    |         arguments to this function are incorrect\n+    |\n+    = note: expected mutable reference `&mut Formatter<'_>`\n+                  found type parameter `W`\n+note: method defined here\n+   --> $RUST\/core\/src\/fmt\/mod.rs\n+\n error[E0277]: can't compare `MyInt` with `_` in const contexts\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n-    |\n-126 | \/ bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n+    |\n+132 | \/ bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt == _`\n     |\n     = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n-    |\n-126 | \/ bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n+    |\n+132 | \/ bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: can't compare `MyInt` with `_` in const contexts\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n-    |\n-126 | \/ bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n+    |\n+132 | \/ bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt == _`\n     |\n     = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n-    |\n-126 | \/ bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n+    |\n+132 | \/ bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `MyInt: BitAnd` is not satisfied\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n-    |\n-126 | \/ bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n+    |\n+132 | \/ bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt & MyInt`\n     |\n     = help: the trait `~const BitAnd` is not implemented for `MyInt`\n note: the trait `BitAnd` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n-    |\n-126 | \/ bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n+    |\n+132 | \/ bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: can't compare `MyInt` with `_` in const contexts\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n-    |\n-126 | \/ bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n+    |\n+132 | \/ bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt == _`\n     |\n     = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n-    |\n-126 | \/ bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n+    |\n+132 | \/ bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `MyInt: BitOr` is not satisfied\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n-    |\n-126 | \/ bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n+    |\n+132 | \/ bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt | MyInt`\n     |\n     = help: the trait `~const BitOr` is not implemented for `MyInt`\n note: the trait `BitOr` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n-    |\n-126 | \/ bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n+    |\n+132 | \/ bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: can't compare `MyInt` with `_` in const contexts\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n-    |\n-126 | \/ bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n+    |\n+132 | \/ bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt == _`\n     |\n     = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n-    |\n-126 | \/ bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n+    |\n+132 | \/ bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `MyInt: BitOr` is not satisfied\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n-    |\n-126 | \/ bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n+    |\n+132 | \/ bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt | MyInt`\n     |\n     = help: the trait `~const BitOr` is not implemented for `MyInt`\n note: the trait `BitOr` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n-    |\n-126 | \/ bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n+    |\n+132 | \/ bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: can't compare `MyInt` with `_` in const contexts\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n-    |\n-126 | \/ bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n+    |\n+132 | \/ bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt == _`\n     |\n     = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n-    |\n-126 | \/ bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n+    |\n+132 | \/ bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `MyInt: BitAnd` is not satisfied\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n-    |\n-126 | \/ bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n+    |\n+132 | \/ bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt & MyInt`\n     |\n     = help: the trait `~const BitAnd` is not implemented for `MyInt`\n note: the trait `BitAnd` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n-    |\n-126 | \/ bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n+    |\n+132 | \/ bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `MyInt: BitAnd` is not satisfied\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n-    |\n-126 | \/ bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n+    |\n+132 | \/ bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt & MyInt`\n     |\n     = help: the trait `~const BitAnd` is not implemented for `MyInt`\n note: the trait `BitAnd` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n-    |\n-126 | \/ bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n+    |\n+132 | \/ bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: can't compare `MyInt` with `_` in const contexts\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n-    |\n-126 | \/ bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n+    |\n+132 | \/ bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt == _`\n     |\n     = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n-    |\n-126 | \/ bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n+    |\n+132 | \/ bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `MyInt: BitAnd` is not satisfied\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n-    |\n-126 | \/ bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n+    |\n+132 | \/ bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt & MyInt`\n     |\n     = help: the trait `~const BitAnd` is not implemented for `MyInt`\n note: the trait `BitAnd` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n-    |\n-126 | \/ bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n+    |\n+132 | \/ bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `MyInt: BitOr` is not satisfied\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n-    |\n-126 | \/ bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n+    |\n+132 | \/ bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt | MyInt`\n     |\n     = help: the trait `~const BitOr` is not implemented for `MyInt`\n note: the trait `BitOr` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n-    |\n-126 | \/ bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n+    |\n+132 | \/ bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `MyInt: BitAnd` is not satisfied\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n-    |\n-126 | \/ bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n+    |\n+132 | \/ bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt & MyInt`\n     |\n     = help: the trait `~const BitAnd` is not implemented for `MyInt`\n note: the trait `BitAnd` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n-    |\n-126 | \/ bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n+    |\n+132 | \/ bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `MyInt: Not` is not satisfied\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n-    |\n-126 | \/ bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n+    |\n+132 | \/ bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ the trait `~const Not` is not implemented for `MyInt`\n     |\n note: the trait `Not` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n-    |\n-126 | \/ bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n+    |\n+132 | \/ bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `MyInt: BitXor` is not satisfied\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n-    |\n-126 | \/ bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n+    |\n+132 | \/ bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt ^ MyInt`\n     |\n     = help: the trait `~const BitXor` is not implemented for `MyInt`\n note: the trait `BitXor` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n-    |\n-126 | \/ bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n+    |\n+132 | \/ bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `MyInt: Not` is not satisfied\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n-    |\n-126 | \/ bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n+    |\n+132 | \/ bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ the trait `~const Not` is not implemented for `MyInt`\n     |\n note: the trait `Not` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n-    |\n-126 | \/ bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:132:1\n+    |\n+132 | \/ bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\ndiff --git \/dev\/null b\/tests\/compile-pass\/bitflags_self_in_value.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/tests\/compile-pass\/bitflags_self_in_value.rs\n@@ -0,0 +1,15 @@\n+use bitflags::bitflags;\n+\n+bitflags! {\n+    pub struct Flags: u32 {\n+        const SOME_FLAG = 1 << Self::SOME_FLAG_SHIFT;\n+    }\n+}\n+\n+impl Flags {\n+    const SOME_FLAG_SHIFT: u32 = 5;\n+}\n+\n+fn main() {\n+    \n+}\ndiff --git a\/tests\/smoke-test\/src\/main.rs b\/tests\/smoke-test\/src\/main.rs\n--- a\/tests\/smoke-test\/src\/main.rs\n+++ b\/tests\/smoke-test\/src\/main.rs\n@@ -1,3 +1,5 @@\n+#![deny(warnings)]\n+\n use bitflags::bitflags;\n \n bitflags! {\n","hints_text":"","base_commit":"31d3e4afefc964045156d7fe3622733f48511353","issue_numbers":["357"],"created_at":"2023-05-17T11:22:15Z","pull_number":355,"instance_id":"bitflags__bitflags-355","patch":"diff --git a\/src\/example_generated.rs b\/src\/example_generated.rs\n--- a\/src\/example_generated.rs\n+++ b\/src\/example_generated.rs\n@@ -39,7 +39,7 @@ __impl_public_bitflags_forward! {\n }\n \n __impl_public_bitflags_iter! {\n-    Flags\n+    Flags: u32, Flags\n }\n \n __impl_public_bitflags_consts! {\ndiff --git a\/src\/external.rs b\/src\/external.rs\n--- a\/src\/external.rs\n+++ b\/src\/external.rs\n@@ -19,7 +19,7 @@ Next, define a macro like so:\n #[cfg(feature = \"serde\")]\n macro_rules! __impl_external_bitflags_my_library {\n     (\n-        $InternalBitFlags:ident: $T:ty {\n+        $InternalBitFlags:ident: $T:ty, $PublicBitFlags:ident {\n             $(\n                 $(#[$attr:ident $($args:tt)*])*\n                 $Flag:ident;\ndiff --git a\/src\/external.rs b\/src\/external.rs\n--- a\/src\/external.rs\n+++ b\/src\/external.rs\n@@ -35,7 +35,7 @@ macro_rules! __impl_external_bitflags_my_library {\n #[cfg(not(feature = \"my_library\"))]\n macro_rules! __impl_external_bitflags_my_library {\n     (\n-        $InternalBitFlags:ident: $T:ty {\n+        $InternalBitFlags:ident: $T:ty, $PublicBitFlags:ident {\n             $(\n                 $(#[$attr:ident $($args:tt)*])*\n                 $Flag:ident;\ndiff --git a\/src\/external.rs b\/src\/external.rs\n--- a\/src\/external.rs\n+++ b\/src\/external.rs\n@@ -55,7 +55,7 @@ Now, we add our macro call to the `__impl_external_bitflags` macro body:\n \n ```rust\n __impl_external_bitflags_my_library! {\n-    $InternalBitFlags: $T {\n+    $InternalBitFlags: $T, $PublicBitFlags {\n         $(\n             $(#[$attr $($args)*])*\n             $Flag;\ndiff --git a\/src\/external.rs b\/src\/external.rs\n--- a\/src\/external.rs\n+++ b\/src\/external.rs\n@@ -76,6 +76,51 @@ pub(crate) mod __private {\n     pub use bytemuck;\n }\n \n+\/\/\/ Implements traits from external libraries for the internal bitflags type.\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+macro_rules! __impl_external_bitflags {\n+    (\n+        $InternalBitFlags:ident: $T:ty, $PublicBitFlags:ident {\n+            $(\n+                $(#[$attr:ident $($args:tt)*])*\n+                $Flag:ident;\n+            )*\n+        }\n+    ) => {\n+        \/\/ Any new library traits impls should be added here\n+        \/\/ Use `serde` as an example: generate code when the feature is available,\n+        \/\/ and a no-op when it isn't\n+\n+        __impl_external_bitflags_serde! {\n+            $InternalBitFlags: $T, $PublicBitFlags {\n+                $(\n+                    $(#[$attr $($args)*])*\n+                    $Flag;\n+                )*\n+            }\n+        }\n+\n+        __impl_external_bitflags_arbitrary! {\n+            $InternalBitFlags: $T, $PublicBitFlags {\n+                $(\n+                    $(#[$attr $($args)*])*\n+                    $Flag;\n+                )*\n+            }\n+        }\n+\n+        __impl_external_bitflags_bytemuck! {\n+            $InternalBitFlags: $T, $PublicBitFlags {\n+                $(\n+                    $(#[$attr $($args)*])*\n+                    $Flag;\n+                )*\n+            }\n+        }\n+    };\n+}\n+\n #[cfg(feature = \"serde\")]\n pub mod serde;\n \ndiff --git a\/src\/external.rs b\/src\/external.rs\n--- a\/src\/external.rs\n+++ b\/src\/external.rs\n@@ -85,11 +130,11 @@ pub mod serde;\n #[cfg(feature = \"serde\")]\n macro_rules! __impl_external_bitflags_serde {\n     (\n-        $InternalBitFlags:ident: $T:ty {\n+        $InternalBitFlags:ident: $T:ty, $PublicBitFlags:ident {\n             $(\n                 $(#[$attr:ident $($args:tt)*])*\n                 $Flag:ident;\n-                )*\n+            )*\n         }\n     ) => {\n         impl $crate::__private::serde::Serialize for $InternalBitFlags {\ndiff --git a\/src\/external.rs b\/src\/external.rs\n--- a\/src\/external.rs\n+++ b\/src\/external.rs\n@@ -98,7 +143,7 @@ macro_rules! __impl_external_bitflags_serde {\n                 serializer: S,\n             ) -> $crate::__private::core::result::Result<S::Ok, S::Error> {\n                 $crate::serde::serialize(\n-                    self,\n+                    &$PublicBitFlags::from_bits_retain(self.bits()),\n                     serializer,\n                 )\n             }\ndiff --git a\/src\/external.rs b\/src\/external.rs\n--- a\/src\/external.rs\n+++ b\/src\/external.rs\n@@ -108,9 +153,11 @@ macro_rules! __impl_external_bitflags_serde {\n             fn deserialize<D: $crate::__private::serde::Deserializer<'de>>(\n                 deserializer: D,\n             ) -> $crate::__private::core::result::Result<Self, D::Error> {\n-                $crate::serde::deserialize(\n+                let flags: $PublicBitFlags = $crate::serde::deserialize(\n                     deserializer,\n-                )\n+                )?;\n+\n+                Ok(flags.0)\n             }\n         }\n     };\ndiff --git a\/src\/external.rs b\/src\/external.rs\n--- a\/src\/external.rs\n+++ b\/src\/external.rs\n@@ -121,11 +168,11 @@ macro_rules! __impl_external_bitflags_serde {\n #[cfg(not(feature = \"serde\"))]\n macro_rules! __impl_external_bitflags_serde {\n     (\n-        $InternalBitFlags:ident: $T:ty {\n+        $InternalBitFlags:ident: $T:ty, $PublicBitFlags:ident {\n             $(\n                 $(#[$attr:ident $($args:tt)*])*\n                 $Flag:ident;\n-                )*\n+            )*\n         }\n     ) => {};\n }\ndiff --git a\/src\/external.rs b\/src\/external.rs\n--- a\/src\/external.rs\n+++ b\/src\/external.rs\n@@ -136,58 +183,13 @@ pub mod arbitrary;\n #[cfg(feature = \"bytemuck\")]\n mod bytemuck;\n \n-\/\/\/ Implements traits from external libraries for the internal bitflags type.\n-#[macro_export(local_inner_macros)]\n-#[doc(hidden)]\n-macro_rules! __impl_external_bitflags {\n-    (\n-        $InternalBitFlags:ident: $T:ty {\n-            $(\n-                $(#[$attr:ident $($args:tt)*])*\n-                $Flag:ident;\n-            )*\n-        }\n-    ) => {\n-        \/\/ Any new library traits impls should be added here\n-        \/\/ Use `serde` as an example: generate code when the feature is available,\n-        \/\/ and a no-op when it isn't\n-\n-        __impl_external_bitflags_serde! {\n-            $InternalBitFlags: $T {\n-                $(\n-                    $(#[$attr $($args)*])*\n-                    $Flag;\n-                )*\n-            }\n-        }\n-\n-        __impl_external_bitflags_arbitrary! {\n-            $InternalBitFlags: $T {\n-                $(\n-                    $(#[$attr $($args)*])*\n-                    $Flag;\n-                )*\n-            }\n-        }\n-\n-        __impl_external_bitflags_bytemuck! {\n-            $InternalBitFlags: $T {\n-                $(\n-                    $(#[$attr $($args)*])*\n-                    $Flag;\n-                )*\n-            }\n-        }\n-    };\n-}\n-\n \/\/\/ Implement `Arbitrary` for the internal bitflags type.\n #[macro_export(local_inner_macros)]\n #[doc(hidden)]\n #[cfg(feature = \"arbitrary\")]\n macro_rules! __impl_external_bitflags_arbitrary {\n     (\n-            $InternalBitFlags:ident: $T:ty {\n+            $InternalBitFlags:ident: $T:ty, $PublicBitFlags:ident {\n                 $(\n                     $(#[$attr:ident $($args:tt)*])*\n                     $Flag:ident;\ndiff --git a\/src\/external.rs b\/src\/external.rs\n--- a\/src\/external.rs\n+++ b\/src\/external.rs\n@@ -198,7 +200,7 @@ macro_rules! __impl_external_bitflags_arbitrary {\n             fn arbitrary(\n                 u: &mut $crate::__private::arbitrary::Unstructured<'a>,\n             ) -> $crate::__private::arbitrary::Result<Self> {\n-                $crate::arbitrary::arbitrary(u)\n+                $crate::arbitrary::arbitrary::<$PublicBitFlags>(u).map(|flags| flags.0)\n             }\n         }\n     };\ndiff --git a\/src\/external.rs b\/src\/external.rs\n--- a\/src\/external.rs\n+++ b\/src\/external.rs\n@@ -209,12 +211,12 @@ macro_rules! __impl_external_bitflags_arbitrary {\n #[cfg(not(feature = \"arbitrary\"))]\n macro_rules! __impl_external_bitflags_arbitrary {\n     (\n-            $InternalBitFlags:ident: $T:ty {\n-                $(\n-                    $(#[$attr:ident $($args:tt)*])*\n-                    $Flag:ident;\n-                )*\n-            }\n+        $InternalBitFlags:ident: $T:ty, $PublicBitFlags:ident {\n+            $(\n+                $(#[$attr:ident $($args:tt)*])*\n+                $Flag:ident;\n+            )*\n+        }\n     ) => {};\n }\n \ndiff --git a\/src\/external.rs b\/src\/external.rs\n--- a\/src\/external.rs\n+++ b\/src\/external.rs\n@@ -224,11 +226,11 @@ macro_rules! __impl_external_bitflags_arbitrary {\n #[cfg(feature = \"bytemuck\")]\n macro_rules! __impl_external_bitflags_bytemuck {\n     (\n-        $InternalBitFlags:ident: $T:ty {\n+        $InternalBitFlags:ident: $T:ty, $PublicBitFlags:ident {\n             $(\n                 $(#[$attr:ident $($args:tt)*])*\n-                    $Flag:ident;\n-                )*\n+                $Flag:ident;\n+            )*\n         }\n     ) => {\n         \/\/ SAFETY: $InternalBitFlags is guaranteed to have the same ABI as $T,\ndiff --git a\/src\/external.rs b\/src\/external.rs\n--- a\/src\/external.rs\n+++ b\/src\/external.rs\n@@ -256,11 +258,11 @@ macro_rules! __impl_external_bitflags_bytemuck {\n #[cfg(not(feature = \"bytemuck\"))]\n macro_rules! __impl_external_bitflags_bytemuck {\n     (\n-        $InternalBitFlags:ident: $T:ty {\n+        $InternalBitFlags:ident: $T:ty, $PublicBitFlags:ident {\n             $(\n                 $(#[$attr:ident $($args:tt)*])*\n-                    $Flag:ident;\n-                )*\n+                $Flag:ident;\n+            )*\n         }\n     ) => {};\n }\ndiff --git a\/src\/internal.rs b\/src\/internal.rs\n--- a\/src\/internal.rs\n+++ b\/src\/internal.rs\n@@ -98,7 +98,7 @@ macro_rules! __impl_internal_bitflags {\n         \/\/ The internal flags type offers a similar API to the public one\n \n         __impl_public_bitflags! {\n-            $InternalBitFlags: $T {\n+            $InternalBitFlags: $T, $PublicBitFlags {\n                 $(\n                     $(#[$attr $($args)*])*\n                     $Flag;\ndiff --git a\/src\/internal.rs b\/src\/internal.rs\n--- a\/src\/internal.rs\n+++ b\/src\/internal.rs\n@@ -106,19 +106,8 @@ macro_rules! __impl_internal_bitflags {\n             }\n         }\n \n-        __impl_public_bitflags_consts! {\n-            $InternalBitFlags: $T {\n-                $(\n-                    $(#[$attr $($args)*])*\n-                    #[allow(\n-                        dead_code,\n-                        deprecated,\n-                        unused_attributes,\n-                        non_upper_case_globals\n-                    )]\n-                    $Flag = $value;\n-                )*\n-            }\n+        __impl_public_bitflags_iter! {\n+            $InternalBitFlags: $T, $PublicBitFlags\n         }\n \n         impl $InternalBitFlags {\ndiff --git a\/src\/internal.rs b\/src\/internal.rs\n--- a\/src\/internal.rs\n+++ b\/src\/internal.rs\n@@ -127,18 +116,6 @@ macro_rules! __impl_internal_bitflags {\n             pub fn bits_mut(&mut self) -> &mut $T {\n                 &mut self.0\n             }\n-\n-            \/\/\/ Iterate over enabled flag values.\n-            #[inline]\n-            pub const fn iter(&self) -> $crate::iter::Iter<$PublicBitFlags> {\n-                $crate::iter::Iter::__private_const_new(<$PublicBitFlags as $crate::Flags>::FLAGS, $PublicBitFlags::from_bits_retain(self.0), $PublicBitFlags::from_bits_retain(self.0))\n-            }\n-\n-            \/\/\/ Iterate over enabled flag values with their stringified names.\n-            #[inline]\n-            pub const fn iter_names(&self) -> $crate::iter::IterNames<$PublicBitFlags> {\n-                $crate::iter::IterNames::__private_const_new(<$PublicBitFlags as $crate::Flags>::FLAGS, $PublicBitFlags::from_bits_retain(self.0), $PublicBitFlags::from_bits_retain(self.0))\n-            }\n         }\n     };\n }\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -590,7 +590,8 @@ macro_rules! bitflags {\n             unused_attributes,\n             unused_mut,\n             unused_imports,\n-            non_upper_case_globals\n+            non_upper_case_globals,\n+            clippy::assign_op_pattern\n         )]\n         const _: () = {\n             \/\/ Declared in a \"hidden\" scope that can't be reached directly\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -610,7 +611,7 @@ macro_rules! bitflags {\n \n             \/\/ This is where new library trait implementations can be added\n             __impl_external_bitflags! {\n-                InternalBitFlags: $T {\n+                InternalBitFlags: $T, $BitFlags {\n                     $(\n                         $(#[$inner $($args)*])*\n                         $Flag;\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -623,7 +624,7 @@ macro_rules! bitflags {\n             }\n \n             __impl_public_bitflags_iter! {\n-                $BitFlags\n+                $BitFlags: $T, $BitFlags\n             }\n         };\n \ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -657,11 +658,12 @@ macro_rules! bitflags {\n             unused_attributes,\n             unused_mut,\n             unused_imports,\n-            non_upper_case_globals\n+            non_upper_case_globals,\n+            clippy::assign_op_pattern\n         )]\n         const _: () = {\n             __impl_public_bitflags! {\n-                $BitFlags: $T {\n+                $BitFlags: $T, $BitFlags {\n                     $(\n                         $(#[$inner $($args)*])*\n                         $Flag;\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -670,7 +672,7 @@ macro_rules! bitflags {\n             }\n \n             __impl_public_bitflags_iter! {\n-                $BitFlags\n+                $BitFlags: $T, $BitFlags\n             }\n         };\n \ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -57,7 +57,7 @@ macro_rules! __impl_public_bitflags_forward {\n                     Self($InternalBitFlags::from_bits_retain(bits))\n                 }\n \n-                fn from_name(name){\n+                fn from_name(name) {\n                     match $InternalBitFlags::from_name(name) {\n                         $crate::__private::core::option::Option::Some(bits) => $crate::__private::core::option::Option::Some(Self(bits)),\n                         $crate::__private::core::option::Option::None => $crate::__private::core::option::Option::None,\ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -130,7 +130,7 @@ macro_rules! __impl_public_bitflags_forward {\n #[doc(hidden)]\n macro_rules! __impl_public_bitflags {\n     (\n-        $PublicBitFlags:ident: $T:ty {\n+        $BitFlags:ident: $T:ty, $PublicBitFlags:ident {\n             $(\n                 $(#[$attr:ident $($args:tt)*])*\n                 $Flag:ident;\ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -138,7 +138,7 @@ macro_rules! __impl_public_bitflags {\n         }\n     ) => {\n         __impl_bitflags! {\n-            $PublicBitFlags: $T {\n+            $BitFlags: $T {\n                 fn empty() {\n                     Self(<$T as $crate::Bits>::EMPTY)\n                 }\ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -260,7 +260,7 @@ macro_rules! __impl_public_bitflags {\n             }\n         }\n \n-        __impl_public_bitflags_ops!($PublicBitFlags);\n+        __impl_public_bitflags_ops!($BitFlags);\n     };\n }\n \ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -268,8 +268,8 @@ macro_rules! __impl_public_bitflags {\n #[macro_export(local_inner_macros)]\n #[doc(hidden)]\n macro_rules! __impl_public_bitflags_iter {\n-    ($PublicBitFlags:ident) => {\n-        impl $PublicBitFlags {\n+    ($BitFlags:ident: $T:ty, $PublicBitFlags:ident) => {\n+        impl $BitFlags {\n             \/\/\/ Iterate over enabled flag values.\n             #[inline]\n             pub const fn iter(&self) -> $crate::iter::Iter<$PublicBitFlags> {\ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -283,8 +283,8 @@ macro_rules! __impl_public_bitflags_iter {\n             }\n         }\n \n-        impl $crate::__private::core::iter::IntoIterator for $PublicBitFlags {\n-            type Item = Self;\n+        impl $crate::__private::core::iter::IntoIterator for $BitFlags {\n+            type Item = $PublicBitFlags;\n             type IntoIter = $crate::iter::Iter<$PublicBitFlags>;\n \n             fn into_iter(self) -> Self::IntoIter {\n","version":"2.3","repo":"bitflags\/bitflags","environment_setup_commit":"09f71f492d0f76d63cd286c3869c70676297e204"}
{"problem_statement":"Allow external impls of Bits and BitFlags\nThe `BitFlags` trait is currently sealed, and is only supported through the `bitflags!` macro. I think we should make this trait publicly implementable, and default most of its members. I spent some time hacking on this, and came up with this minimal implementation.\r\n\r\nGiven a flags type like:\r\n\r\n```rust\r\nbitflags! {\r\n    pub struct MyFlags: u32 {\r\n        const A = 0b0000_0001;\r\n        const B = 0b0000_0010;\r\n        const C = 0b0000_0100;\r\n    }\r\n};\r\n```\r\n\r\nYou can implement it manually with:\r\n\r\n```rust\r\npub struct MyFlags {\r\n    bits: u32,\r\n}\r\n\r\nimpl BitFlags for MyFlags {\r\n    const FLAGS: &'static [(&'static str, Self::Bits)] = &[\r\n        (\"A\", 0b0000_0001),\r\n        (\"B\", 0b0000_0010),\r\n        (\"C\", 0b0000_0100),\r\n    ];\r\n\r\n    type Bits = u32;\r\n    type Iter = bitflags::iter::Iter<Self>;\r\n    type IterNames = bitflags::iter::IterNames<Self>;\r\n\r\n    fn bits(&self) -> Self::Bits {\r\n        self.bits\r\n    }\r\n\r\n    fn from_bits_retain(bits: Self::Bits) -> Self {\r\n        Self {\r\n            bits\r\n        }\r\n    }\r\n\r\n    fn iter(&self) -> Self::Iter {\r\n        bitflags::iter::Iter::new(self)\r\n    }\r\n\r\n    fn iter_names(&self) -> Self::IterNames {\r\n        bitflags::iter::IterNames::new(self)\r\n    }\r\n}\r\n```\r\n\r\nI'm proposing we _don't_ do #293, so that the implementation of `BitFlags` doesn't call for a host of supertraits.\r\n\r\nThe `FLAGS` constant there is new, and drives the iteration-based methods like `from_bits_truncate`, `from_name`, and the implementations of `Iter` and `IterNames`. If you squint, it looks a lot like the body of the `bitflags` macro.\r\n\r\nI think doing this has a few benefits:\r\n\r\n1. It makes the trait \"real\", so you can implement it and work with it yourself.\r\n2. It moves most of the generated code out of macros where they don't need to use fully-qualified paths like `$crate::__private::core::option::Option::Some<T>`.\r\n3. It gives us a starting point for #347 and #339, where you might not be able to use the `bitflags!` macro, but with a small amount of effort, can cook up your own flags type with whatever shape you want, and still get the benefits of generated code.\r\n\r\nFor trait impls like `serde` and `arbitrary`, we can then expose utilities like that proposed `bitflags::iter` module that make manual impls of those traits with awareness that the type is a flags enum easy:\r\n\r\n```rust\r\nimpl Serialize for MyFlags {\r\n    fn serialize<S: Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {\r\n        bitflags::serde::serialize(self, serializer)\r\n    }\r\n}\r\n```\r\n\r\nI'm keen to hear what people think of this.\n","test_patch":"diff --git a\/.github\/workflows\/rust.yml b\/.github\/workflows\/rust.yml\n--- a\/.github\/workflows\/rust.yml\n+++ b\/.github\/workflows\/rust.yml\n@@ -10,40 +10,21 @@ permissions:\n \n jobs:\n   check:\n-    name: \"Tests \/ OS: ${{ matrix.os }} - ${{ matrix.channel }}-${{ matrix.rust_target }}\"\n-    runs-on: ${{ matrix.os }}\n+    name: \"Tests\"\n+    runs-on: ubuntu-latest\n     strategy:\n       matrix:\n-        exclude:\n-        - os: macos-10.15\n-          rust_target: x86_64-gnu\n-        - os: macos-10.15\n-          rust_target: x86_64-msvc\n-        - os: windows-2019\n-          rust_target: x86_64-apple-darwin\n-        - os: ubuntu-20.04\n-          rust_target: x86_64-msvc\n-        - os: ubuntu-20.04\n-          rust_target: x86_64-apple-darwin\n         channel:\n         - stable\n         - beta\n         - nightly\n-        os:\n-        - macos-10.15\n-        - windows-2019\n-        - ubuntu-20.04\n-        rust_target:\n-        - x86_64-gnu\n-        - x86_64-msvc\n-        - x86_64-apple-darwin\n \n     steps:\n     - name: Checkout repository\n       uses: actions\/checkout@8e5e7e5ab8b370d6c329ec480221332ada57f0ab\n \n     - name: Install Rust Toolchain\n-      run: rustup default ${{ matrix.channel }}-${{ matrix.rust_target }}\n+      run: rustup default ${{ matrix.channel }}\n \n     - name: Install cargo-hack\n       run: cargo install cargo-hack\ndiff --git a\/.github\/workflows\/rust.yml b\/.github\/workflows\/rust.yml\n--- a\/.github\/workflows\/rust.yml\n+++ b\/.github\/workflows\/rust.yml\n@@ -87,6 +68,19 @@ jobs:\n           cd .\/tests\/smoke-test\n           cargo +$msrv build\n \n+  mips:\n+    name: Tests \/ MIPS (Big Endian)\n+    runs-on: ubuntu-latest\n+    steps:\n+      - name: Checkout sources\n+        uses: actions\/checkout@8e5e7e5ab8b370d6c329ec480221332ada57f0ab\n+\n+      - name: Install Cross\n+        run: cargo install cross\n+\n+      - name: Default features\n+        run: cross test --target mips-unknown-linux-gnu\n+\n   embedded:\n     name: Build (embedded)\n     runs-on: ubuntu-latest\ndiff --git a\/Cargo.toml b\/Cargo.toml\n--- a\/Cargo.toml\n+++ b\/Cargo.toml\n@@ -32,6 +32,7 @@ rustversion = \"1.0\"\n serde_derive = \"1.0\"\n serde_json = \"1.0\"\n serde_test = \"1.0\"\n+zerocopy = \"0.6\"\n arbitrary = { version = \"1.0\", features = [\"derive\"] }\n bytemuck = { version = \"1.0\", features = [\"derive\"] }\n \ndiff --git a\/src\/external\/arbitrary_support.rs b\/src\/external\/arbitrary.rs\n--- a\/src\/external\/arbitrary_support.rs\n+++ b\/src\/external\/arbitrary.rs\n@@ -1,3 +1,17 @@\n+\/\/! Specialized fuzzing for flags types using `arbitrary`.\n+\n+use crate::Flags;\n+\n+\/\/\/ Get a random known flags value.\n+pub fn arbitrary<'a, B: Flags>(\n+    u: &mut arbitrary::Unstructured<'a>,\n+) -> arbitrary::Result<B>\n+where\n+    B::Bits: arbitrary::Arbitrary<'a>\n+{\n+    B::from_bits(u.arbitrary()?).ok_or_else(|| arbitrary::Error::IncorrectFormat)\n+}\n+\n #[cfg(test)]\n mod tests {\n     use arbitrary::Arbitrary;\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -422,22 +422,29 @@\n \n #![cfg_attr(not(any(feature = \"std\", test)), no_std)]\n #![cfg_attr(not(test), forbid(unsafe_code))]\n-\n #![doc(html_root_url = \"https:\/\/docs.rs\/bitflags\/2.2.1\")]\n \n #[doc(inline)]\n-pub use traits::BitFlags;\n+pub use traits::{Flags, Flag, Bits};\n \n+pub mod iter;\n pub mod parser;\n+\n mod traits;\n \n #[doc(hidden)]\n pub mod __private {\n-    pub use crate::{external::*, traits::*};\n+    pub use crate::{external::__private::*, traits::__private::*};\n \n     pub use core;\n }\n \n+#[allow(unused_imports)]\n+pub use external::*;\n+\n+#[allow(deprecated)]\n+pub use traits::BitFlags;\n+\n \/*\n How does the bitflags crate work?\n \ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -650,6 +1051,9 @@ mod tests {\n         str,\n     };\n \n+    #[derive(Debug, PartialEq, Eq)]\n+    pub struct ManualFlags(u32);\n+\n     bitflags! {\n         #[doc = \"> The first principle is that you must not fool yourself \u2014 and\"]\n         #[doc = \"> you are the easiest person to fool.\"]\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -686,6 +1090,17 @@ mod tests {\n         struct LongFlags: u32 {\n             const LONG_A = 0b1111111111111111;\n         }\n+\n+        impl ManualFlags: u32 {\n+            const A = 0b00000001;\n+            #[doc = \"<pcwalton> macros are way better at generating code than trans is\"]\n+            const B = 0b00000010;\n+            const C = 0b00000100;\n+            #[doc = \"* cmr bed\"]\n+            #[doc = \"* strcat table\"]\n+            #[doc = \"<strcat> wait what?\"]\n+            const ABC = Self::A.bits() | Self::B.bits() | Self::C.bits();\n+        }\n     }\n \n     bitflags! {\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -724,6 +1139,8 @@ mod tests {\n         assert_eq!(Flags::A.bits(), 0b00000001);\n         assert_eq!(Flags::ABC.bits(), 0b00000111);\n \n+        assert_eq!(<Flags as crate::Flags>::bits(&Flags::ABC), 0b00000111);\n+\n         assert_eq!(AnotherSetOfFlags::empty().bits(), 0b00);\n         assert_eq!(AnotherSetOfFlags::ANOTHER_FLAG.bits(), !0_i8);\n \ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -738,6 +1155,8 @@ mod tests {\n         assert_eq!(Flags::from_bits(0b11), Some(Flags::A | Flags::B));\n         assert_eq!(Flags::from_bits(0b1000), None);\n \n+        assert_eq!(<Flags as crate::Flags>::from_bits(0b11), Some(Flags::A | Flags::B));\n+\n         assert_eq!(\n             AnotherSetOfFlags::from_bits(!0_i8),\n             Some(AnotherSetOfFlags::ANOTHER_FLAG)\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -756,6 +1175,8 @@ mod tests {\n         assert_eq!(Flags::from_bits_truncate(0b1000), Flags::empty());\n         assert_eq!(Flags::from_bits_truncate(0b1001), Flags::A);\n \n+        assert_eq!(<Flags as crate::Flags>::from_bits_truncate(0b11), (Flags::A | Flags::B));\n+\n         assert_eq!(\n             AnotherSetOfFlags::from_bits_truncate(0_i8),\n             AnotherSetOfFlags::empty()\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -776,6 +1197,8 @@ mod tests {\n         assert_eq!(Flags::from_bits_retain(0b1000), (extra | Flags::empty()));\n         assert_eq!(Flags::from_bits_retain(0b1001), (extra | Flags::A));\n \n+        assert_eq!(<Flags as crate::Flags>::from_bits_retain(0b11), (Flags::A | Flags::B));\n+\n         let extra = EmptyFlags::from_bits_retain(0b1000);\n         assert_eq!(\n             EmptyFlags::from_bits_retain(0b1000),\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -789,6 +1212,8 @@ mod tests {\n         assert!(!Flags::A.is_empty());\n         assert!(!Flags::ABC.is_empty());\n \n+        assert!(!<Flags as crate::Flags>::is_empty(&Flags::ABC));\n+\n         assert!(!AnotherSetOfFlags::ANOTHER_FLAG.is_empty());\n \n         assert!(EmptyFlags::empty().is_empty());\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -806,6 +1231,8 @@ mod tests {\n         assert!(!(Flags::A | extra).is_all());\n         assert!((Flags::ABC | extra).is_all());\n \n+        assert!(<Flags as crate::Flags>::is_all(&Flags::all()));\n+\n         assert!(AnotherSetOfFlags::ANOTHER_FLAG.is_all());\n \n         assert!(EmptyFlags::all().is_all());\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -818,6 +1245,8 @@ mod tests {\n         let e2 = Flags::empty();\n         assert!(!e1.intersects(e2));\n \n+        assert!(!<Flags as crate::Flags>::intersects(&e1, e2));\n+\n         assert!(AnotherSetOfFlags::ANOTHER_FLAG.intersects(AnotherSetOfFlags::ANOTHER_FLAG));\n     }\n \ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -826,6 +1255,8 @@ mod tests {\n         let e1 = Flags::empty();\n         let e2 = Flags::ABC;\n         assert!(!e1.intersects(e2));\n+\n+        assert!(!<Flags as crate::Flags>::intersects(&e1, e2));\n     }\n \n     #[test]\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -833,6 +1264,8 @@ mod tests {\n         let e1 = Flags::A;\n         let e2 = Flags::B;\n         assert!(!e1.intersects(e2));\n+\n+        assert!(!<Flags as crate::Flags>::intersects(&e1, e2));\n     }\n \n     #[test]\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -840,6 +1273,8 @@ mod tests {\n         let e1 = Flags::A;\n         let e2 = Flags::A | Flags::B;\n         assert!(e1.intersects(e2));\n+\n+        assert!(<Flags as crate::Flags>::intersects(&e1, e2));\n     }\n \n     #[test]\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -850,6 +1285,8 @@ mod tests {\n         assert!(e2.contains(e1));\n         assert!(Flags::ABC.contains(e2));\n \n+        assert!(<Flags as crate::Flags>::contains(&Flags::ABC, e2));\n+\n         assert!(AnotherSetOfFlags::ANOTHER_FLAG.contains(AnotherSetOfFlags::ANOTHER_FLAG));\n \n         assert!(EmptyFlags::empty().contains(EmptyFlags::empty()));\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -862,6 +1299,11 @@ mod tests {\n         e1.insert(e2);\n         assert_eq!(e1, e2);\n \n+        let mut e1 = Flags::A;\n+        let e2 = Flags::A | Flags::B;\n+        <Flags as crate::Flags>::insert(&mut e1, e2);\n+        assert_eq!(e1, e2);\n+\n         let mut e3 = AnotherSetOfFlags::empty();\n         e3.insert(AnotherSetOfFlags::ANOTHER_FLAG);\n         assert_eq!(e3, AnotherSetOfFlags::ANOTHER_FLAG);\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -874,6 +1316,11 @@ mod tests {\n         e1.remove(e2);\n         assert_eq!(e1, Flags::B);\n \n+        let mut e1 = Flags::A | Flags::B;\n+        let e2 = Flags::A | Flags::C;\n+        <Flags as crate::Flags>::remove(&mut e1, e2);\n+        assert_eq!(e1, Flags::B);\n+\n         let mut e3 = AnotherSetOfFlags::ANOTHER_FLAG;\n         e3.remove(AnotherSetOfFlags::ANOTHER_FLAG);\n         assert_eq!(e3, AnotherSetOfFlags::empty());\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -926,6 +1373,8 @@ mod tests {\n         assert_eq!(ac, Flags::C.union(Flags::A));\n         assert_eq!(bc, Flags::C.union(Flags::B));\n \n+        assert_eq!(ac, <Flags as crate::Flags>::union(Flags::A, Flags::C));\n+\n         assert_eq!(ac, Flags::A | Flags::C);\n         assert_eq!(bc, Flags::B | Flags::C);\n         assert_eq!(ab.union(bc), Flags::ABC);\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -941,15 +1390,24 @@ mod tests {\n         assert_eq!(ac.intersection(bc), Flags::C);\n         assert_eq!(bc.intersection(ac), Flags::C);\n \n+        assert_eq!(Flags::C, <Flags as crate::Flags>::intersection(ac, bc));\n+\n         assert_eq!(ac.difference(bc), ac - bc);\n         assert_eq!(bc.difference(ac), bc - ac);\n         assert_eq!(ac.difference(bc), Flags::A);\n         assert_eq!(bc.difference(ac), Flags::B);\n \n+        assert_eq!(bc, <Flags as crate::Flags>::difference(bc, Flags::A));\n+\n         assert_eq!(bc.complement(), !bc);\n         assert_eq!(bc.complement(), Flags::A);\n+\n+        assert_eq!(Flags::A, <Flags as crate::Flags>::complement(bc));\n+\n         assert_eq!(ac.symmetric_difference(bc), Flags::A.union(Flags::B));\n         assert_eq!(bc.symmetric_difference(ac), Flags::A.union(Flags::B));\n+\n+        assert_eq!(ab, <Flags as crate::Flags>::symmetric_difference(ac, bc));\n     }\n \n     #[test]\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -1287,7 +1745,6 @@ mod tests {\n         parse_case(FmtFlags::empty(), \"\");\n         parse_case(FmtFlags::empty(), \" \\r\\n\\t\");\n         parse_case(FmtFlags::empty(), \"0x0\");\n-        parse_case(FmtFlags::empty(), \"0x0\");\n \n         parse_case(FmtFlags::\uace0\uc591\uc774, \"\uace0\uc591\uc774\");\n         parse_case(FmtFlags::\uace0\uc591\uc774, \"  \uace0\uc591\uc774  \");\ndiff --git a\/tests\/compile-fail\/visibility\/private_flags.stderr b\/tests\/compile-fail\/access_outside_visibility.stderr\n--- a\/tests\/compile-fail\/visibility\/private_flags.stderr\n+++ b\/tests\/compile-fail\/access_outside_visibility.stderr\n@@ -1,11 +1,11 @@\n error[E0603]: struct `Flags2` is private\n-  --> tests\/compile-fail\/visibility\/private_flags.rs:17:22\n+  --> tests\/compile-fail\/access_outside_visibility.rs:17:22\n    |\n 17 |     let _ = example::Flags2::FLAG_B;\n    |                      ^^^^^^ private struct\n    |\n note: the struct `Flags2` is defined here\n-  --> tests\/compile-fail\/visibility\/private_flags.rs:4:5\n+  --> tests\/compile-fail\/access_outside_visibility.rs:4:5\n    |\n 4  | \/     bitflags! {\n 5  | |         pub struct Flags1: u32 {\ndiff --git a\/tests\/compile-fail\/visibility\/private_flags.stderr b\/tests\/compile-fail\/access_outside_visibility.stderr\n--- a\/tests\/compile-fail\/visibility\/private_flags.stderr\n+++ b\/tests\/compile-fail\/access_outside_visibility.stderr\n@@ -15,4 +15,4 @@ note: the struct `Flags2` is defined here\n 11 | |         }\n 12 | |     }\n    | |_____^\n-   = note: this error originates in the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+   = note: this error originates in the macro `__declare_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\ndiff --git a\/tests\/compile-fail\/non_integer_base\/all_defined.rs b\/tests\/compile-fail\/bitflags_custom_bits.rs\n--- a\/tests\/compile-fail\/non_integer_base\/all_defined.rs\n+++ b\/tests\/compile-fail\/bitflags_custom_bits.rs\n@@ -19,13 +19,18 @@ use std::{\n     },\n };\n \n-use bitflags::bitflags;\n+use bitflags::{bitflags, Bits, parser::{ParseError, FromHex}};\n \n \/\/ Ideally we'd actually want this to work, but currently need something like `num`'s `Zero`\n \/\/ With some design work it could be made possible\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n struct MyInt(u8);\n \n+impl Bits for MyInt {\n+    const EMPTY: Self = MyInt(u8::MIN);\n+    const ALL: Self = MyInt(u8::MAX);\n+}\n+\n impl BitAnd for MyInt {\n     type Output = Self;\n \ndiff --git a\/tests\/compile-fail\/non_integer_base\/all_defined.rs b\/tests\/compile-fail\/bitflags_custom_bits.rs\n--- a\/tests\/compile-fail\/non_integer_base\/all_defined.rs\n+++ b\/tests\/compile-fail\/bitflags_custom_bits.rs\n@@ -68,6 +73,14 @@ impl BitXorAssign for MyInt {\n     }\n }\n \n+impl Not for MyInt {\n+    type Output = MyInt;\n+\n+    fn not(self) -> Self {\n+        MyInt(!self.0)\n+    }\n+}\n+\n impl Debug for MyInt {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         Debug::fmt(&self.0, f)\ndiff --git a\/tests\/compile-fail\/non_integer_base\/all_defined.rs b\/tests\/compile-fail\/bitflags_custom_bits.rs\n--- a\/tests\/compile-fail\/non_integer_base\/all_defined.rs\n+++ b\/tests\/compile-fail\/bitflags_custom_bits.rs\n@@ -104,11 +117,9 @@ impl Binary for MyInt {\n     }\n }\n \n-impl Not for MyInt {\n-    type Output = MyInt;\n-\n-    fn not(self) -> Self {\n-        MyInt(!self.0)\n+impl FromHex for MyInt {\n+    fn from_hex(input: &str) -> Result<Self, ParseError> {\n+        Ok(MyInt(u8::from_str_radix(input, 16).map_err(|_| ParseError::invalid_hex_flag(input))?))\n     }\n }\n \ndiff --git \/dev\/null b\/tests\/compile-fail\/bitflags_custom_bits.stderr\nnew file mode 100644\n--- \/dev\/null\n+++ b\/tests\/compile-fail\/bitflags_custom_bits.stderr\n@@ -0,0 +1,461 @@\n+error[E0277]: the trait bound `MyInt: bitflags::traits::Primitive` is not satisfied\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:127:22\n+    |\n+127 |     struct Flags128: MyInt {\n+    |                      ^^^^^ the trait `bitflags::traits::Primitive` is not implemented for `MyInt`\n+    |\n+    = help: the following other types implement trait `bitflags::traits::Primitive`:\n+              i128\n+              i16\n+              i32\n+              i64\n+              i8\n+              isize\n+              u128\n+              u16\n+            and $N others\n+note: required by a bound in `PublicFlags::Primitive`\n+   --> src\/traits.rs\n+    |\n+    |     type Primitive: Primitive;\n+    |                     ^^^^^^^^^ required by this bound in `PublicFlags::Primitive`\n+\n+error[E0277]: can't compare `MyInt` with `_` in const contexts\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n+    |\n+126 | \/ bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^ no implementation for `MyInt == _`\n+    |\n+    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n+note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n+    |\n+126 | \/ bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: can't compare `MyInt` with `_` in const contexts\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n+    |\n+126 | \/ bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^ no implementation for `MyInt == _`\n+    |\n+    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n+note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n+    |\n+126 | \/ bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: the trait bound `MyInt: BitAnd` is not satisfied\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n+    |\n+126 | \/ bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^ no implementation for `MyInt & MyInt`\n+    |\n+    = help: the trait `~const BitAnd` is not implemented for `MyInt`\n+note: the trait `BitAnd` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n+    |\n+126 | \/ bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: can't compare `MyInt` with `_` in const contexts\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n+    |\n+126 | \/ bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^ no implementation for `MyInt == _`\n+    |\n+    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n+note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n+    |\n+126 | \/ bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: the trait bound `MyInt: BitOr` is not satisfied\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n+    |\n+126 | \/ bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^ no implementation for `MyInt | MyInt`\n+    |\n+    = help: the trait `~const BitOr` is not implemented for `MyInt`\n+note: the trait `BitOr` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n+    |\n+126 | \/ bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: can't compare `MyInt` with `_` in const contexts\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n+    |\n+126 | \/ bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^ no implementation for `MyInt == _`\n+    |\n+    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n+note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n+    |\n+126 | \/ bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: the trait bound `MyInt: BitOr` is not satisfied\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n+    |\n+126 | \/ bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^ no implementation for `MyInt | MyInt`\n+    |\n+    = help: the trait `~const BitOr` is not implemented for `MyInt`\n+note: the trait `BitOr` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n+    |\n+126 | \/ bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: can't compare `MyInt` with `_` in const contexts\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n+    |\n+126 | \/ bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^ no implementation for `MyInt == _`\n+    |\n+    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n+note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n+    |\n+126 | \/ bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: the trait bound `MyInt: BitAnd` is not satisfied\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n+    |\n+126 | \/ bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^ no implementation for `MyInt & MyInt`\n+    |\n+    = help: the trait `~const BitAnd` is not implemented for `MyInt`\n+note: the trait `BitAnd` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n+    |\n+126 | \/ bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: the trait bound `MyInt: BitAnd` is not satisfied\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n+    |\n+126 | \/ bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^ no implementation for `MyInt & MyInt`\n+    |\n+    = help: the trait `~const BitAnd` is not implemented for `MyInt`\n+note: the trait `BitAnd` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n+    |\n+126 | \/ bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: can't compare `MyInt` with `_` in const contexts\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n+    |\n+126 | \/ bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^ no implementation for `MyInt == _`\n+    |\n+    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n+note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n+    |\n+126 | \/ bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: the trait bound `MyInt: BitAnd` is not satisfied\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n+    |\n+126 | \/ bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^ no implementation for `MyInt & MyInt`\n+    |\n+    = help: the trait `~const BitAnd` is not implemented for `MyInt`\n+note: the trait `BitAnd` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n+    |\n+126 | \/ bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: the trait bound `MyInt: BitOr` is not satisfied\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n+    |\n+126 | \/ bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^ no implementation for `MyInt | MyInt`\n+    |\n+    = help: the trait `~const BitOr` is not implemented for `MyInt`\n+note: the trait `BitOr` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n+    |\n+126 | \/ bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: the trait bound `MyInt: BitAnd` is not satisfied\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n+    |\n+126 | \/ bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^ no implementation for `MyInt & MyInt`\n+    |\n+    = help: the trait `~const BitAnd` is not implemented for `MyInt`\n+note: the trait `BitAnd` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n+    |\n+126 | \/ bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: the trait bound `MyInt: Not` is not satisfied\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n+    |\n+126 | \/ bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^ the trait `~const Not` is not implemented for `MyInt`\n+    |\n+note: the trait `Not` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n+    |\n+126 | \/ bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: the trait bound `MyInt: BitXor` is not satisfied\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n+    |\n+126 | \/ bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^ no implementation for `MyInt ^ MyInt`\n+    |\n+    = help: the trait `~const BitXor` is not implemented for `MyInt`\n+note: the trait `BitXor` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n+    |\n+126 | \/ bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: the trait bound `MyInt: Not` is not satisfied\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n+    |\n+126 | \/ bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^ the trait `~const Not` is not implemented for `MyInt`\n+    |\n+note: the trait `Not` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests\/compile-fail\/bitflags_custom_bits.rs:126:1\n+    |\n+126 | \/ bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\ndiff --git \/dev\/null b\/tests\/compile-fail\/bitflags_missing_type.stderr\nnew file mode 100644\n--- \/dev\/null\n+++ b\/tests\/compile-fail\/bitflags_missing_type.stderr\n@@ -0,0 +1,17 @@\n+error: no rules expected the token `{`\n+ --> tests\/compile-fail\/bitflags_missing_type.rs:5:23\n+  |\n+5 |     pub struct Flags1 {\n+  |                       ^ no rules expected this token in macro call\n+  |\n+note: while trying to match `:`\n+ --> src\/lib.rs\n+  |\n+  |         $vis:vis struct $BitFlags:ident: $T:ty {\n+  |                                        ^\n+\n+error[E0601]: `main` function not found in crate `$CRATE`\n+ --> tests\/compile-fail\/bitflags_missing_type.rs:8:2\n+  |\n+8 | }\n+  |  ^ consider adding a `main` function to `$DIR\/tests\/compile-fail\/bitflags_missing_type.rs`\ndiff --git a\/tests\/compile-fail\/syntax\/missing_value.rs b\/tests\/compile-fail\/bitflags_missing_value.rs\n--- a\/tests\/compile-fail\/syntax\/missing_value.rs\n+++ b\/tests\/compile-fail\/bitflags_missing_value.rs\n@@ -2,7 +2,7 @@\n extern crate bitflags;\n \n bitflags! {\n-    pub struct Flags1 {\n+    pub struct Flags1: u32 {\n         const A;\n     }\n }\ndiff --git \/dev\/null b\/tests\/compile-fail\/bitflags_missing_value.stderr\nnew file mode 100644\n--- \/dev\/null\n+++ b\/tests\/compile-fail\/bitflags_missing_value.stderr\n@@ -0,0 +1,17 @@\n+error: no rules expected the token `;`\n+ --> tests\/compile-fail\/bitflags_missing_value.rs:6:16\n+  |\n+6 |         const A;\n+  |                ^ no rules expected this token in macro call\n+  |\n+note: while trying to match `=`\n+ --> src\/lib.rs\n+  |\n+  |                 const $Flag:ident = $value:expr;\n+  |                                   ^\n+\n+error[E0601]: `main` function not found in crate `$CRATE`\n+ --> tests\/compile-fail\/bitflags_missing_value.rs:8:2\n+  |\n+8 | }\n+  |  ^ consider adding a `main` function to `$DIR\/tests\/compile-fail\/bitflags_missing_value.rs`\ndiff --git a\/tests\/compile-fail\/visibility\/pub_const.stderr b\/tests\/compile-fail\/bitflags_pub_const.stderr\n--- a\/tests\/compile-fail\/visibility\/pub_const.stderr\n+++ b\/tests\/compile-fail\/bitflags_pub_const.stderr\n@@ -1,5 +1,11 @@\n error: no rules expected the token `pub`\n- --> $DIR\/pub_const.rs:5:9\n+ --> tests\/compile-fail\/bitflags_pub_const.rs:5:9\n   |\n 5 |         pub const FLAG_A = 0b00000001;\n   |         ^^^ no rules expected this token in macro call\n+  |\n+note: while trying to match `}`\n+ --> src\/lib.rs\n+  |\n+  |         }\n+  |         ^\ndiff --git a\/tests\/compile-fail\/redefined.rs b\/tests\/compile-fail\/bitflags_redefined.rs\n--- a\/tests\/compile-fail\/redefined.rs\n+++ b\/tests\/compile-fail\/bitflags_redefined.rs\n@@ -2,13 +2,13 @@\n extern crate bitflags;\n \n bitflags! {\n-    pub struct Flags1 {\n+    pub struct Flags1: u32 {\n         const A = 1;\n     }\n }\n \n bitflags! {\n-    pub struct Flags1 {\n+    pub struct Flags1: u32 {\n         const A = 1;\n     }\n }\ndiff --git \/dev\/null b\/tests\/compile-fail\/bitflags_redefined.stderr\nnew file mode 100644\n--- \/dev\/null\n+++ b\/tests\/compile-fail\/bitflags_redefined.stderr\n@@ -0,0 +1,804 @@\n+error[E0428]: the name `Flags1` is defined multiple times\n+  --> tests\/compile-fail\/bitflags_redefined.rs:4:1\n+   |\n+4  | \/ bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ `Flags1` redefined here\n+9  |\n+10 | \/ bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- previous definition of the type `Flags1` here\n+   |\n+   = note: `Flags1` must be defined only once in the type namespace of this module\n+   = note: this error originates in the macro `__declare_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0601]: `main` function not found in crate `$CRATE`\n+  --> tests\/compile-fail\/bitflags_redefined.rs:14:2\n+   |\n+14 | }\n+   |  ^ consider adding a `main` function to `$DIR\/tests\/compile-fail\/bitflags_redefined.rs`\n+\n+error[E0119]: conflicting implementations of trait `Flags` for type `Flags1`\n+  --> tests\/compile-fail\/bitflags_redefined.rs:10:1\n+   |\n+4  | \/ bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_- first implementation here\n+9  |\n+10 | \/ bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_^ conflicting implementation for `Flags1`\n+   |\n+   = note: this error originates in the macro `__impl_public_bitflags_consts` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0119]: conflicting implementations of trait `PublicFlags` for type `Flags1`\n+  --> tests\/compile-fail\/bitflags_redefined.rs:10:1\n+   |\n+4  | \/ bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_- first implementation here\n+9  |\n+10 | \/ bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_^ conflicting implementation for `Flags1`\n+   |\n+   = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0119]: conflicting implementations of trait `Binary` for type `Flags1`\n+  --> tests\/compile-fail\/bitflags_redefined.rs:10:1\n+   |\n+4  | \/ bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_- first implementation here\n+9  |\n+10 | \/ bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_^ conflicting implementation for `Flags1`\n+   |\n+   = note: this error originates in the macro `__impl_public_bitflags_ops` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0119]: conflicting implementations of trait `Octal` for type `Flags1`\n+  --> tests\/compile-fail\/bitflags_redefined.rs:10:1\n+   |\n+4  | \/ bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_- first implementation here\n+9  |\n+10 | \/ bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_^ conflicting implementation for `Flags1`\n+   |\n+   = note: this error originates in the macro `__impl_public_bitflags_ops` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0119]: conflicting implementations of trait `LowerHex` for type `Flags1`\n+  --> tests\/compile-fail\/bitflags_redefined.rs:10:1\n+   |\n+4  | \/ bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_- first implementation here\n+9  |\n+10 | \/ bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_^ conflicting implementation for `Flags1`\n+   |\n+   = note: this error originates in the macro `__impl_public_bitflags_ops` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0119]: conflicting implementations of trait `UpperHex` for type `Flags1`\n+  --> tests\/compile-fail\/bitflags_redefined.rs:10:1\n+   |\n+4  | \/ bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_- first implementation here\n+9  |\n+10 | \/ bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_^ conflicting implementation for `Flags1`\n+   |\n+   = note: this error originates in the macro `__impl_public_bitflags_ops` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0119]: conflicting implementations of trait `BitOr` for type `Flags1`\n+  --> tests\/compile-fail\/bitflags_redefined.rs:10:1\n+   |\n+4  | \/ bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_- first implementation here\n+9  |\n+10 | \/ bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_^ conflicting implementation for `Flags1`\n+   |\n+   = note: this error originates in the macro `__impl_public_bitflags_ops` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0119]: conflicting implementations of trait `BitOrAssign` for type `Flags1`\n+  --> tests\/compile-fail\/bitflags_redefined.rs:10:1\n+   |\n+4  | \/ bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_- first implementation here\n+9  |\n+10 | \/ bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_^ conflicting implementation for `Flags1`\n+   |\n+   = note: this error originates in the macro `__impl_public_bitflags_ops` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0119]: conflicting implementations of trait `BitXor` for type `Flags1`\n+  --> tests\/compile-fail\/bitflags_redefined.rs:10:1\n+   |\n+4  | \/ bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_- first implementation here\n+9  |\n+10 | \/ bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_^ conflicting implementation for `Flags1`\n+   |\n+   = note: this error originates in the macro `__impl_public_bitflags_ops` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0119]: conflicting implementations of trait `BitXorAssign` for type `Flags1`\n+  --> tests\/compile-fail\/bitflags_redefined.rs:10:1\n+   |\n+4  | \/ bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_- first implementation here\n+9  |\n+10 | \/ bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_^ conflicting implementation for `Flags1`\n+   |\n+   = note: this error originates in the macro `__impl_public_bitflags_ops` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0119]: conflicting implementations of trait `BitAnd` for type `Flags1`\n+  --> tests\/compile-fail\/bitflags_redefined.rs:10:1\n+   |\n+4  | \/ bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_- first implementation here\n+9  |\n+10 | \/ bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_^ conflicting implementation for `Flags1`\n+   |\n+   = note: this error originates in the macro `__impl_public_bitflags_ops` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0119]: conflicting implementations of trait `BitAndAssign` for type `Flags1`\n+  --> tests\/compile-fail\/bitflags_redefined.rs:10:1\n+   |\n+4  | \/ bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_- first implementation here\n+9  |\n+10 | \/ bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_^ conflicting implementation for `Flags1`\n+   |\n+   = note: this error originates in the macro `__impl_public_bitflags_ops` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0119]: conflicting implementations of trait `Sub` for type `Flags1`\n+  --> tests\/compile-fail\/bitflags_redefined.rs:10:1\n+   |\n+4  | \/ bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_- first implementation here\n+9  |\n+10 | \/ bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_^ conflicting implementation for `Flags1`\n+   |\n+   = note: this error originates in the macro `__impl_public_bitflags_ops` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0119]: conflicting implementations of trait `SubAssign` for type `Flags1`\n+  --> tests\/compile-fail\/bitflags_redefined.rs:10:1\n+   |\n+4  | \/ bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_- first implementation here\n+9  |\n+10 | \/ bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_^ conflicting implementation for `Flags1`\n+   |\n+   = note: this error originates in the macro `__impl_public_bitflags_ops` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0119]: conflicting implementations of trait `Not` for type `Flags1`\n+  --> tests\/compile-fail\/bitflags_redefined.rs:10:1\n+   |\n+4  | \/ bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_- first implementation here\n+9  |\n+10 | \/ bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_^ conflicting implementation for `Flags1`\n+   |\n+   = note: this error originates in the macro `__impl_public_bitflags_ops` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0119]: conflicting implementations of trait `Extend<Flags1>` for type `Flags1`\n+  --> tests\/compile-fail\/bitflags_redefined.rs:10:1\n+   |\n+4  | \/ bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_- first implementation here\n+9  |\n+10 | \/ bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_^ conflicting implementation for `Flags1`\n+   |\n+   = note: this error originates in the macro `__impl_public_bitflags_ops` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0119]: conflicting implementations of trait `FromIterator<Flags1>` for type `Flags1`\n+  --> tests\/compile-fail\/bitflags_redefined.rs:10:1\n+   |\n+4  | \/ bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_- first implementation here\n+9  |\n+10 | \/ bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_^ conflicting implementation for `Flags1`\n+   |\n+   = note: this error originates in the macro `__impl_public_bitflags_ops` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0119]: conflicting implementations of trait `IntoIterator` for type `Flags1`\n+  --> tests\/compile-fail\/bitflags_redefined.rs:10:1\n+   |\n+4  | \/ bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_- first implementation here\n+9  |\n+10 | \/ bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_^ conflicting implementation for `Flags1`\n+   |\n+   = note: this error originates in the macro `__impl_public_bitflags_iter` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `A`\n+  --> tests\/compile-fail\/bitflags_redefined.rs:4:1\n+   |\n+4  | \/ bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `A`\n+9  |\n+10 | \/ bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `A`\n+   |\n+   = note: this error originates in the macro `__impl_public_bitflags_consts` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `empty`\n+  --> tests\/compile-fail\/bitflags_redefined.rs:4:1\n+   |\n+4  | \/ bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `empty`\n+9  |\n+10 | \/ bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `empty`\n+   |\n+   = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `all`\n+  --> tests\/compile-fail\/bitflags_redefined.rs:4:1\n+   |\n+4  | \/ bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `all`\n+9  |\n+10 | \/ bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `all`\n+   |\n+   = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `bits`\n+  --> tests\/compile-fail\/bitflags_redefined.rs:4:1\n+   |\n+4  | \/ bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `bits`\n+9  |\n+10 | \/ bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `bits`\n+   |\n+   = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `from_bits`\n+  --> tests\/compile-fail\/bitflags_redefined.rs:4:1\n+   |\n+4  | \/ bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `from_bits`\n+9  |\n+10 | \/ bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `from_bits`\n+   |\n+   = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `from_bits_truncate`\n+  --> tests\/compile-fail\/bitflags_redefined.rs:4:1\n+   |\n+4  | \/ bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `from_bits_truncate`\n+9  |\n+10 | \/ bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `from_bits_truncate`\n+   |\n+   = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `from_bits_retain`\n+  --> tests\/compile-fail\/bitflags_redefined.rs:4:1\n+   |\n+4  | \/ bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `from_bits_retain`\n+9  |\n+10 | \/ bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `from_bits_retain`\n+   |\n+   = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `from_name`\n+  --> tests\/compile-fail\/bitflags_redefined.rs:4:1\n+   |\n+4  | \/ bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `from_name`\n+9  |\n+10 | \/ bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `from_name`\n+   |\n+   = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `is_empty`\n+  --> tests\/compile-fail\/bitflags_redefined.rs:4:1\n+   |\n+4  | \/ bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `is_empty`\n+9  |\n+10 | \/ bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `is_empty`\n+   |\n+   = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `is_all`\n+  --> tests\/compile-fail\/bitflags_redefined.rs:4:1\n+   |\n+4  | \/ bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `is_all`\n+9  |\n+10 | \/ bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `is_all`\n+   |\n+   = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `intersects`\n+  --> tests\/compile-fail\/bitflags_redefined.rs:4:1\n+   |\n+4  | \/ bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `intersects`\n+9  |\n+10 | \/ bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `intersects`\n+   |\n+   = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `contains`\n+  --> tests\/compile-fail\/bitflags_redefined.rs:4:1\n+   |\n+4  | \/ bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `contains`\n+9  |\n+10 | \/ bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `contains`\n+   |\n+   = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `insert`\n+  --> tests\/compile-fail\/bitflags_redefined.rs:4:1\n+   |\n+4  | \/ bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `insert`\n+9  |\n+10 | \/ bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `insert`\n+   |\n+   = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `remove`\n+  --> tests\/compile-fail\/bitflags_redefined.rs:4:1\n+   |\n+4  | \/ bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `remove`\n+9  |\n+10 | \/ bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `remove`\n+   |\n+   = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `toggle`\n+  --> tests\/compile-fail\/bitflags_redefined.rs:4:1\n+   |\n+4  | \/ bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `toggle`\n+9  |\n+10 | \/ bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `toggle`\n+   |\n+   = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `set`\n+  --> tests\/compile-fail\/bitflags_redefined.rs:4:1\n+   |\n+4  | \/ bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `set`\n+9  |\n+10 | \/ bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `set`\n+   |\n+   = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `intersection`\n+  --> tests\/compile-fail\/bitflags_redefined.rs:4:1\n+   |\n+4  | \/ bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `intersection`\n+9  |\n+10 | \/ bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `intersection`\n+   |\n+   = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `union`\n+  --> tests\/compile-fail\/bitflags_redefined.rs:4:1\n+   |\n+4  | \/ bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `union`\n+9  |\n+10 | \/ bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `union`\n+   |\n+   = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `difference`\n+  --> tests\/compile-fail\/bitflags_redefined.rs:4:1\n+   |\n+4  | \/ bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `difference`\n+9  |\n+10 | \/ bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `difference`\n+   |\n+   = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `symmetric_difference`\n+  --> tests\/compile-fail\/bitflags_redefined.rs:4:1\n+   |\n+4  | \/ bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `symmetric_difference`\n+9  |\n+10 | \/ bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `symmetric_difference`\n+   |\n+   = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `complement`\n+  --> tests\/compile-fail\/bitflags_redefined.rs:4:1\n+   |\n+4  | \/ bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `complement`\n+9  |\n+10 | \/ bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `complement`\n+   |\n+   = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `iter`\n+  --> tests\/compile-fail\/bitflags_redefined.rs:4:1\n+   |\n+4  | \/ bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `iter`\n+9  |\n+10 | \/ bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `iter`\n+   |\n+   = note: this error originates in the macro `__impl_public_bitflags_iter` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `iter_names`\n+  --> tests\/compile-fail\/bitflags_redefined.rs:4:1\n+   |\n+4  | \/ bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `iter_names`\n+9  |\n+10 | \/ bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `iter_names`\n+   |\n+   = note: this error originates in the macro `__impl_public_bitflags_iter` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\ndiff --git \/dev\/null b\/tests\/compile-fail\/bitflags_trait_custom.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/tests\/compile-fail\/bitflags_trait_custom.rs\n@@ -0,0 +1,9 @@\n+use bitflags::BitFlags;\n+\n+pub struct BootlegFlags(u32);\n+\n+impl BitFlags for BootlegFlags {\n+    type Bits = u32;\n+}\n+\n+fn main() {}\ndiff --git \/dev\/null b\/tests\/compile-fail\/bitflags_trait_custom.stderr\nnew file mode 100644\n--- \/dev\/null\n+++ b\/tests\/compile-fail\/bitflags_trait_custom.stderr\n@@ -0,0 +1,31 @@\n+error[E0437]: type `Bits` is not a member of trait `BitFlags`\n+ --> tests\/compile-fail\/bitflags_trait_custom.rs:6:5\n+  |\n+6 |     type Bits = u32;\n+  |     ^^^^^^^^^^^^^^^^ not a member of trait `BitFlags`\n+\n+warning: use of deprecated trait `bitflags::BitFlags`: use the `Flags` trait instead\n+ --> tests\/compile-fail\/bitflags_trait_custom.rs:1:15\n+  |\n+1 | use bitflags::BitFlags;\n+  |               ^^^^^^^^\n+  |\n+  = note: `#[warn(deprecated)]` on by default\n+\n+warning: use of deprecated trait `bitflags::BitFlags`: use the `Flags` trait instead\n+ --> tests\/compile-fail\/bitflags_trait_custom.rs:5:6\n+  |\n+5 | impl BitFlags for BootlegFlags {\n+  |      ^^^^^^^^\n+\n+error[E0277]: the trait bound `BootlegFlags: Flags` is not satisfied\n+ --> tests\/compile-fail\/bitflags_trait_custom.rs:5:19\n+  |\n+5 | impl BitFlags for BootlegFlags {\n+  |                   ^^^^^^^^^^^^ the trait `Flags` is not implemented for `BootlegFlags`\n+  |\n+note: required by a bound in `BitFlags`\n+ --> src\/traits.rs\n+  |\n+  | pub trait BitFlags: ImplementedByBitFlagsMacro + Flags {\n+  |                                                  ^^^^^ required by this bound in `BitFlags`\ndiff --git \/dev\/null b\/tests\/compile-fail\/bitflags_trait_deprecated.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/tests\/compile-fail\/bitflags_trait_deprecated.rs\n@@ -0,0 +1,5 @@\n+#![deny(warnings)]\n+\n+pub use bitflags::BitFlags;\n+\n+fn main() {}\ndiff --git \/dev\/null b\/tests\/compile-fail\/bitflags_trait_deprecated.stderr\nnew file mode 100644\n--- \/dev\/null\n+++ b\/tests\/compile-fail\/bitflags_trait_deprecated.stderr\n@@ -0,0 +1,12 @@\n+error: use of deprecated trait `bitflags::BitFlags`: use the `Flags` trait instead\n+ --> tests\/compile-fail\/bitflags_trait_deprecated.rs:3:19\n+  |\n+3 | pub use bitflags::BitFlags;\n+  |                   ^^^^^^^^\n+  |\n+note: the lint level is defined here\n+ --> tests\/compile-fail\/bitflags_trait_deprecated.rs:1:9\n+  |\n+1 | #![deny(warnings)]\n+  |         ^^^^^^^^\n+  = note: `#[deny(deprecated)]` implied by `#[deny(warnings)]`\ndiff --git a\/tests\/compile-fail\/non_integer_base\/all_defined.stderr \/dev\/null\n--- a\/tests\/compile-fail\/non_integer_base\/all_defined.stderr\n+++ \/dev\/null\n@@ -1,297 +0,0 @@\n-error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n-   --> tests\/compile-fail\/non_integer_base\/all_defined.rs:116:22\n-    |\n-116 |     struct Flags128: MyInt {\n-    |                      ^^^^^ the trait `Bits` is not implemented for `MyInt`\n-    |\n-    = help: the following other types implement trait `Bits`:\n-              i128\n-              i16\n-              i32\n-              i64\n-              i8\n-              u128\n-              u16\n-              u32\n-            and 2 others\n-note: required by a bound in `bitflags::BitFlags::Bits`\n-   --> src\/bitflags_trait.rs\n-    |\n-    |     type Bits: Bits;\n-    |                ^^^^ required by this bound in `bitflags::BitFlags::Bits`\n-\n-error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n-   --> tests\/compile-fail\/non_integer_base\/all_defined.rs:115:1\n-    |\n-115 | \/ bitflags! {\n-116 | |     struct Flags128: MyInt {\n-117 | |         const A = MyInt(0b0000_0001u8);\n-118 | |         const B = MyInt(0b0000_0010u8);\n-119 | |         const C = MyInt(0b0000_0100u8);\n-120 | |     }\n-121 | | }\n-    | |_^ the trait `Bits` is not implemented for `MyInt`\n-    |\n-    = help: the following other types implement trait `Bits`:\n-              i128\n-              i16\n-              i32\n-              i64\n-              i8\n-              u128\n-              u16\n-              u32\n-            and 2 others\n-    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n-   --> tests\/compile-fail\/non_integer_base\/all_defined.rs:115:1\n-    |\n-115 | \/ bitflags! {\n-116 | |     struct Flags128: MyInt {\n-117 | |         const A = MyInt(0b0000_0001u8);\n-118 | |         const B = MyInt(0b0000_0010u8);\n-119 | |         const C = MyInt(0b0000_0100u8);\n-120 | |     }\n-121 | | }\n-    | |_^ the trait `Bits` is not implemented for `MyInt`\n-    |\n-    = help: the following other types implement trait `Bits`:\n-              i128\n-              i16\n-              i32\n-              i64\n-              i8\n-              u128\n-              u16\n-              u32\n-            and 2 others\n-    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n-   --> tests\/compile-fail\/non_integer_base\/all_defined.rs:115:1\n-    |\n-115 | \/ bitflags! {\n-116 | |     struct Flags128: MyInt {\n-117 | |         const A = MyInt(0b0000_0001u8);\n-118 | |         const B = MyInt(0b0000_0010u8);\n-119 | |         const C = MyInt(0b0000_0100u8);\n-120 | |     }\n-121 | | }\n-    | |_^ the trait `Bits` is not implemented for `MyInt`\n-    |\n-    = help: the following other types implement trait `Bits`:\n-              i128\n-              i16\n-              i32\n-              i64\n-              i8\n-              u128\n-              u16\n-              u32\n-            and 2 others\n-    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: can't compare `MyInt` with `_` in const contexts\n-   --> tests\/compile-fail\/non_integer_base\/all_defined.rs:115:1\n-    |\n-115 | \/ bitflags! {\n-116 | |     struct Flags128: MyInt {\n-117 | |         const A = MyInt(0b0000_0001u8);\n-118 | |         const B = MyInt(0b0000_0010u8);\n-119 | |         const C = MyInt(0b0000_0100u8);\n-120 | |     }\n-121 | | }\n-    | |_^ no implementation for `MyInt == _`\n-    |\n-    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n-note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests\/compile-fail\/non_integer_base\/all_defined.rs:115:1\n-    |\n-115 | \/ bitflags! {\n-116 | |     struct Flags128: MyInt {\n-117 | |         const A = MyInt(0b0000_0001u8);\n-118 | |         const B = MyInt(0b0000_0010u8);\n-119 | |         const C = MyInt(0b0000_0100u8);\n-120 | |     }\n-121 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: can't compare `MyInt` with `_` in const contexts\n-   --> tests\/compile-fail\/non_integer_base\/all_defined.rs:115:1\n-    |\n-115 | \/ bitflags! {\n-116 | |     struct Flags128: MyInt {\n-117 | |         const A = MyInt(0b0000_0001u8);\n-118 | |         const B = MyInt(0b0000_0010u8);\n-119 | |         const C = MyInt(0b0000_0100u8);\n-120 | |     }\n-121 | | }\n-    | |_^ no implementation for `MyInt == _`\n-    |\n-    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n-note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests\/compile-fail\/non_integer_base\/all_defined.rs:115:1\n-    |\n-115 | \/ bitflags! {\n-116 | |     struct Flags128: MyInt {\n-117 | |         const A = MyInt(0b0000_0001u8);\n-118 | |         const B = MyInt(0b0000_0010u8);\n-119 | |         const C = MyInt(0b0000_0100u8);\n-120 | |     }\n-121 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n-   --> tests\/compile-fail\/non_integer_base\/all_defined.rs:115:1\n-    |\n-115 | \/ bitflags! {\n-116 | |     struct Flags128: MyInt {\n-117 | |         const A = MyInt(0b0000_0001u8);\n-118 | |         const B = MyInt(0b0000_0010u8);\n-119 | |         const C = MyInt(0b0000_0100u8);\n-120 | |     }\n-121 | | }\n-    | |_^ the trait `Bits` is not implemented for `MyInt`\n-    |\n-    = help: the following other types implement trait `Bits`:\n-              i128\n-              i16\n-              i32\n-              i64\n-              i8\n-              u128\n-              u16\n-              u32\n-            and 2 others\n-    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n-   --> tests\/compile-fail\/non_integer_base\/all_defined.rs:115:1\n-    |\n-115 | \/ bitflags! {\n-116 | |     struct Flags128: MyInt {\n-117 | |         const A = MyInt(0b0000_0001u8);\n-118 | |         const B = MyInt(0b0000_0010u8);\n-119 | |         const C = MyInt(0b0000_0100u8);\n-120 | |     }\n-121 | | }\n-    | |_^ the trait `Bits` is not implemented for `MyInt`\n-    |\n-    = help: the following other types implement trait `Bits`:\n-              i128\n-              i16\n-              i32\n-              i64\n-              i8\n-              u128\n-              u16\n-              u32\n-            and 2 others\n-    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: can't compare `MyInt` with `_` in const contexts\n-   --> tests\/compile-fail\/non_integer_base\/all_defined.rs:115:1\n-    |\n-115 | \/ bitflags! {\n-116 | |     struct Flags128: MyInt {\n-117 | |         const A = MyInt(0b0000_0001u8);\n-118 | |         const B = MyInt(0b0000_0010u8);\n-119 | |         const C = MyInt(0b0000_0100u8);\n-120 | |     }\n-121 | | }\n-    | |_^ no implementation for `MyInt == _`\n-    |\n-    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n-note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests\/compile-fail\/non_integer_base\/all_defined.rs:115:1\n-    |\n-115 | \/ bitflags! {\n-116 | |     struct Flags128: MyInt {\n-117 | |         const A = MyInt(0b0000_0001u8);\n-118 | |         const B = MyInt(0b0000_0010u8);\n-119 | |         const C = MyInt(0b0000_0100u8);\n-120 | |     }\n-121 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: can't compare `MyInt` with `_` in const contexts\n-   --> tests\/compile-fail\/non_integer_base\/all_defined.rs:115:1\n-    |\n-115 | \/ bitflags! {\n-116 | |     struct Flags128: MyInt {\n-117 | |         const A = MyInt(0b0000_0001u8);\n-118 | |         const B = MyInt(0b0000_0010u8);\n-119 | |         const C = MyInt(0b0000_0100u8);\n-120 | |     }\n-121 | | }\n-    | |_^ no implementation for `MyInt == _`\n-    |\n-    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n-note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests\/compile-fail\/non_integer_base\/all_defined.rs:115:1\n-    |\n-115 | \/ bitflags! {\n-116 | |     struct Flags128: MyInt {\n-117 | |         const A = MyInt(0b0000_0001u8);\n-118 | |         const B = MyInt(0b0000_0010u8);\n-119 | |         const C = MyInt(0b0000_0100u8);\n-120 | |     }\n-121 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: can't compare `MyInt` with `_` in const contexts\n-   --> tests\/compile-fail\/non_integer_base\/all_defined.rs:115:1\n-    |\n-115 | \/ bitflags! {\n-116 | |     struct Flags128: MyInt {\n-117 | |         const A = MyInt(0b0000_0001u8);\n-118 | |         const B = MyInt(0b0000_0010u8);\n-119 | |         const C = MyInt(0b0000_0100u8);\n-120 | |     }\n-121 | | }\n-    | |_^ no implementation for `MyInt == _`\n-    |\n-    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n-note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests\/compile-fail\/non_integer_base\/all_defined.rs:115:1\n-    |\n-115 | \/ bitflags! {\n-116 | |     struct Flags128: MyInt {\n-117 | |         const A = MyInt(0b0000_0001u8);\n-118 | |         const B = MyInt(0b0000_0010u8);\n-119 | |         const C = MyInt(0b0000_0100u8);\n-120 | |     }\n-121 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: can't compare `MyInt` with `_` in const contexts\n-   --> tests\/compile-fail\/non_integer_base\/all_defined.rs:115:1\n-    |\n-115 | \/ bitflags! {\n-116 | |     struct Flags128: MyInt {\n-117 | |         const A = MyInt(0b0000_0001u8);\n-118 | |         const B = MyInt(0b0000_0010u8);\n-119 | |         const C = MyInt(0b0000_0100u8);\n-120 | |     }\n-121 | | }\n-    | |_^ no implementation for `MyInt == _`\n-    |\n-    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n-note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests\/compile-fail\/non_integer_base\/all_defined.rs:115:1\n-    |\n-115 | \/ bitflags! {\n-116 | |     struct Flags128: MyInt {\n-117 | |         const A = MyInt(0b0000_0001u8);\n-118 | |         const B = MyInt(0b0000_0010u8);\n-119 | |         const C = MyInt(0b0000_0100u8);\n-120 | |     }\n-121 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\ndiff --git a\/tests\/compile-fail\/non_integer_base\/all_missing.rs \/dev\/null\n--- a\/tests\/compile-fail\/non_integer_base\/all_missing.rs\n+++ \/dev\/null\n@@ -1,13 +0,0 @@\n-use bitflags::bitflags;\n-\n-struct MyInt(u8);\n-\n-bitflags! {\n-    struct Flags128: MyInt {\n-        const A = MyInt(0b0000_0001);\n-        const B = MyInt(0b0000_0010);\n-        const C = MyInt(0b0000_0100);\n-    }\n-}\n-\n-fn main() {}\ndiff --git a\/tests\/compile-fail\/non_integer_base\/all_missing.stderr \/dev\/null\n--- a\/tests\/compile-fail\/non_integer_base\/all_missing.stderr\n+++ \/dev\/null\n@@ -1,13 +0,0 @@\n-error[E0204]: the trait `Copy` may not be implemented for this type\n-  --> tests\/compile-fail\/non_integer_base\/all_missing.rs:5:1\n-   |\n-5  | \/ bitflags! {\n-6  | |     struct Flags128: MyInt {\n-7  | |         const A = MyInt(0b0000_0001);\n-8  | |         const B = MyInt(0b0000_0010);\n-9  | |         const C = MyInt(0b0000_0100);\n-10 | |     }\n-11 | | }\n-   | |_^ this field does not implement `Copy`\n-   |\n-   = note: this error originates in the derive macro `Copy` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\ndiff --git a\/tests\/compile-fail\/redefined.stderr \/dev\/null\n--- a\/tests\/compile-fail\/redefined.stderr\n+++ \/dev\/null\n@@ -1,17 +0,0 @@\n-error: no rules expected the token `{`\n- --> tests\/compile-fail\/redefined.rs:5:23\n-  |\n-5 |     pub struct Flags1 {\n-  |                       ^ no rules expected this token in macro call\n-\n-error: no rules expected the token `{`\n-  --> tests\/compile-fail\/redefined.rs:11:23\n-   |\n-11 |     pub struct Flags1 {\n-   |                       ^ no rules expected this token in macro call\n-\n-error[E0601]: `main` function not found in crate `$CRATE`\n-  --> tests\/compile-fail\/redefined.rs:14:2\n-   |\n-14 | }\n-   |  ^ consider adding a `main` function to `$DIR\/tests\/compile-fail\/redefined.rs`\ndiff --git a\/tests\/compile-fail\/syntax\/missing_type.stderr \/dev\/null\n--- a\/tests\/compile-fail\/syntax\/missing_type.stderr\n+++ \/dev\/null\n@@ -1,11 +0,0 @@\n-error: no rules expected the token `{`\n- --> tests\/compile-fail\/syntax\/missing_type.rs:5:23\n-  |\n-5 |     pub struct Flags1 {\n-  |                       ^ no rules expected this token in macro call\n-\n-error[E0601]: `main` function not found in crate `$CRATE`\n- --> tests\/compile-fail\/syntax\/missing_type.rs:8:2\n-  |\n-8 | }\n-  |  ^ consider adding a `main` function to `$DIR\/tests\/compile-fail\/syntax\/missing_type.rs`\ndiff --git a\/tests\/compile-fail\/syntax\/missing_value.stderr \/dev\/null\n--- a\/tests\/compile-fail\/syntax\/missing_value.stderr\n+++ \/dev\/null\n@@ -1,11 +0,0 @@\n-error: no rules expected the token `{`\n- --> tests\/compile-fail\/syntax\/missing_value.rs:5:23\n-  |\n-5 |     pub struct Flags1 {\n-  |                       ^ no rules expected this token in macro call\n-\n-error[E0601]: `main` function not found in crate `$CRATE`\n- --> tests\/compile-fail\/syntax\/missing_value.rs:8:2\n-  |\n-8 | }\n-  |  ^ consider adding a `main` function to `$DIR\/tests\/compile-fail\/syntax\/missing_value.rs`\ndiff --git a\/tests\/compile-fail\/trait\/custom_impl.rs \/dev\/null\n--- a\/tests\/compile-fail\/trait\/custom_impl.rs\n+++ \/dev\/null\n@@ -1,65 +0,0 @@\n-use bitflags::BitFlags;\n-\n-pub struct BootlegFlags(u32);\n-\n-impl BitFlags for BootlegFlags {\n-    type Bits = u32;\n-\n-    fn empty() -> Self {\n-        unimplemented!()\n-    }\n-\n-    fn all() -> Self {\n-        unimplemented!()\n-    }\n-\n-    fn bits(&self) -> u32 {\n-        unimplemented!()\n-    }\n-\n-    fn from_bits(_: u32) -> Option<BootlegFlags> {\n-        unimplemented!()\n-    }\n-\n-    fn from_bits_truncate(_: u32) -> BootlegFlags {\n-        unimplemented!()\n-    }\n-\n-    fn from_bits_retain(_: u32) -> BootlegFlags {\n-        unimplemented!()\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        unimplemented!()\n-    }\n-\n-    fn is_all(&self) -> bool {\n-        unimplemented!()\n-    }\n-\n-    fn intersects(&self, _: BootlegFlags) -> bool {\n-        unimplemented!()\n-    }\n-\n-    fn contains(&self, _: BootlegFlags) -> bool {\n-        unimplemented!()\n-    }\n-\n-    fn insert(&mut self, _: BootlegFlags) {\n-        unimplemented!()\n-    }\n-\n-    fn remove(&mut self, _: BootlegFlags) {\n-        unimplemented!()\n-    }\n-\n-    fn toggle(&mut self, _: BootlegFlags) {\n-        unimplemented!()\n-    }\n-\n-    fn set(&mut self, _: BootlegFlags, value: bool) {\n-        unimplemented!()\n-    }\n-}\n-\n-fn main() {}\ndiff --git a\/tests\/compile-fail\/trait\/custom_impl.stderr \/dev\/null\n--- a\/tests\/compile-fail\/trait\/custom_impl.stderr\n+++ \/dev\/null\n@@ -1,11 +0,0 @@\n-error[E0277]: the trait bound `BootlegFlags: ImplementedByBitFlagsMacro` is not satisfied\n- --> tests\/compile-fail\/trait\/custom_impl.rs:5:6\n-  |\n-5 | impl BitFlags for BootlegFlags {\n-  |      ^^^^^^^^ the trait `ImplementedByBitFlagsMacro` is not implemented for `BootlegFlags`\n-  |\n-note: required by a bound in `BitFlags`\n- --> src\/bitflags_trait.rs\n-  |\n-  | pub trait BitFlags: ImplementedByBitFlagsMacro {\n-  |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `BitFlags`\ndiff --git \/dev\/null b\/tests\/compile-pass\/bitflags_trait_bound_flags.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/tests\/compile-pass\/bitflags_trait_bound_flags.rs\n@@ -0,0 +1,19 @@\n+#![allow(deprecated)]\n+\n+use bitflags::{BitFlags, Flags};\n+\n+pub trait MyCustomFlagsTrait {\n+    fn uses_flags<B: BitFlags>(flags: B);\n+}\n+\n+pub struct MyCustomFlags;\n+\n+impl MyCustomFlagsTrait for MyCustomFlags {\n+    fn uses_flags<B: Flags>(_: B) {\n+\n+    }\n+}\n+\n+fn main() {\n+\n+}\ndiff --git a\/tests\/compile-pass\/trait\/generic_iter.rs b\/tests\/compile-pass\/bitflags_trait_generic_iter.rs\n--- a\/tests\/compile-pass\/trait\/generic_iter.rs\n+++ b\/tests\/compile-pass\/bitflags_trait_generic_iter.rs\n@@ -1,3 +1,5 @@\n+#![allow(deprecated)]\n+\n use bitflags::{bitflags, BitFlags};\n \n bitflags! {\ndiff --git a\/tests\/compile-pass\/trait\/precedence.rs b\/tests\/compile-pass\/bitflags_trait_precedence.rs\n--- a\/tests\/compile-pass\/trait\/precedence.rs\n+++ b\/tests\/compile-pass\/bitflags_trait_precedence.rs\n@@ -1,3 +1,5 @@\n+#![allow(deprecated)]\n+\n use bitflags::{bitflags, BitFlags};\n \n bitflags! {\ndiff --git \/dev\/null b\/tests\/compile-pass\/bitflags_trait_supertrait.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/tests\/compile-pass\/bitflags_trait_supertrait.rs\n@@ -0,0 +1,80 @@\n+#![allow(deprecated)]\n+\n+\/\/ From: https:\/\/github.com\/bitflags\/bitflags\/issues\/293#issuecomment-1493296383\n+use core::{\n+    fmt::{Binary, LowerHex, Octal, UpperHex},\n+    ops::{\n+        Add, AddAssign, BitAnd, BitAndAssign, BitOr, BitOrAssign, BitXor, BitXorAssign, Div, DivAssign,\n+        Mul, MulAssign, Not, Rem, RemAssign, Shl, ShlAssign, Shr, ShrAssign, Sub, SubAssign,\n+    }\n+};\n+\n+use bitflags::{bitflags, BitFlags};\n+\n+pub trait BitFlagsExt {\n+    fn complement_retain(self) -> Self;\n+    fn has_uncorresponding_bits(self) -> bool;\n+}\n+impl<T, U> BitFlagsExt for T\n+where\n+    T: BitFlags<Bits = U>\n+        + BitAnd<Output = T>\n+        + BitAndAssign\n+        + BitOr<Output = T>\n+        + BitOrAssign\n+        + BitXor<Output = T>\n+        + BitXorAssign\n+        + Not<Output = T>\n+        + Sub<Output = T>\n+        + SubAssign\n+        + Extend<T>\n+        + FromIterator<T>\n+        + IntoIterator\n+        + Binary\n+        + LowerHex\n+        + Octal\n+        + UpperHex,\n+    U: BitAnd<Output = U>\n+        + BitAndAssign\n+        + BitOr<Output = U>\n+        + BitOrAssign\n+        + BitXor<Output = U>\n+        + BitXorAssign\n+        + Not<Output = U>\n+        + Shl<Output = U>\n+        + ShlAssign\n+        + Shr<Output = U>\n+        + ShrAssign\n+        + Add<Output = U>\n+        + AddAssign\n+        + Div<Output = U>\n+        + DivAssign\n+        + Mul<Output = U>\n+        + MulAssign\n+        + Rem<Output = U>\n+        + RemAssign\n+        + Sub<Output = U>\n+        + SubAssign,\n+{\n+    fn complement_retain(self) -> Self {\n+        Self::from_bits_retain(!self.bits())\n+    }\n+\n+    fn has_uncorresponding_bits(self) -> bool {\n+        !(self & Self::all().complement_retain()).is_empty()\n+    }\n+}\n+\n+bitflags! {\n+    struct Flags: u32 {\n+        const A = 0b00000001;\n+    }\n+}\n+\n+fn has_uncorresponding_bits<B: BitFlagsExt>(flags: B) -> bool {\n+    flags.has_uncorresponding_bits()\n+}\n+\n+fn main() {\n+    has_uncorresponding_bits(Flags::A);\n+}\ndiff --git \/dev\/null b\/tests\/compile-pass\/bitflags_trait_to_flags.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/tests\/compile-pass\/bitflags_trait_to_flags.rs\n@@ -0,0 +1,31 @@\n+#![allow(deprecated)]\n+\n+use bitflags::{bitflags, Flags, BitFlags};\n+\n+fn uses_flags1<B: Flags>(f: B) -> usize {\n+    uses_bitflags2(f)\n+}\n+\n+fn uses_bitflags1<B: BitFlags>(f: B) -> usize {\n+    uses_flags2(f)\n+}\n+\n+fn uses_flags2<B: Flags>(f: B) -> usize {\n+    f.iter().count()\n+}\n+\n+fn uses_bitflags2<B: BitFlags>(f: B) -> usize {\n+    f.iter().count()\n+}\n+\n+bitflags! {\n+    pub struct MyFlags: u32 {\n+        const A = 0b00000001;\n+        const B = 0b00000010;\n+        const C = 0b00000100;\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(uses_flags1(MyFlags::A | MyFlags::B), uses_bitflags1(MyFlags::A | MyFlags::B));\n+}\ndiff --git \/dev\/null b\/tests\/compile-pass\/flags_trait_bound_bitflags.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/tests\/compile-pass\/flags_trait_bound_bitflags.rs\n@@ -0,0 +1,19 @@\n+#![allow(deprecated)]\n+\n+use bitflags::{BitFlags, Flags};\n+\n+pub trait MyCustomFlagsTrait {\n+    fn uses_flags<B: Flags>(flags: B);\n+}\n+\n+pub struct MyCustomFlags;\n+\n+impl MyCustomFlagsTrait for MyCustomFlags {\n+    fn uses_flags<B: BitFlags>(_: B) {\n+\n+    }\n+}\n+\n+fn main() {\n+\n+}\ndiff --git \/dev\/null b\/tests\/compile-pass\/flags_trait_generic_iter.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/tests\/compile-pass\/flags_trait_generic_iter.rs\n@@ -0,0 +1,16 @@\n+use bitflags::{bitflags, Flags};\n+\n+bitflags! {\n+    struct MyFlags: u32 {\n+        const A = 0b00000001;\n+        const B = 0b00000010;\n+    }\n+}\n+\n+fn count_flags<F: Flags>(flags: &F) -> usize {\n+    flags.iter().count()\n+}\n+\n+fn main() {\n+    assert_eq!(2, count_flags(&(MyFlags::A | MyFlags::B)));\n+}\ndiff --git \/dev\/null b\/tests\/compile-pass\/flags_trait_precedence.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/tests\/compile-pass\/flags_trait_precedence.rs\n@@ -0,0 +1,16 @@\n+use bitflags::{bitflags, Flags};\n+\n+bitflags! {\n+    struct MyFlags: u32 {\n+        const A = 0b00000001;\n+    }\n+}\n+\n+fn all_from_trait<F: Flags>() {\n+    let _ = F::all();\n+}\n+\n+fn main() {\n+    all_from_trait::<MyFlags>();\n+    let _ = MyFlags::all();\n+}\ndiff --git \/dev\/null b\/tests\/compile-pass\/flags_trait_supertrait.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/tests\/compile-pass\/flags_trait_supertrait.rs\n@@ -0,0 +1,80 @@\n+#![allow(deprecated)]\n+\n+\/\/ From: https:\/\/github.com\/bitflags\/bitflags\/issues\/293#issuecomment-1493296383\n+use core::{\n+    fmt::{Binary, LowerHex, Octal, UpperHex},\n+    ops::{\n+        Add, AddAssign, BitAnd, BitAndAssign, BitOr, BitOrAssign, BitXor, BitXorAssign, Div, DivAssign,\n+        Mul, MulAssign, Not, Rem, RemAssign, Shl, ShlAssign, Shr, ShrAssign, Sub, SubAssign,\n+    }\n+};\n+\n+use bitflags::{bitflags, Flags};\n+\n+pub trait FlagsExt {\n+    fn complement_retain(self) -> Self;\n+    fn has_uncorresponding_bits(self) -> bool;\n+}\n+impl<T, U> FlagsExt for T\n+where\n+    T: Flags<Bits = U>\n+        + BitAnd<Output = T>\n+        + BitAndAssign\n+        + BitOr<Output = T>\n+        + BitOrAssign\n+        + BitXor<Output = T>\n+        + BitXorAssign\n+        + Not<Output = T>\n+        + Sub<Output = T>\n+        + SubAssign\n+        + Extend<T>\n+        + FromIterator<T>\n+        + IntoIterator\n+        + Binary\n+        + LowerHex\n+        + Octal\n+        + UpperHex,\n+    U: BitAnd<Output = U>\n+        + BitAndAssign\n+        + BitOr<Output = U>\n+        + BitOrAssign\n+        + BitXor<Output = U>\n+        + BitXorAssign\n+        + Not<Output = U>\n+        + Shl<Output = U>\n+        + ShlAssign\n+        + Shr<Output = U>\n+        + ShrAssign\n+        + Add<Output = U>\n+        + AddAssign\n+        + Div<Output = U>\n+        + DivAssign\n+        + Mul<Output = U>\n+        + MulAssign\n+        + Rem<Output = U>\n+        + RemAssign\n+        + Sub<Output = U>\n+        + SubAssign,\n+{\n+    fn complement_retain(self) -> Self {\n+        Self::from_bits_retain(!self.bits())\n+    }\n+\n+    fn has_uncorresponding_bits(self) -> bool {\n+        !(self & Self::all().complement_retain()).is_empty()\n+    }\n+}\n+\n+bitflags! {\n+    struct MyFlags: u32 {\n+        const A = 0b00000001;\n+    }\n+}\n+\n+fn has_uncorresponding_bits<B: FlagsExt>(flags: B) -> bool {\n+    flags.has_uncorresponding_bits()\n+}\n+\n+fn main() {\n+    has_uncorresponding_bits(MyFlags::A);\n+}\ndiff --git a\/tests\/compile-pass\/visibility\/bits_field.rs \/dev\/null\n--- a\/tests\/compile-pass\/visibility\/bits_field.rs\n+++ \/dev\/null\n@@ -1,11 +0,0 @@\n-use bitflags::bitflags;\n-\n-bitflags! {\n-    pub struct Flags1: u32 {\n-        const FLAG_A = 0b00000001;\n-    }\n-}\n-\n-fn main() {\n-    assert_eq!(0b00000001, Flags1::FLAG_A.bits());\n-}\ndiff --git a\/tests\/smoke-test\/Cargo.toml b\/tests\/smoke-test\/Cargo.toml\n--- a\/tests\/smoke-test\/Cargo.toml\n+++ b\/tests\/smoke-test\/Cargo.toml\n@@ -6,3 +6,4 @@ publish = false\n \n [dependencies.bitflags]\n path = \"..\/..\/\"\n+all-features = true\n","hints_text":"As for `Bits`, it can be reasonably reduced to:\r\n\r\n```rust\r\npub trait Bits:\r\n    Clone\r\n    + Copy\r\n    + BitAnd<Output = Self>\r\n    + BitOr<Output = Self>\r\n    + BitXor<Output = Self>\r\n    + Not<Output = Self>\r\n    + PartialEq\r\n    + Sized\r\n    + 'static\r\n{\r\n    \/\/\/ The value of `Self` where no bits are set.\r\n    const EMPTY: Self;\r\n\r\n    \/\/\/ The value of `Self` where all bits are set.\r\n    const ALL: Self;\r\n}\r\n```\r\n\r\nThe `Copy` and `'static` bounds are pretty limiting, but doesn't rule out _some_ more exotic backing storage like `[bool; N]`.\nThe main thing you don't get from just the `BitFlags` macro right now, and what stops us being able to immediately replace a lot of generated code with it, is the const definitions, and const versions of those trait functions. We could consider a few utility macros that we transition `bitflags!` to, that will define costs and impl operators for you:\r\n\r\n```rust\r\nimpl_consts! {\r\n    MyFlags: u32 {\r\n        const A = 0b0000_0001;\r\n        const B = 0b0000_0010;\r\n        const C = 0b0000_0100;\r\n    }\r\n}\r\n```\r\n\r\nwould generate:\r\n\r\n```rust\r\nimpl MyFlags {\r\n    const FLAGS: &'static [(&'static str, Self::Bits)] = &[\r\n        (\"A\", 0b0000_0001),\r\n        (\"B\", 0b0000_0010),\r\n        (\"C\", 0b0000_0100),\r\n    ];\r\n\r\n    pub const A: Self = Self::from_bits_retain(0b0000_0001);\r\n    pub const B: Self = Self::from_bits_retain(0b0000_0010);\r\n    pub const C: Self = Self::from_bits_retain(0b0000_0100);\r\n}\r\n```\r\n\r\nyou could then use `Self::FLAGS` as the basis for the const in the `BitFlags` trait, so there's still only a single definition of what those flags are.\nSome other open design questions are:\r\n\r\n1. Should we use slices like `&[(&str, T)]`, or some wrapper type, like `Flags` that also implements indexing.\r\n2. Should we use tuples like `(&str, T)`, or some flags type like `Flag`. Having a separate type would let us add metadata in the future, such as whether or not the flag is a composite of other flags.\r\n\r\nI'm happy with `&[(&str, T)]`, but open to trying a more encapsulated API if it doesn't affect ergonomics or create too many extra types. It's certainly more future proof.","base_commit":"1d8388bf4ce18afde846d220ad8b6e0dc40aae94","issue_numbers":["348"],"created_at":"2023-05-04T06:16:51Z","pull_number":351,"instance_id":"bitflags__bitflags-351","patch":"diff --git \/dev\/null b\/examples\/custom_bits_type.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/examples\/custom_bits_type.rs\n@@ -0,0 +1,85 @@\n+use std::ops::{BitAnd, BitOr, BitXor, Not};\n+\n+use bitflags::{Flags, Flag, Bits};\n+\n+\/\/ Define a custom container that can be used in flags types\n+\/\/ Note custom bits types can't be used in `bitflags!`\n+\/\/ without making the trait impls `const`. This is currently\n+\/\/ unstable\n+#[derive(Clone, Copy, Debug)]\n+pub struct CustomBits([bool; 3]);\n+\n+impl Bits for CustomBits {\n+    const EMPTY: Self = CustomBits([false; 3]);\n+\n+    const ALL: Self = CustomBits([true; 3]);\n+}\n+\n+impl PartialEq for CustomBits {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.0 == other.0\n+    }\n+}\n+\n+impl BitAnd for CustomBits {\n+    type Output = Self;\n+\n+    fn bitand(self, other: Self) -> Self {\n+        CustomBits([self.0[0] & other.0[0], self.0[1] & other.0[1], self.0[2] & other.0[2]])\n+    }\n+}\n+\n+impl BitOr for CustomBits {\n+    type Output = Self;\n+\n+    fn bitor(self, other: Self) -> Self {\n+        CustomBits([self.0[0] | other.0[0], self.0[1] | other.0[1], self.0[2] | other.0[2]])\n+    }\n+}\n+\n+impl BitXor for CustomBits {\n+    type Output = Self;\n+\n+    fn bitxor(self, other: Self) -> Self {\n+        CustomBits([self.0[0] & other.0[0], self.0[1] & other.0[1], self.0[2] & other.0[2]])\n+    }\n+}\n+\n+impl Not for CustomBits {\n+    type Output = Self;\n+\n+    fn not(self) -> Self {\n+        CustomBits([!self.0[0], !self.0[1], !self.0[2]])\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug)]\n+pub struct CustomFlags(CustomBits);\n+\n+impl CustomFlags {\n+    pub const A: Self = CustomFlags(CustomBits([true, false, false]));\n+    pub const B: Self = CustomFlags(CustomBits([false, true, false]));\n+    pub const C: Self = CustomFlags(CustomBits([false, false, true]));\n+}\n+\n+impl Flags for CustomFlags {\n+    const FLAGS: &'static [Flag<Self>] = &[\n+        Flag::new(\"A\", Self::A),\n+        Flag::new(\"B\", Self::B),\n+        Flag::new(\"C\", Self::C),\n+    ];\n+\n+    type Bits = CustomBits;\n+\n+    fn bits(&self) -> Self::Bits {\n+        self.0\n+    }\n+\n+    fn from_bits_retain(bits: Self::Bits) -> Self {\n+        CustomFlags(bits)\n+    }\n+}\n+\n+fn main() {\n+    println!(\"{:?}\", CustomFlags::A.union(CustomFlags::C));\n+}\ndiff --git \/dev\/null b\/examples\/custom_derive.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/examples\/custom_derive.rs\n@@ -0,0 +1,23 @@\n+\/\/! An example of implementing the `BitFlags` trait manually for a flags type.\n+\n+use std::str;\n+\n+use bitflags::bitflags;\n+\n+\/\/ Define a flags type outside of the `bitflags` macro as a newtype\n+\/\/ It can accept custom derives for libaries `bitflags` doesn't support natively\n+#[derive(zerocopy::AsBytes, zerocopy::FromBytes)]\n+#[repr(transparent)]\n+pub struct ManualFlags(u32);\n+\n+\/\/ Next: use `impl Flags` instead of `struct Flags`\n+bitflags! {\n+    impl ManualFlags: u32 {\n+        const A = 0b00000001;\n+        const B = 0b00000010;\n+        const C = 0b00000100;\n+        const ABC = Self::A.bits() | Self::B.bits() | Self::C.bits();\n+    }\n+}\n+\n+fn main() {}\ndiff --git a\/examples\/fmt.rs b\/examples\/fmt.rs\n--- a\/examples\/fmt.rs\n+++ b\/examples\/fmt.rs\n@@ -2,40 +2,40 @@\n \n use core::{fmt, str};\n \n-fn main() -> Result<(), bitflags::parser::ParseError> {\n-    bitflags::bitflags! {\n-        \/\/ You can `#[derive]` the `Debug` trait, but implementing it manually\n-        \/\/ can produce output like `A | B` instead of `Flags(A | B)`.\n-        \/\/ #[derive(Debug)]\n-        #[derive(PartialEq, Eq)]\n-        pub struct Flags: u32 {\n-            const A = 1;\n-            const B = 2;\n-            const C = 4;\n-            const D = 8;\n-        }\n+bitflags::bitflags! {\n+    \/\/ You can `#[derive]` the `Debug` trait, but implementing it manually\n+    \/\/ can produce output like `A | B` instead of `Flags(A | B)`.\n+    \/\/ #[derive(Debug)]\n+    #[derive(PartialEq, Eq)]\n+    pub struct Flags: u32 {\n+        const A = 1;\n+        const B = 2;\n+        const C = 4;\n+        const D = 8;\n     }\n+}\n \n-    impl fmt::Debug for Flags {\n-        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-            fmt::Debug::fmt(&self.0, f)\n-        }\n+impl fmt::Debug for Flags {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        bitflags::parser::to_writer(self, f)\n     }\n+}\n \n-    impl fmt::Display for Flags {\n-        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-            fmt::Display::fmt(&self.0, f)\n-        }\n+impl fmt::Display for Flags {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        bitflags::parser::to_writer(self, f)\n     }\n+}\n \n-    impl str::FromStr for Flags {\n-        type Err = bitflags::parser::ParseError;\n+impl str::FromStr for Flags {\n+    type Err = bitflags::parser::ParseError;\n \n-        fn from_str(flags: &str) -> Result<Self, Self::Err> {\n-            Ok(Self(flags.parse()?))\n-        }\n+    fn from_str(flags: &str) -> Result<Self, Self::Err> {\n+        bitflags::parser::from_str(flags)\n     }\n+}\n \n+fn main() -> Result<(), bitflags::parser::ParseError> {\n     let flags = Flags::A | Flags::B;\n \n     println!(\"{}\", flags);\ndiff --git \/dev\/null b\/examples\/macro_free.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/examples\/macro_free.rs\n@@ -0,0 +1,58 @@\n+\/\/! An example of implementing the `BitFlags` trait manually for a flags type.\n+\/\/!\n+\/\/! This example doesn't use any macros.\n+\n+use std::{fmt, str};\n+\n+use bitflags::{Flags, Flag};\n+\n+\/\/ First: Define your flags type. It just needs to be `Sized + 'static`.\n+pub struct ManualFlags(u32);\n+\n+\/\/ Not required: Define some constants for valid flags\n+impl ManualFlags {\n+    pub const A: ManualFlags = ManualFlags(0b00000001);\n+    pub const B: ManualFlags = ManualFlags(0b00000010);\n+    pub const C: ManualFlags = ManualFlags(0b00000100);\n+    pub const ABC: ManualFlags = ManualFlags(0b00000111);\n+}\n+\n+\/\/ Next: Implement the `BitFlags` trait, specifying your set of valid flags\n+\/\/ and iterators\n+impl Flags for ManualFlags {\n+    const FLAGS: &'static [Flag<Self>] = &[\n+        Flag::new(\"A\", Self::A),\n+        Flag::new(\"B\", Self::B),\n+        Flag::new(\"C\", Self::C),\n+    ];\n+\n+    type Bits = u32;\n+\n+    fn bits(&self) -> u32 {\n+        self.0\n+    }\n+\n+    fn from_bits_retain(bits: u32) -> Self {\n+        Self(bits)\n+    }\n+}\n+\n+\/\/ Not required: Add parsing support\n+impl str::FromStr for ManualFlags {\n+    type Err = bitflags::parser::ParseError;\n+\n+    fn from_str(input: &str) -> Result<Self, Self::Err> {\n+        bitflags::parser::from_str(input)\n+    }\n+}\n+\n+\/\/ Not required: Add formatting support\n+impl fmt::Display for ManualFlags {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        bitflags::parser::to_writer(self, f)\n+    }\n+}\n+\n+fn main() {\n+    println!(\"{}\", ManualFlags::A.union(ManualFlags::B).union(ManualFlags::C));\n+}\ndiff --git a\/src\/example_generated.rs b\/src\/example_generated.rs\n--- a\/src\/example_generated.rs\n+++ b\/src\/example_generated.rs\n@@ -9,30 +9,41 @@ __declare_public_bitflags! {\n     \/\/\/ This is the same `Flags` struct defined in the [crate level example](..\/index.html#example).\n     \/\/\/ Note that this struct is just for documentation purposes only, it must not be used outside\n     \/\/\/ this crate.\n-    pub struct Flags;\n+    pub struct Flags\n }\n \n __declare_internal_bitflags! {\n-    pub struct Field0: u32;\n-    pub struct Iter;\n-    pub struct IterRaw;\n+    pub struct Field0: u32\n }\n \n __impl_internal_bitflags! {\n-    Field0: u32, Flags, Iter, IterRaw {\n-        A;\n-        B;\n-        C;\n-        ABC;\n+    Field0: u32, Flags {\n+        \/\/ Field `A`.\n+        \/\/\/\n+        \/\/\/ This flag has the value `0b00000001`.\n+        A = 0b00000001;\n+        \/\/\/ Field `B`.\n+        \/\/\/\n+        \/\/\/ This flag has the value `0b00000010`.\n+        B = 0b00000010;\n+        \/\/\/ Field `C`.\n+        \/\/\/\n+        \/\/\/ This flag has the value `0b00000100`.\n+        C = 0b00000100;\n+        ABC = Self::A.bits() | Self::B.bits() | Self::C.bits();\n     }\n }\n \n-__impl_public_bitflags! {\n-    Flags: u32, Field0, Iter, IterRaw;\n+__impl_public_bitflags_forward! {\n+    Flags: u32, Field0\n+}\n+\n+__impl_public_bitflags_iter! {\n+    Flags\n }\n \n __impl_public_bitflags_consts! {\n-    Flags {\n+    Flags: u32 {\n         \/\/\/ Field `A`.\n         \/\/\/\n         \/\/\/ This flag has the value `0b00000001`.\ndiff --git a\/src\/external.rs b\/src\/external.rs\n--- a\/src\/external.rs\n+++ b\/src\/external.rs\n@@ -5,7 +5,13 @@ How do I support a new external library?\n \n Let's say we want to add support for `my_library`.\n \n-First, we define a macro like so:\n+First, we create a module under `external`, like `serde` with any specialized code.\n+Ideally, any utilities in here should just work off the `Flags` trait and maybe a\n+few other assumed bounds.\n+\n+Next, re-export the library from the `__private` module here.\n+\n+Next, define a macro like so:\n \n ```rust\n #[macro_export(local_inner_macros)]\ndiff --git a\/src\/external.rs b\/src\/external.rs\n--- a\/src\/external.rs\n+++ b\/src\/external.rs\n@@ -57,27 +63,78 @@ __impl_external_bitflags_my_library! {\n     }\n }\n ```\n+*\/\n \n-What about libraries that _must_ be supported through `#[derive]`?\n+pub(crate) mod __private {\n+    #[cfg(feature = \"serde\")]\n+    pub use serde;\n \n-In these cases, the attributes will need to be added to the `__declare_internal_bitflags` macro when\n-the internal type is declared.\n-*\/\n+    #[cfg(feature = \"arbitrary\")]\n+    pub use arbitrary;\n+\n+    #[cfg(feature = \"bytemuck\")]\n+    pub use bytemuck;\n+}\n \n #[cfg(feature = \"serde\")]\n-pub mod serde_support;\n+pub mod serde;\n+\n+\/\/\/ Implement `Serialize` and `Deserialize` for the internal bitflags type.\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n #[cfg(feature = \"serde\")]\n-pub use serde;\n+macro_rules! __impl_external_bitflags_serde {\n+    (\n+        $InternalBitFlags:ident: $T:ty {\n+            $(\n+                $(#[$attr:ident $($args:tt)*])*\n+                $Flag:ident;\n+                )*\n+        }\n+    ) => {\n+        impl $crate::__private::serde::Serialize for $InternalBitFlags {\n+            fn serialize<S: $crate::__private::serde::Serializer>(\n+                &self,\n+                serializer: S,\n+            ) -> $crate::__private::core::result::Result<S::Ok, S::Error> {\n+                $crate::serde::serialize(\n+                    self,\n+                    serializer,\n+                )\n+            }\n+        }\n+\n+        impl<'de> $crate::__private::serde::Deserialize<'de> for $InternalBitFlags {\n+            fn deserialize<D: $crate::__private::serde::Deserializer<'de>>(\n+                deserializer: D,\n+            ) -> $crate::__private::core::result::Result<Self, D::Error> {\n+                $crate::serde::deserialize(\n+                    deserializer,\n+                )\n+            }\n+        }\n+    };\n+}\n+\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+#[cfg(not(feature = \"serde\"))]\n+macro_rules! __impl_external_bitflags_serde {\n+    (\n+        $InternalBitFlags:ident: $T:ty {\n+            $(\n+                $(#[$attr:ident $($args:tt)*])*\n+                $Flag:ident;\n+                )*\n+        }\n+    ) => {};\n+}\n \n #[cfg(feature = \"arbitrary\")]\n-pub mod arbitrary_support;\n-#[cfg(feature = \"arbitrary\")]\n-pub use arbitrary;\n+pub mod arbitrary;\n \n #[cfg(feature = \"bytemuck\")]\n-pub mod bytemuck_support;\n-#[cfg(feature = \"bytemuck\")]\n-pub use bytemuck;\n+mod bytemuck;\n \n \/\/\/ Implements traits from external libraries for the internal bitflags type.\n #[macro_export(local_inner_macros)]\ndiff --git a\/src\/external.rs b\/src\/external.rs\n--- a\/src\/external.rs\n+++ b\/src\/external.rs\n@@ -124,57 +181,6 @@ macro_rules! __impl_external_bitflags {\n     };\n }\n \n-\/\/\/ Implement `Serialize` and `Deserialize` for the internal bitflags type.\n-#[macro_export(local_inner_macros)]\n-#[doc(hidden)]\n-#[cfg(feature = \"serde\")]\n-macro_rules! __impl_external_bitflags_serde {\n-    (\n-        $InternalBitFlags:ident: $T:ty {\n-            $(\n-                $(#[$attr:ident $($args:tt)*])*\n-                $Flag:ident;\n-            )*\n-        }\n-    ) => {\n-        impl $crate::__private::serde::Serialize for $InternalBitFlags {\n-            fn serialize<S: $crate::__private::serde::Serializer>(\n-                &self,\n-                serializer: S,\n-            ) -> $crate::__private::core::result::Result<S::Ok, S::Error> {\n-                $crate::__private::serde_support::serialize_bits_default::<$InternalBitFlags, $T, S>(\n-                    &self,\n-                    serializer,\n-                )\n-            }\n-        }\n-\n-        impl<'de> $crate::__private::serde::Deserialize<'de> for $InternalBitFlags {\n-            fn deserialize<D: $crate::__private::serde::Deserializer<'de>>(\n-                deserializer: D,\n-            ) -> $crate::__private::core::result::Result<Self, D::Error> {\n-                $crate::__private::serde_support::deserialize_bits_default::<$InternalBitFlags, $T, D>(\n-                    deserializer,\n-                )\n-            }\n-        }\n-    };\n-}\n-\n-#[macro_export(local_inner_macros)]\n-#[doc(hidden)]\n-#[cfg(not(feature = \"serde\"))]\n-macro_rules! __impl_external_bitflags_serde {\n-    (\n-        $InternalBitFlags:ident: $T:ty {\n-            $(\n-                $(#[$attr:ident $($args:tt)*])*\n-                $Flag:ident;\n-            )*\n-        }\n-    ) => {};\n-}\n-\n \/\/\/ Implement `Arbitrary` for the internal bitflags type.\n #[macro_export(local_inner_macros)]\n #[doc(hidden)]\ndiff --git a\/src\/external.rs b\/src\/external.rs\n--- a\/src\/external.rs\n+++ b\/src\/external.rs\n@@ -192,7 +198,7 @@ macro_rules! __impl_external_bitflags_arbitrary {\n             fn arbitrary(\n                 u: &mut $crate::__private::arbitrary::Unstructured<'a>,\n             ) -> $crate::__private::arbitrary::Result<Self> {\n-                Self::from_bits(u.arbitrary()?).ok_or_else(|| $crate::__private::arbitrary::Error::IncorrectFormat)\n+                $crate::arbitrary::arbitrary(u)\n             }\n         }\n     };\ndiff --git a\/src\/external\/serde_support.rs b\/src\/external\/serde.rs\n--- a\/src\/external\/serde_support.rs\n+++ b\/src\/external\/serde.rs\n@@ -1,59 +1,66 @@\n+\/\/! Specialized serialization for flags types using `serde`.\n+\n use core::{fmt, str};\n+use crate::{Flags, parser::{self, ParseHex, WriteHex}};\n use serde::{\n     de::{Error, Visitor},\n     Deserialize, Deserializer, Serialize, Serializer,\n };\n \n-pub fn serialize_bits_default<T: fmt::Display + AsRef<B>, B: Serialize, S: Serializer>(\n-    flags: &T,\n+\/\/\/ Serialize a set of flags as a human-readable string or their underlying bits.\n+pub fn serialize<B: Flags, S: Serializer>(\n+    flags: &B,\n     serializer: S,\n-) -> Result<S::Ok, S::Error> {\n+) -> Result<S::Ok, S::Error>\n+where\n+    B::Bits: WriteHex + Serialize,\n+{\n     \/\/ Serialize human-readable flags as a string like `\"A | B\"`\n     if serializer.is_human_readable() {\n-        serializer.collect_str(flags)\n+        serializer.collect_str(&parser::AsDisplay(flags))\n     }\n     \/\/ Serialize non-human-readable flags directly as the underlying bits\n     else {\n-        flags.as_ref().serialize(serializer)\n+        flags.bits().serialize(serializer)\n     }\n }\n \n-pub fn deserialize_bits_default<\n+\/\/\/ Deserialize a set of flags from a human-readable string or their underlying bits.\n+pub fn deserialize<\n     'de,\n-    T: str::FromStr + From<B>,\n-    B: Deserialize<'de>,\n+    B: Flags,\n     D: Deserializer<'de>,\n >(\n     deserializer: D,\n-) -> Result<T, D::Error>\n+) -> Result<B, D::Error>\n where\n-    <T as str::FromStr>::Err: fmt::Display,\n+    B::Bits: ParseHex + Deserialize<'de>,\n {\n     if deserializer.is_human_readable() {\n         \/\/ Deserialize human-readable flags by parsing them from strings like `\"A | B\"`\n-        struct FlagsVisitor<T>(core::marker::PhantomData<T>);\n+        struct FlagsVisitor<B>(core::marker::PhantomData<B>);\n \n-        impl<'de, T: str::FromStr> Visitor<'de> for FlagsVisitor<T>\n+        impl<'de, B: Flags> Visitor<'de> for FlagsVisitor<B>\n         where\n-            <T as str::FromStr>::Err: fmt::Display,\n+            B::Bits: ParseHex,\n         {\n-            type Value = T;\n+            type Value = B;\n \n             fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n                 formatter.write_str(\"a string value of `|` separated flags\")\n             }\n \n             fn visit_str<E: Error>(self, flags: &str) -> Result<Self::Value, E> {\n-                flags.parse().map_err(|e| E::custom(e))\n+                parser::from_str(flags).map_err(|e| E::custom(e))\n             }\n         }\n \n         deserializer.deserialize_str(FlagsVisitor(Default::default()))\n     } else {\n         \/\/ Deserialize non-human-readable flags directly from the underlying bits\n-        let bits = B::deserialize(deserializer)?;\n+        let bits = B::Bits::deserialize(deserializer)?;\n \n-        Ok(bits.into())\n+        Ok(B::from_bits_retain(bits))\n     }\n }\n \ndiff --git a\/src\/internal.rs b\/src\/internal.rs\n--- a\/src\/internal.rs\n+++ b\/src\/internal.rs\n@@ -10,29 +10,14 @@\n #[doc(hidden)]\n macro_rules! __declare_internal_bitflags {\n     (\n-        $vis:vis struct $InternalBitFlags:ident: $T:ty;\n-        $iter_vis:vis struct $Iter:ident;\n-        $iter_names_vis:vis struct $IterNames:ident;\n+        $vis:vis struct $InternalBitFlags:ident: $T:ty\n     ) => {\n         \/\/ NOTE: The ABI of this type is _guaranteed_ to be the same as `T`\n         \/\/ This is relied on by some external libraries like `bytemuck` to make\n         \/\/ its `unsafe` trait impls sound.\n         #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n         #[repr(transparent)]\n-        $vis struct $InternalBitFlags {\n-            bits: $T,\n-        }\n-\n-        $iter_vis struct $Iter {\n-            inner: $IterNames,\n-            done: bool,\n-        }\n-\n-        $iter_names_vis struct $IterNames {\n-            idx: usize,\n-            source: $InternalBitFlags,\n-            state: $InternalBitFlags,\n-        }\n+        $vis struct $InternalBitFlags($T);\n     };\n }\n \ndiff --git a\/src\/internal.rs b\/src\/internal.rs\n--- a\/src\/internal.rs\n+++ b\/src\/internal.rs\n@@ -44,14 +29,18 @@ macro_rules! __declare_internal_bitflags {\n #[doc(hidden)]\n macro_rules! __impl_internal_bitflags {\n     (\n-        $InternalBitFlags:ident: $T:ty, $BitFlags:ident, $Iter:ident, $IterNames:ident {\n+        $InternalBitFlags:ident: $T:ty, $PublicBitFlags:ident {\n             $(\n                 $(#[$attr:ident $($args:tt)*])*\n-                $Flag:ident;\n+                $Flag:ident = $value:expr;\n             )*\n         }\n     ) => {\n-        impl $crate::__private::PublicFlags for $BitFlags {\n+        \/\/ NOTE: This impl is also used to prevent using bits types from non-primitive types\n+        \/\/ in the `bitflags` macro. If this approach is changed, this guard will need to be\n+        \/\/ retained somehow\n+        impl $crate::__private::PublicFlags for $PublicBitFlags {\n+            type Primitive = $T;\n             type Internal = $InternalBitFlags;\n         }\n \ndiff --git a\/src\/internal.rs b\/src\/internal.rs\n--- a\/src\/internal.rs\n+++ b\/src\/internal.rs\n@@ -73,7 +62,7 @@ macro_rules! __impl_internal_bitflags {\n                     \/\/ We can remove this `0x0` and remain compatible with `FromStr`,\n                     \/\/ because an empty string will still parse to an empty set of flags,\n                     \/\/ just like `0x0` does.\n-                    $crate::__private::core::write!(f, \"{:#x}\", <$T as $crate::__private::Bits>::EMPTY)\n+                    $crate::__private::core::write!(f, \"{:#x}\", <$T as $crate::Bits>::EMPTY)\n                 } else {\n                     $crate::__private::core::fmt::Display::fmt(self, f)\n                 }\ndiff --git a\/src\/internal.rs b\/src\/internal.rs\n--- a\/src\/internal.rs\n+++ b\/src\/internal.rs\n@@ -82,489 +71,74 @@ macro_rules! __impl_internal_bitflags {\n \n         impl $crate::__private::core::fmt::Display for $InternalBitFlags {\n             fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter<'_>) -> $crate::__private::core::fmt::Result {\n-                \/\/ A formatter for bitflags that produces text output like:\n-                \/\/\n-                \/\/ A | B | 0xf6\n-                \/\/\n-                \/\/ The names of set flags are written in a bar-separated-format,\n-                \/\/ followed by a hex number of any remaining bits that are set\n-                \/\/ but don't correspond to any flags.\n-\n-                \/\/ Iterate over the valid flags\n-                let mut first = true;\n-                let mut iter = self.iter_names();\n-                for (name, _) in &mut iter {\n-                    if !first {\n-                        f.write_str(\" | \")?;\n-                    }\n-\n-                    first = false;\n-                    f.write_str(name)?;\n-                }\n-\n-                \/\/ Append any extra bits that correspond to flags to the end of the format\n-                let extra_bits = iter.state.bits();\n-                if extra_bits != <$T as $crate::__private::Bits>::EMPTY {\n-                    if !first {\n-                        f.write_str(\" | \")?;\n-                    }\n-\n-                    $crate::__private::core::write!(f, \"{:#x}\", extra_bits)?;\n-                }\n-\n-                $crate::__private::core::fmt::Result::Ok(())\n+                $crate::parser::to_writer(&$PublicBitFlags(*self), f)\n             }\n         }\n \n-        \/\/ The impl for `FromStr` should parse anything produced by `Display`\n         impl $crate::__private::core::str::FromStr for $InternalBitFlags {\n             type Err = $crate::parser::ParseError;\n \n             fn from_str(s: &str) -> $crate::__private::core::result::Result<Self, Self::Err> {\n-                let s = s.trim();\n-\n-                let mut parsed_flags = Self::empty();\n-\n-                \/\/ If the input is empty then return an empty set of flags\n-                if s.is_empty() {\n-                    return $crate::__private::core::result::Result::Ok(parsed_flags);\n-                }\n-\n-                for flag in s.split('|') {\n-                    let flag = flag.trim();\n-\n-                    \/\/ If the flag is empty then we've got missing input\n-                    if flag.is_empty() {\n-                        return $crate::__private::core::result::Result::Err($crate::parser::ParseError::empty_flag());\n-                    }\n-\n-                    \/\/ If the flag starts with `0x` then it's a hex number\n-                    \/\/ Parse it directly to the underlying bits type\n-                    let parsed_flag = if let $crate::__private::core::option::Option::Some(flag) = flag.strip_prefix(\"0x\") {\n-                        let bits = <$T>::from_str_radix(flag, 16).map_err(|_| $crate::parser::ParseError::invalid_hex_flag(flag))?;\n-\n-                        Self::from_bits_retain(bits)\n-                    }\n-                    \/\/ Otherwise the flag is a name\n-                    \/\/ The generated flags type will determine whether\n-                    \/\/ or not it's a valid identifier\n-                    else {\n-                        Self::from_name(flag).ok_or_else(|| $crate::parser::ParseError::invalid_named_flag(flag))?\n-                    };\n-\n-                    parsed_flags.insert(parsed_flag);\n-                }\n-\n-                $crate::__private::core::result::Result::Ok(parsed_flags)\n-            }\n-        }\n-\n-        impl $crate::__private::core::fmt::Binary for $InternalBitFlags {\n-            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n-                $crate::__private::core::fmt::Binary::fmt(&self.bits(), f)\n+                $crate::parser::from_str::<$PublicBitFlags>(s).map(|flags| flags.0)\n             }\n         }\n \n-        impl $crate::__private::core::fmt::Octal for $InternalBitFlags {\n-            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n-                $crate::__private::core::fmt::Octal::fmt(&self.bits(), f)\n-            }\n-        }\n-\n-        impl $crate::__private::core::fmt::LowerHex for $InternalBitFlags {\n-            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n-                $crate::__private::core::fmt::LowerHex::fmt(&self.bits(), f)\n+        impl $crate::__private::core::convert::AsRef<$T> for $InternalBitFlags {\n+            fn as_ref(&self) -> &$T {\n+                &self.0\n             }\n         }\n \n-        impl $crate::__private::core::fmt::UpperHex for $InternalBitFlags {\n-            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n-                $crate::__private::core::fmt::UpperHex::fmt(&self.bits(), f)\n+        impl $crate::__private::core::convert::From<$T> for $InternalBitFlags {\n+            fn from(bits: $T) -> Self {\n+                Self::from_bits_retain(bits)\n             }\n         }\n \n-        impl $InternalBitFlags {\n-            #[inline]\n-            pub const fn empty() -> Self {\n-                Self { bits: <$T as $crate::__private::Bits>::EMPTY }\n-            }\n-\n-            #[inline]\n-            pub const fn all() -> Self {\n-                Self::from_bits_truncate(<$T as $crate::__private::Bits>::ALL)\n-            }\n-\n-            #[inline]\n-            pub const fn bits(&self) -> $T {\n-                self.bits\n-            }\n-\n-            #[inline]\n-            pub fn bits_mut(&mut self) -> &mut $T {\n-                &mut self.bits\n-            }\n-\n-            #[inline]\n-            pub const fn from_bits(bits: $T) -> $crate::__private::core::option::Option<Self> {\n-                let truncated = Self::from_bits_truncate(bits).bits;\n-\n-                if truncated == bits {\n-                    $crate::__private::core::option::Option::Some(Self { bits })\n-                } else {\n-                    $crate::__private::core::option::Option::None\n-                }\n-            }\n-\n-            #[inline]\n-            pub const fn from_bits_truncate(bits: $T) -> Self {\n-                if bits == <$T as $crate::__private::Bits>::EMPTY {\n-                    return Self { bits }\n-                }\n-\n-                let mut truncated = <$T as $crate::__private::Bits>::EMPTY;\n+        \/\/ The internal flags type offers a similar API to the public one\n \n+        __impl_public_bitflags! {\n+            $InternalBitFlags: $T {\n                 $(\n-                    __expr_safe_flags!(\n-                        $(#[$attr $($args)*])*\n-                        {\n-                            if bits & $BitFlags::$Flag.bits() == $BitFlags::$Flag.bits() {\n-                                truncated |= $BitFlags::$Flag.bits()\n-                            }\n-                        }\n-                    );\n+                    $(#[$attr $($args)*])*\n+                    $Flag;\n                 )*\n-\n-                Self { bits: truncated }\n-            }\n-\n-            #[inline]\n-            pub const fn from_bits_retain(bits: $T) -> Self {\n-                Self { bits }\n             }\n+        }\n \n-            #[inline]\n-            pub fn from_name(name: &str) -> $crate::__private::core::option::Option<Self> {\n+        __impl_public_bitflags_consts! {\n+            $InternalBitFlags: $T {\n                 $(\n-                    __expr_safe_flags!(\n-                        $(#[$attr $($args)*])*\n-                        {\n-                            if name == $crate::__private::core::stringify!($Flag) {\n-                                return $crate::__private::core::option::Option::Some(Self { bits: $BitFlags::$Flag.bits() });\n-                            }\n-                        }\n-                    );\n+                    $(#[$attr $($args)*])*\n+                    #[allow(\n+                        dead_code,\n+                        deprecated,\n+                        unused_attributes,\n+                        non_upper_case_globals\n+                    )]\n+                    $Flag = $value;\n                 )*\n-\n-                let _ = name;\n-                $crate::__private::core::option::Option::None\n-            }\n-\n-            #[inline]\n-            pub const fn iter(&self) -> $Iter {\n-                $Iter {\n-                    inner: self.iter_names(),\n-                    done: false,\n-                }\n-            }\n-\n-            #[inline]\n-            pub const fn iter_names(&self) -> $IterNames {\n-                $IterNames {\n-                    idx: 0,\n-                    source: *self,\n-                    state: *self,\n-                }\n-            }\n-\n-            #[inline]\n-            pub const fn is_empty(&self) -> bool {\n-                self.bits == Self::empty().bits\n-            }\n-\n-            #[inline]\n-            pub const fn is_all(&self) -> bool {\n-                Self::all().bits | self.bits == self.bits\n-            }\n-\n-            #[inline]\n-            pub const fn intersects(&self, other: Self) -> bool {\n-                !(Self { bits: self.bits & other.bits}).is_empty()\n-            }\n-\n-            #[inline]\n-            pub const fn contains(&self, other: Self) -> bool {\n-                (self.bits & other.bits) == other.bits\n-            }\n-\n-            #[inline]\n-            pub fn insert(&mut self, other: Self) {\n-                self.bits |= other.bits;\n-            }\n-\n-            #[inline]\n-            pub fn remove(&mut self, other: Self) {\n-                self.bits &= !other.bits;\n-            }\n-\n-            #[inline]\n-            pub fn toggle(&mut self, other: Self) {\n-                self.bits ^= other.bits;\n-            }\n-\n-            #[inline]\n-            pub fn set(&mut self, other: Self, value: bool) {\n-                if value {\n-                    self.insert(other);\n-                } else {\n-                    self.remove(other);\n-                }\n-            }\n-\n-            #[inline]\n-            #[must_use]\n-            pub const fn intersection(self, other: Self) -> Self {\n-                Self { bits: self.bits & other.bits }\n-            }\n-\n-            #[inline]\n-            #[must_use]\n-            pub const fn union(self, other: Self) -> Self {\n-                Self { bits: self.bits | other.bits }\n             }\n+        }\n \n+        impl $InternalBitFlags {\n+            \/\/\/ Returns a mutable reference to the raw value of the flags currently stored.\n             #[inline]\n-            #[must_use]\n-            pub const fn difference(self, other: Self) -> Self {\n-                Self { bits: self.bits & !other.bits }\n+            pub fn bits_mut(&mut self) -> &mut $T {\n+                &mut self.0\n             }\n \n+            \/\/\/ Iterate over enabled flag values.\n             #[inline]\n-            #[must_use]\n-            pub const fn symmetric_difference(self, other: Self) -> Self {\n-                Self { bits: self.bits ^ other.bits }\n+            pub const fn iter(&self) -> $crate::iter::Iter<$PublicBitFlags> {\n+                $crate::iter::Iter::__private_const_new(<$PublicBitFlags as $crate::Flags>::FLAGS, $PublicBitFlags::from_bits_retain(self.0), $PublicBitFlags::from_bits_retain(self.0))\n             }\n \n+            \/\/\/ Iterate over enabled flag values with their stringified names.\n             #[inline]\n-            #[must_use]\n-            pub const fn complement(self) -> Self {\n-                Self::from_bits_truncate(!self.bits)\n-            }\n-        }\n-\n-        impl $crate::__private::core::convert::AsRef<$T> for $InternalBitFlags {\n-            fn as_ref(&self) -> &$T {\n-                &self.bits\n-            }\n-        }\n-\n-        impl $crate::__private::core::convert::From<$T> for $InternalBitFlags {\n-            fn from(bits: $T) -> Self {\n-                Self::from_bits_retain(bits)\n-            }\n-        }\n-\n-        impl $crate::__private::core::iter::Iterator for $Iter {\n-            type Item = $BitFlags;\n-\n-            fn next(&mut self) -> $crate::__private::core::option::Option<Self::Item> {\n-                match self.inner.next().map(|(_, value)| value) {\n-                    $crate::__private::core::option::Option::Some(value) => $crate::__private::core::option::Option::Some(value),\n-                    $crate::__private::core::option::Option::None if !self.done => {\n-                        self.done = true;\n-\n-                        \/\/ After iterating through valid names, if there are any bits left over\n-                        \/\/ then return one final value that includes them. This makes `into_iter`\n-                        \/\/ and `from_iter` roundtrip\n-                        if self.inner.state != $InternalBitFlags::empty() {\n-                            $crate::__private::core::option::Option::Some($BitFlags::from_bits_retain(self.inner.state.bits()))\n-                        } else {\n-                            $crate::__private::core::option::Option::None\n-                        }\n-                    },\n-                    _ => $crate::__private::core::option::Option::None,\n-                }\n-            }\n-        }\n-\n-        impl $crate::__private::core::iter::Iterator for $IterNames {\n-            type Item = (&'static str, $BitFlags);\n-\n-            fn next(&mut self) -> $crate::__private::core::option::Option<Self::Item> {\n-                const NUM_FLAGS: usize = {\n-                    let mut num_flags = 0;\n-\n-                    $(\n-                        __expr_safe_flags!(\n-                            $(#[$attr $($args)*])*\n-                            {\n-                                { num_flags += 1; }\n-                            }\n-                        );\n-                    )*\n-\n-                    num_flags\n-                };\n-\n-                const OPTIONS: [$T; NUM_FLAGS] = [\n-                    $(\n-                        __expr_safe_flags!(\n-                            $(#[$attr $($args)*])*\n-                            {\n-                                $BitFlags::$Flag.bits()\n-                            }\n-                        ),\n-                    )*\n-                ];\n-\n-                const OPTIONS_NAMES: [&'static str; NUM_FLAGS] = [\n-                    $(\n-                        __expr_safe_flags!(\n-                            $(#[$attr $($args)*])*\n-                            {\n-                                $crate::__private::core::stringify!($Flag)\n-                            }\n-                        ),\n-                    )*\n-                ];\n-\n-                if self.state.is_empty() || NUM_FLAGS == 0 {\n-                    $crate::__private::core::option::Option::None\n-                } else {\n-                    #[allow(clippy::indexing_slicing)]\n-                    for (flag, flag_name) in OPTIONS[self.idx..NUM_FLAGS].iter().copied()\n-                        .zip(OPTIONS_NAMES[self.idx..NUM_FLAGS].iter().copied())\n-                    {\n-                        self.idx += 1;\n-\n-                        \/\/ NOTE: We check whether the flag exists in self, but remove it from\n-                        \/\/ a different value. This ensure that overlapping flags are handled\n-                        \/\/ properly. Take the following example:\n-                        \/\/\n-                        \/\/ const A: 0b00000001;\n-                        \/\/ const B: 0b00000101;\n-                        \/\/\n-                        \/\/ Given the bits 0b00000101, both A and B are set. But if we removed A\n-                        \/\/ as we encountered it we'd be left with 0b00000100, which doesn't\n-                        \/\/ correspond to a valid flag on its own.\n-                        if self.source.contains($InternalBitFlags { bits: flag }) {\n-                            self.state.remove($InternalBitFlags { bits: flag });\n-\n-                            return $crate::__private::core::option::Option::Some((flag_name, $BitFlags::from_bits_retain(flag)))\n-                        }\n-                    }\n-\n-                    $crate::__private::core::option::Option::None\n-                }\n+            pub const fn iter_names(&self) -> $crate::iter::IterNames<$PublicBitFlags> {\n+                $crate::iter::IterNames::__private_const_new(<$PublicBitFlags as $crate::Flags>::FLAGS, $PublicBitFlags::from_bits_retain(self.0), $PublicBitFlags::from_bits_retain(self.0))\n             }\n         }\n     };\n }\n-\n-\/\/\/ A macro that processed the input to `bitflags!` and shuffles attributes around\n-\/\/\/ based on whether or not they're \"expression-safe\".\n-\/\/\/\n-\/\/\/ This macro is a token-tree muncher that works on 2 levels:\n-\/\/\/\n-\/\/\/ For each attribute, we explicitly match on its identifier, like `cfg` to determine\n-\/\/\/ whether or not it should be considered expression-safe.\n-\/\/\/\n-\/\/\/ If you find yourself with an attribute that should be considered expression-safe\n-\/\/\/ and isn't, it can be added here.\n-#[macro_export(local_inner_macros)]\n-#[doc(hidden)]\n-macro_rules! __expr_safe_flags {\n-    \/\/ Entrypoint: Move all flags and all attributes into `unprocessed` lists\n-    \/\/ where they'll be munched one-at-a-time\n-    (\n-        $(#[$inner:ident $($args:tt)*])*\n-        { $e:expr }\n-    ) => {\n-        __expr_safe_flags! {\n-            expr: { $e },\n-            attrs: {\n-                \/\/ All attributes start here\n-                unprocessed: [$(#[$inner $($args)*])*],\n-                processed: {\n-                    \/\/ Attributes that are safe on expressions go here\n-                    expr: [],\n-                },\n-            },\n-        }\n-    };\n-    \/\/ Process the next attribute on the current flag\n-    \/\/ `cfg`: The next flag should be propagated to expressions\n-    \/\/ NOTE: You can copy this rules block and replace `cfg` with\n-    \/\/ your attribute name that should be considered expression-safe\n-    (\n-        expr: { $e:expr },\n-            attrs: {\n-            unprocessed: [\n-                \/\/ cfg matched here\n-                #[cfg $($args:tt)*]\n-                $($attrs_rest:tt)*\n-            ],\n-            processed: {\n-                expr: [$($expr:tt)*],\n-            },\n-        },\n-    ) => {\n-        __expr_safe_flags! {\n-            expr: { $e },\n-            attrs: {\n-                unprocessed: [\n-                    $($attrs_rest)*\n-                ],\n-                processed: {\n-                    expr: [\n-                        $($expr)*\n-                        \/\/ cfg added here\n-                        #[cfg $($args)*]\n-                    ],\n-                },\n-            },\n-        }\n-    };\n-    \/\/ Process the next attribute on the current flag\n-    \/\/ `$other`: The next flag should not be propagated to expressions\n-    (\n-        expr: { $e:expr },\n-            attrs: {\n-            unprocessed: [\n-                \/\/ $other matched here\n-                #[$other:ident $($args:tt)*]\n-                $($attrs_rest:tt)*\n-            ],\n-            processed: {\n-                expr: [$($expr:tt)*],\n-            },\n-        },\n-    ) => {\n-        __expr_safe_flags! {\n-            expr: { $e },\n-                attrs: {\n-                unprocessed: [\n-                    $($attrs_rest)*\n-                ],\n-                processed: {\n-                    expr: [\n-                        \/\/ $other not added here\n-                        $($expr)*\n-                    ],\n-                },\n-            },\n-        }\n-    };\n-    \/\/ Once all attributes on all flags are processed, generate the actual code\n-    (\n-        expr: { $e:expr },\n-        attrs: {\n-            unprocessed: [],\n-            processed: {\n-                expr: [$(#[$expr:ident $($exprargs:tt)*])*],\n-            },\n-        },\n-    ) => {\n-        $(#[$expr $($exprargs)*])*\n-        { $e }\n-    }\n-}\ndiff --git \/dev\/null b\/src\/iter.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/src\/iter.rs\n@@ -0,0 +1,133 @@\n+\/\/! Iterating over set flag values.\n+\n+use crate::{Flags, Flag};\n+\n+\/\/\/ An iterator over a set of flags.\n+\/\/\/\n+\/\/\/ Any bits that don't correspond to a valid flag will be yielded\n+\/\/\/ as a final item from the iterator.\n+pub struct Iter<B: 'static> {\n+    inner: IterNames<B>,\n+    done: bool,\n+}\n+\n+impl<B: Flags> Iter<B> {\n+    \/\/\/ Create a new iterator over the given set of flags.\n+    pub(crate) fn new(flags: &B) -> Self {\n+        Iter {\n+            inner: IterNames::new(flags),\n+            done: false,\n+        }\n+    }\n+}\n+\n+impl<B: 'static> Iter<B> {\n+    #[doc(hidden)]\n+    pub const fn __private_const_new(flags: &'static [Flag<B>], source: B, state: B) -> Self {\n+        Iter {\n+            inner: IterNames::__private_const_new(flags, source, state),\n+            done: false,\n+        }\n+    }\n+}\n+\n+impl<B: Flags> Iterator for Iter<B> {\n+    type Item = B;\n+    \n+    fn next(&mut self) -> Option<Self::Item> {\n+        match self.inner.next() {\n+            Some((_, flag)) => Some(flag),\n+            None if !self.done => {\n+                self.done = true;\n+                \n+                \/\/ After iterating through valid names, if there are any bits left over\n+                \/\/ then return one final value that includes them. This makes `into_iter`\n+                \/\/ and `from_iter` roundtrip\n+                if !self.inner.remaining().is_empty() {\n+                    Some(B::from_bits_retain(self.inner.state.bits()))\n+                } else {\n+                    None\n+                }\n+            }\n+            None => None,\n+        }\n+    }\n+}\n+\n+\/\/\/ An iterator over a set of flags and their names.\n+\/\/\/\n+\/\/\/ Any bits that don't correspond to a valid flag will be ignored.\n+pub struct IterNames<B: 'static> {\n+    flags: &'static [Flag<B>],\n+    idx: usize,\n+    source: B,\n+    state: B,\n+}\n+\n+impl<B: Flags> IterNames<B> {\n+    \/\/\/ Create a new iterator over the given set of flags.\n+    pub(crate) fn new(flags: &B) -> Self {\n+        IterNames {\n+            flags: B::FLAGS,\n+            idx: 0,\n+            state: B::from_bits_retain(flags.bits()),\n+            source: B::from_bits_retain(flags.bits()),\n+        }\n+    }\n+}\n+\n+impl<B: 'static> IterNames<B> {\n+    #[doc(hidden)]\n+    pub const fn __private_const_new(flags: &'static [Flag<B>], source: B, state: B) -> Self {\n+        IterNames {\n+            flags,\n+            idx: 0,\n+            state,\n+            source,\n+        }\n+    }\n+\n+    \/\/\/ Get the remaining (unyielded) flags.\n+    \/\/\/\n+    \/\/\/ Once the iterator has finished, this method can be used to\n+    \/\/\/ check whether or not there are any bits that didn't correspond\n+    \/\/\/ to a valid flag remaining.\n+    pub fn remaining(&self) -> &B {\n+        &self.state\n+    }\n+}\n+\n+impl<B: Flags> Iterator for IterNames<B> {\n+    type Item = (&'static str, B);\n+    \n+    fn next(&mut self) -> Option<Self::Item> {\n+        while let Some(flag) = self.flags.get(self.idx) {\n+            \/\/ Short-circuit if our state is empty\n+            if self.state.is_empty() {\n+                return None;\n+            }\n+\n+            self.idx += 1;\n+\n+            let bits = flag.value().bits();\n+\n+            \/\/ NOTE: We check whether the flag exists in self, but remove it from\n+            \/\/ a different value. This ensure that overlapping flags are handled\n+            \/\/ properly. Take the following example:\n+            \/\/\n+            \/\/ const A: 0b00000001;\n+            \/\/ const B: 0b00000101;\n+            \/\/\n+            \/\/ Given the bits 0b00000101, both A and B are set. But if we removed A\n+            \/\/ as we encountered it we'd be left with 0b00000100, which doesn't\n+            \/\/ correspond to a valid flag on its own.\n+            if self.source.contains(B::from_bits_retain(bits)) {\n+                self.state.remove(B::from_bits_retain(bits));\n+\n+                return Some((flag.name(), B::from_bits_retain(bits)));\n+            }\n+        }\n+        \n+        None\n+    }\n+}\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -374,16 +374,16 @@\n \/\/! }\n \/\/! ```\n \/\/!\n-\/\/! [`from_bits`]: BitFlags::from_bits\n-\/\/! [`from_bits_truncate`]: BitFlags::from_bits_truncate\n+\/\/! [`from_bits`]: Flags::from_bits\n+\/\/! [`from_bits_truncate`]: Flags::from_bits_truncate\n \/\/!\n-\/\/! # The `BitFlags` trait\n+\/\/! # The `Flags` trait\n \/\/!\n-\/\/! This library defines a `BitFlags` trait that's implemented by all generated flags types.\n+\/\/! This library defines a `Flags` trait that's implemented by all generated flags types.\n \/\/! The trait makes it possible to work with flags types generically:\n \/\/!\n \/\/! ```\n-\/\/! fn count_unset_flags<F: bitflags::BitFlags>(flags: &F) -> usize {\n+\/\/! fn count_unset_flags<F: bitflags::Flags>(flags: &F) -> usize {\n \/\/!     \/\/ Find out how many flags there are in total\n \/\/!     let total = F::all().iter().count();\n \/\/!\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -563,20 +570,14 @@ macro_rules! bitflags {\n         \/\/ This type appears in the end-user's API\n         __declare_public_bitflags! {\n             $(#[$outer])*\n-            $vis struct $BitFlags;\n+            $vis struct $BitFlags\n         }\n \n         \/\/ Workaround for: https:\/\/github.com\/bitflags\/bitflags\/issues\/320\n         __impl_public_bitflags_consts! {\n-            $BitFlags {\n+            $BitFlags: $T {\n                 $(\n                     $(#[$inner $($args)*])*\n-                    #[allow(\n-                        dead_code,\n-                        deprecated,\n-                        unused_attributes,\n-                        non_upper_case_globals\n-                    )]\n                     $Flag = $value;\n                 )*\n             }\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -595,16 +596,14 @@ macro_rules! bitflags {\n             \/\/ Declared in a \"hidden\" scope that can't be reached directly\n             \/\/ These types don't appear in the end-user's API\n             __declare_internal_bitflags! {\n-                $vis struct InternalBitFlags: $T;\n-                $vis struct Iter;\n-                $vis struct IterRaw;\n+                $vis struct InternalBitFlags: $T\n             }\n \n             __impl_internal_bitflags! {\n-                InternalBitFlags: $T, $BitFlags, Iter, IterRaw {\n+                InternalBitFlags: $T, $BitFlags {\n                     $(\n                         $(#[$inner $($args)*])*\n-                        $Flag;\n+                        $Flag = $value;\n                     )*\n                 }\n             }\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -619,8 +618,59 @@ macro_rules! bitflags {\n                 }\n             }\n \n+            __impl_public_bitflags_forward! {\n+                $BitFlags: $T, InternalBitFlags\n+            }\n+\n+            __impl_public_bitflags_iter! {\n+                $BitFlags\n+            }\n+        };\n+\n+        bitflags! {\n+            $($t)*\n+        }\n+    };\n+    (\n+        impl $BitFlags:ident: $T:ty {\n+            $(\n+                $(#[$inner:ident $($args:tt)*])*\n+                const $Flag:ident = $value:expr;\n+            )*\n+        }\n+\n+        $($t:tt)*\n+    ) => {\n+        __impl_public_bitflags_consts! {\n+            $BitFlags: $T {\n+                $(\n+                    $(#[$inner $($args)*])*\n+                    $Flag = $value;\n+                )*\n+            }\n+        }\n+\n+        #[allow(\n+            dead_code,\n+            deprecated,\n+            unused_doc_comments,\n+            unused_attributes,\n+            unused_mut,\n+            unused_imports,\n+            non_upper_case_globals\n+        )]\n+        const _: () = {\n             __impl_public_bitflags! {\n-                $BitFlags: $T, InternalBitFlags, Iter, IterRaw;\n+                $BitFlags: $T {\n+                    $(\n+                        $(#[$inner $($args)*])*\n+                        $Flag;\n+                    )*\n+                }\n+            }\n+\n+            __impl_public_bitflags_iter! {\n+                $BitFlags\n             }\n         };\n \ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -631,6 +681,357 @@ macro_rules! bitflags {\n     () => {};\n }\n \n+\/\/\/ Implement functions on bitflags types.\n+\/\/\/\n+\/\/\/ We need to be careful about adding new methods and trait implementations here because they\n+\/\/\/ could conflict with items added by the end-user.\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+macro_rules! __impl_bitflags {\n+    (\n+        $PublicBitFlags:ident: $T:ty {\n+            fn empty() $empty:block\n+            fn all() $all:block\n+            fn bits($bits0:ident) $bits:block\n+            fn from_bits($from_bits0:ident) $from_bits:block\n+            fn from_bits_truncate($from_bits_truncate0:ident) $from_bits_truncate:block\n+            fn from_bits_retain($from_bits_retain0:ident) $from_bits_retain:block\n+            fn from_name($from_name0:ident) $from_name:block\n+            fn is_empty($is_empty0:ident) $is_empty:block\n+            fn is_all($is_all0:ident) $is_all:block\n+            fn intersects($intersects0:ident, $intersects1:ident) $intersects:block\n+            fn contains($contains0:ident, $contains1:ident) $contains:block\n+            fn insert($insert0:ident, $insert1:ident) $insert:block\n+            fn remove($remove0:ident, $remove1:ident) $remove:block\n+            fn toggle($toggle0:ident, $toggle1:ident) $toggle:block\n+            fn set($set0:ident, $set1:ident, $set2:ident) $set:block\n+            fn intersection($intersection0:ident, $intersection1:ident) $intersection:block\n+            fn union($union0:ident, $union1:ident) $union:block\n+            fn difference($difference0:ident, $difference1:ident) $difference:block\n+            fn symmetric_difference($symmetric_difference0:ident, $symmetric_difference1:ident) $symmetric_difference:block\n+            fn complement($complement0:ident) $complement:block\n+        }\n+    ) => {\n+        #[allow(\n+            dead_code,\n+            deprecated,\n+            unused_attributes\n+        )]\n+        impl $PublicBitFlags {\n+            \/\/\/ Returns an empty set of flags.\n+            #[inline]\n+            pub const fn empty() -> Self {\n+                $empty\n+            }\n+\n+            \/\/\/ Returns the set containing all flags.\n+            #[inline]\n+            pub const fn all() -> Self {\n+                $all\n+            }\n+\n+            \/\/\/ Returns the raw value of the flags currently stored.\n+            #[inline]\n+            pub const fn bits(&self) -> $T {\n+                let $bits0 = self;\n+                $bits\n+            }\n+\n+            \/\/\/ Convert from underlying bit representation, unless that\n+            \/\/\/ representation contains bits that do not correspond to a flag.\n+            #[inline]\n+            pub const fn from_bits(bits: $T) -> $crate::__private::core::option::Option<Self> {\n+                let $from_bits0 = bits;\n+                $from_bits\n+            }\n+\n+            \/\/\/ Convert from underlying bit representation, dropping any bits\n+            \/\/\/ that do not correspond to flags.\n+            #[inline]\n+            pub const fn from_bits_truncate(bits: $T) -> Self {\n+                let $from_bits_truncate0 = bits;\n+                $from_bits_truncate\n+            }\n+\n+            \/\/\/ Convert from underlying bit representation, preserving all\n+            \/\/\/ bits (even those not corresponding to a defined flag).\n+            #[inline]\n+            pub const fn from_bits_retain(bits: $T) -> Self {\n+                let $from_bits_retain0 = bits;\n+                $from_bits_retain\n+            }\n+\n+            \/\/\/ Get the value for a flag from its stringified name.\n+            \/\/\/\n+            \/\/\/ Names are _case-sensitive_, so must correspond exactly to\n+            \/\/\/ the identifier given to the flag.\n+            #[inline]\n+            pub fn from_name(name: &str) -> $crate::__private::core::option::Option<Self> {\n+                let $from_name0 = name;\n+                $from_name\n+            }\n+\n+            \/\/\/ Returns `true` if no flags are currently stored.\n+            #[inline]\n+            pub const fn is_empty(&self) -> bool {\n+                let $is_empty0 = self;\n+                $is_empty\n+            }\n+\n+            \/\/\/ Returns `true` if all flags are currently set.\n+            #[inline]\n+            pub const fn is_all(&self) -> bool {\n+                let $is_all0 = self;\n+                $is_all\n+            }\n+\n+            \/\/\/ Returns `true` if there are flags common to both `self` and `other`.\n+            #[inline]\n+            pub const fn intersects(&self, other: Self) -> bool {\n+                let $intersects0 = self;\n+                let $intersects1 = other;\n+                $intersects\n+            }\n+\n+            \/\/\/ Returns `true` if all of the flags in `other` are contained within `self`.\n+            #[inline]\n+            pub const fn contains(&self, other: Self) -> bool {\n+                let $contains0 = self;\n+                let $contains1 = other;\n+                $contains\n+            }\n+\n+            \/\/\/ Inserts the specified flags in-place.\n+            #[inline]\n+            pub fn insert(&mut self, other: Self) {\n+                let $insert0 = self;\n+                let $insert1 = other;\n+                $insert\n+            }\n+\n+            \/\/\/ Removes the specified flags in-place.\n+            #[inline]\n+            pub fn remove(&mut self, other: Self) {\n+                let $remove0 = self;\n+                let $remove1 = other;\n+                $remove\n+            }\n+\n+            \/\/\/ Toggles the specified flags in-place.\n+            #[inline]\n+            pub fn toggle(&mut self, other: Self) {\n+                let $toggle0 = self;\n+                let $toggle1 = other;\n+                $toggle\n+            }\n+\n+            \/\/\/ Inserts or removes the specified flags depending on the passed value.\n+            #[inline]\n+            pub fn set(&mut self, other: Self, value: bool) {\n+                let $set0 = self;\n+                let $set1 = other;\n+                let $set2 = value;\n+                $set\n+            }\n+\n+            \/\/\/ Returns the intersection between the flags in `self` and\n+            \/\/\/ `other`.\n+            \/\/\/\n+            \/\/\/ Specifically, the returned set contains only the flags which are\n+            \/\/\/ present in *both* `self` *and* `other`.\n+            \/\/\/\n+            \/\/\/ This is equivalent to using the `&` operator (e.g.\n+            \/\/\/ [`ops::BitAnd`]), as in `flags & other`.\n+            \/\/\/\n+            \/\/\/ [`ops::BitAnd`]: https:\/\/doc.rust-lang.org\/std\/ops\/trait.BitAnd.html\n+            #[inline]\n+            #[must_use]\n+            pub const fn intersection(self, other: Self) -> Self {\n+                let $intersection0 = self;\n+                let $intersection1 = other;\n+                $intersection\n+            }\n+\n+            \/\/\/ Returns the union of between the flags in `self` and `other`.\n+            \/\/\/\n+            \/\/\/ Specifically, the returned set contains all flags which are\n+            \/\/\/ present in *either* `self` *or* `other`, including any which are\n+            \/\/\/ present in both (see [`Self::symmetric_difference`] if that\n+            \/\/\/ is undesirable).\n+            \/\/\/\n+            \/\/\/ This is equivalent to using the `|` operator (e.g.\n+            \/\/\/ [`ops::BitOr`]), as in `flags | other`.\n+            \/\/\/\n+            \/\/\/ [`ops::BitOr`]: https:\/\/doc.rust-lang.org\/std\/ops\/trait.BitOr.html\n+            #[inline]\n+            #[must_use]\n+            pub const fn union(self, other: Self) -> Self {\n+                let $union0 = self;\n+                let $union1 = other;\n+                $union\n+            }\n+\n+            \/\/\/ Returns the difference between the flags in `self` and `other`.\n+            \/\/\/\n+            \/\/\/ Specifically, the returned set contains all flags present in\n+            \/\/\/ `self`, except for the ones present in `other`.\n+            \/\/\/\n+            \/\/\/ It is also conceptually equivalent to the \"bit-clear\" operation:\n+            \/\/\/ `flags & !other` (and this syntax is also supported).\n+            \/\/\/\n+            \/\/\/ This is equivalent to using the `-` operator (e.g.\n+            \/\/\/ [`ops::Sub`]), as in `flags - other`.\n+            \/\/\/\n+            \/\/\/ [`ops::Sub`]: https:\/\/doc.rust-lang.org\/std\/ops\/trait.Sub.html\n+            #[inline]\n+            #[must_use]\n+            pub const fn difference(self, other: Self) -> Self {\n+                let $difference0 = self;\n+                let $difference1 = other;\n+                $difference\n+            }\n+\n+            \/\/\/ Returns the [symmetric difference][sym-diff] between the flags\n+            \/\/\/ in `self` and `other`.\n+            \/\/\/\n+            \/\/\/ Specifically, the returned set contains the flags present which\n+            \/\/\/ are present in `self` or `other`, but that are not present in\n+            \/\/\/ both. Equivalently, it contains the flags present in *exactly\n+            \/\/\/ one* of the sets `self` and `other`.\n+            \/\/\/\n+            \/\/\/ This is equivalent to using the `^` operator (e.g.\n+            \/\/\/ [`ops::BitXor`]), as in `flags ^ other`.\n+            \/\/\/\n+            \/\/\/ [sym-diff]: https:\/\/en.wikipedia.org\/wiki\/Symmetric_difference\n+            \/\/\/ [`ops::BitXor`]: https:\/\/doc.rust-lang.org\/std\/ops\/trait.BitXor.html\n+            #[inline]\n+            #[must_use]\n+            pub const fn symmetric_difference(self, other: Self) -> Self {\n+                let $symmetric_difference0 = self;\n+                let $symmetric_difference1 = other;\n+                $symmetric_difference\n+            }\n+\n+            \/\/\/ Returns the complement of this set of flags.\n+            \/\/\/\n+            \/\/\/ Specifically, the returned set contains all the flags which are\n+            \/\/\/ not set in `self`, but which are allowed for this type.\n+            \/\/\/\n+            \/\/\/ Alternatively, it can be thought of as the set difference\n+            \/\/\/ between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n+            \/\/\/\n+            \/\/\/ This is equivalent to using the `!` operator (e.g.\n+            \/\/\/ [`ops::Not`]), as in `!flags`.\n+            \/\/\/\n+            \/\/\/ [`Self::all()`]: Self::all\n+            \/\/\/ [`ops::Not`]: https:\/\/doc.rust-lang.org\/std\/ops\/trait.Not.html\n+            #[inline]\n+            #[must_use]\n+            pub const fn complement(self) -> Self {\n+                let $complement0 = self;\n+                $complement\n+            }\n+        }\n+    };\n+}\n+\n+\/\/\/ A macro that processed the input to `bitflags!` and shuffles attributes around\n+\/\/\/ based on whether or not they're \"expression-safe\".\n+\/\/\/\n+\/\/\/ This macro is a token-tree muncher that works on 2 levels:\n+\/\/\/\n+\/\/\/ For each attribute, we explicitly match on its identifier, like `cfg` to determine\n+\/\/\/ whether or not it should be considered expression-safe.\n+\/\/\/\n+\/\/\/ If you find yourself with an attribute that should be considered expression-safe\n+\/\/\/ and isn't, it can be added here.\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+macro_rules! __bitflags_expr_safe_attrs {\n+    \/\/ Entrypoint: Move all flags and all attributes into `unprocessed` lists\n+    \/\/ where they'll be munched one-at-a-time\n+    (\n+        $(#[$inner:ident $($args:tt)*])*\n+        { $e:expr }\n+    ) => {\n+        __bitflags_expr_safe_attrs! {\n+            expr: { $e },\n+            attrs: {\n+                \/\/ All attributes start here\n+                unprocessed: [$(#[$inner $($args)*])*],\n+                \/\/ Attributes that are safe on expressions go here\n+                processed: [],\n+            },\n+        }\n+    };\n+    \/\/ Process the next attribute on the current flag\n+    \/\/ `cfg`: The next flag should be propagated to expressions\n+    \/\/ NOTE: You can copy this rules block and replace `cfg` with\n+    \/\/ your attribute name that should be considered expression-safe\n+    (\n+        expr: { $e:expr },\n+            attrs: {\n+            unprocessed: [\n+                \/\/ cfg matched here\n+                #[cfg $($args:tt)*]\n+                $($attrs_rest:tt)*\n+            ],\n+            processed: [$($expr:tt)*],\n+        },\n+    ) => {\n+        __bitflags_expr_safe_attrs! {\n+            expr: { $e },\n+            attrs: {\n+                unprocessed: [\n+                    $($attrs_rest)*\n+                ],\n+                processed: [\n+                    $($expr)*\n+                    \/\/ cfg added here\n+                    #[cfg $($args)*]\n+                ],\n+            },\n+        }\n+    };\n+    \/\/ Process the next attribute on the current flag\n+    \/\/ `$other`: The next flag should not be propagated to expressions\n+    (\n+        expr: { $e:expr },\n+            attrs: {\n+            unprocessed: [\n+                \/\/ $other matched here\n+                #[$other:ident $($args:tt)*]\n+                $($attrs_rest:tt)*\n+            ],\n+            processed: [$($expr:tt)*],\n+        },\n+    ) => {\n+        __bitflags_expr_safe_attrs! {\n+            expr: { $e },\n+                attrs: {\n+                unprocessed: [\n+                    $($attrs_rest)*\n+                ],\n+                processed: [\n+                    \/\/ $other not added here\n+                    $($expr)*\n+                ],\n+            },\n+        }\n+    };\n+    \/\/ Once all attributes on all flags are processed, generate the actual code\n+    (\n+        expr: { $e:expr },\n+        attrs: {\n+            unprocessed: [],\n+            processed: [$(#[$expr:ident $($exprargs:tt)*])*],\n+        },\n+    ) => {\n+        $(#[$expr $($exprargs)*])*\n+        { $e }\n+    }\n+}\n+\n #[macro_use]\n mod public;\n #[macro_use]\ndiff --git a\/src\/parser.rs b\/src\/parser.rs\n--- a\/src\/parser.rs\n+++ b\/src\/parser.rs\n@@ -28,7 +28,118 @@\n \n #![allow(clippy::let_unit_value)]\n \n-use core::fmt;\n+use core::fmt::{self, Write};\n+\n+use crate::{Flags, Bits};\n+\n+\/\/\/ Write a set of flags to a writer.\n+\/\/\/\n+\/\/\/ Any bits that don't correspond to a valid flag will be formatted\n+\/\/\/ as a hex number.\n+pub fn to_writer<B: Flags>(flags: &B, mut writer: impl Write) -> Result<(), fmt::Error>\n+where\n+    B::Bits: WriteHex,\n+{\n+    \/\/ A formatter for bitflags that produces text output like:\n+    \/\/\n+    \/\/ A | B | 0xf6\n+    \/\/\n+    \/\/ The names of set flags are written in a bar-separated-format,\n+    \/\/ followed by a hex number of any remaining bits that are set\n+    \/\/ but don't correspond to any flags.\n+\n+    \/\/ Iterate over the valid flags\n+    let mut first = true;\n+    let mut iter = flags.iter_names();\n+    for (name, _) in &mut iter {\n+        if !first {\n+            writer.write_str(\" | \")?;\n+        }\n+\n+        first = false;\n+        writer.write_str(name)?;\n+    }\n+\n+    \/\/ Append any extra bits that correspond to flags to the end of the format\n+    let remaining = iter.remaining().bits();\n+    if remaining != B::Bits::EMPTY {\n+        if !first {\n+            writer.write_str(\" | \")?;\n+        }\n+\n+        writer.write_str(\"0x\")?;\n+        remaining.write_hex(writer)?;\n+    }\n+\n+    fmt::Result::Ok(())\n+}\n+\n+pub(crate) struct AsDisplay<'a, B>(pub(crate) &'a B);\n+\n+impl<'a, B: Flags> fmt::Display for AsDisplay<'a, B>\n+where\n+    B::Bits: WriteHex,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        to_writer(self.0, f)\n+    }\n+}\n+\n+\/\/\/ Parse a set of flags from text.\n+\/\/\/\n+\/\/\/ This function will fail on unknown flags rather than ignore them.\n+pub fn from_str<B: Flags>(input: &str) -> Result<B, ParseError>\n+where\n+    B::Bits: ParseHex,\n+{\n+    let mut parsed_flags = B::empty();\n+\n+    \/\/ If the input is empty then return an empty set of flags\n+    if input.trim().is_empty() {\n+        return Ok(parsed_flags);\n+    }\n+\n+    for flag in input.split('|') {\n+        let flag = flag.trim();\n+\n+        \/\/ If the flag is empty then we've got missing input\n+        if flag.is_empty() {\n+            return Err(ParseError::empty_flag());\n+        }\n+\n+        \/\/ If the flag starts with `0x` then it's a hex number\n+        \/\/ Parse it directly to the underlying bits type\n+        let parsed_flag = if let Some(flag) = flag.strip_prefix(\"0x\") {\n+            let bits = <B::Bits>::parse_hex(flag).map_err(|_| ParseError::invalid_hex_flag(flag))?;\n+\n+            B::from_bits_retain(bits)\n+        }\n+        \/\/ Otherwise the flag is a name\n+        \/\/ The generated flags type will determine whether\n+        \/\/ or not it's a valid identifier\n+        else {\n+            B::from_name(flag).ok_or_else(|| ParseError::invalid_named_flag(flag))?\n+        };\n+\n+        parsed_flags.insert(parsed_flag);\n+    }\n+\n+    Ok(parsed_flags)\n+}\n+\n+\/\/\/ Encode a value as a hex number.\n+pub trait WriteHex {\n+    \/\/\/ Write the value as hex.\n+    fn write_hex<W: fmt::Write>(&self, writer: W) -> fmt::Result;\n+}\n+\n+\/\/\/ Parse a value from a number encoded as a hex string.\n+pub trait ParseHex {\n+    \/\/\/ Parse the value from hex.\n+    fn parse_hex(input: &str) -> Result<Self, ParseError>\n+    where\n+        Self: Sized;\n+}\n \n \/\/\/ An error encountered while parsing flags from text.\n #[derive(Debug)]\ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -11,10 +11,10 @@\n macro_rules! __declare_public_bitflags {\n     (\n         $(#[$outer:meta])*\n-        $vis:vis struct $BitFlags:ident;\n+        $vis:vis struct $PublicBitFlags:ident\n     ) => {\n         $(#[$outer])*\n-        $vis struct $BitFlags(<$BitFlags as $crate::__private::PublicFlags>::Internal);\n+        $vis struct $PublicBitFlags(<$PublicBitFlags as $crate::__private::PublicFlags>::Internal);\n     };\n }\n \ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -24,236 +24,302 @@ macro_rules! __declare_public_bitflags {\n \/\/\/ could conflict with items added by the end-user.\n #[macro_export(local_inner_macros)]\n #[doc(hidden)]\n-macro_rules! __impl_public_bitflags {\n+macro_rules! __impl_public_bitflags_forward {\n     (\n-        $PublicBitFlags:ident: $T:ty, $InternalBitFlags:ident, $Iter:ident, $IterNames:ident;\n+        $PublicBitFlags:ident: $T:ty, $InternalBitFlags:ident\n     ) => {\n-        impl $crate::__private::core::fmt::Binary for $PublicBitFlags {\n-            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n-                $crate::__private::core::fmt::Binary::fmt(&self.0, f)\n-            }\n-        }\n+        __impl_bitflags! {\n+            $PublicBitFlags: $T {\n+                fn empty() {\n+                    Self($InternalBitFlags::empty())\n+                }\n \n-        impl $crate::__private::core::fmt::Octal for $PublicBitFlags {\n-            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n-                $crate::__private::core::fmt::Octal::fmt(&self.0, f)\n-            }\n-        }\n+                fn all() {\n+                    Self($InternalBitFlags::all())\n+                }\n \n-        impl $crate::__private::core::fmt::LowerHex for $PublicBitFlags {\n-            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n-                $crate::__private::core::fmt::LowerHex::fmt(&self.0, f)\n+                fn bits(f) {\n+                    f.0.bits()\n+                }\n+\n+                fn from_bits(bits) {\n+                    match $InternalBitFlags::from_bits(bits) {\n+                        $crate::__private::core::option::Option::Some(bits) => $crate::__private::core::option::Option::Some(Self(bits)),\n+                        $crate::__private::core::option::Option::None => $crate::__private::core::option::Option::None,\n+                    }\n+                }\n+\n+                fn from_bits_truncate(bits) {\n+                    Self($InternalBitFlags::from_bits_truncate(bits))\n+                }\n+\n+                fn from_bits_retain(bits) {\n+                    Self($InternalBitFlags::from_bits_retain(bits))\n+                }\n+\n+                fn from_name(name){\n+                    match $InternalBitFlags::from_name(name) {\n+                        $crate::__private::core::option::Option::Some(bits) => $crate::__private::core::option::Option::Some(Self(bits)),\n+                        $crate::__private::core::option::Option::None => $crate::__private::core::option::Option::None,\n+                    }\n+                }\n+\n+                fn is_empty(f) {\n+                    f.0.is_empty()\n+                }\n+\n+                fn is_all(f) {\n+                    f.0.is_all()\n+                }\n+\n+                fn intersects(f, other) {\n+                    f.0.intersects(other.0)\n+                }\n+\n+                fn contains(f, other) {\n+                    f.0.contains(other.0)\n+                }\n+\n+                fn insert(f, other) {\n+                    f.0.insert(other.0)\n+                }\n+\n+                fn remove(f, other) {\n+                    f.0.remove(other.0)\n+                }\n+\n+                fn toggle(f, other) {\n+                    f.0.toggle(other.0)\n+                }\n+\n+                fn set(f, other, value) {\n+                    f.0.set(other.0, value)\n+                }\n+\n+                fn intersection(f, other) {\n+                    Self(f.0.intersection(other.0))\n+                }\n+\n+                fn union(f, other) {\n+                    Self(f.0.union(other.0))\n+                }\n+\n+                fn difference(f, other) {\n+                    Self(f.0.difference(other.0))\n+                }\n+\n+                fn symmetric_difference(f, other) {\n+                    Self(f.0.symmetric_difference(other.0))\n+                }\n+\n+                fn complement(f) {\n+                    Self(f.0.complement())\n+                }\n             }\n         }\n \n-        impl $crate::__private::core::fmt::UpperHex for $PublicBitFlags {\n-            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n-                $crate::__private::core::fmt::UpperHex::fmt(&self.0, f)\n-            }\n+        __impl_public_bitflags_ops!($PublicBitFlags);\n+    };\n+}\n+\n+\/\/\/ Implement functions on the public (user-facing) bitflags type.\n+\/\/\/\n+\/\/\/ We need to be careful about adding new methods and trait implementations here because they\n+\/\/\/ could conflict with items added by the end-user.\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+macro_rules! __impl_public_bitflags {\n+    (\n+        $PublicBitFlags:ident: $T:ty {\n+            $(\n+                $(#[$attr:ident $($args:tt)*])*\n+                $Flag:ident;\n+            )*\n         }\n+    ) => {\n+        __impl_bitflags! {\n+            $PublicBitFlags: $T {\n+                fn empty() {\n+                    Self(<$T as $crate::Bits>::EMPTY)\n+                }\n \n-        impl $PublicBitFlags {\n-            \/\/\/ Returns an empty set of flags.\n-            #[inline]\n-            pub const fn empty() -> Self {\n-                Self($InternalBitFlags::empty())\n-            }\n+                fn all() {\n+                    Self::from_bits_truncate(<$T as $crate::Bits>::ALL)\n+                }\n \n-            \/\/\/ Returns the set containing all flags.\n-            #[inline]\n-            pub const fn all() -> Self {\n-                Self($InternalBitFlags::all())\n-            }\n+                fn bits(f) {\n+                    f.0\n+                }\n \n-            \/\/\/ Returns the raw value of the flags currently stored.\n-            #[inline]\n-            pub const fn bits(&self) -> $T {\n-                self.0.bits()\n-            }\n+                fn from_bits(bits) {\n+                    let truncated = Self::from_bits_truncate(bits).0;\n \n-            \/\/\/ Convert from underlying bit representation, unless that\n-            \/\/\/ representation contains bits that do not correspond to a flag.\n-            #[inline]\n-            pub const fn from_bits(bits: $T) -> $crate::__private::core::option::Option<Self> {\n-                match $InternalBitFlags::from_bits(bits) {\n-                    $crate::__private::core::option::Option::Some(bits) => $crate::__private::core::option::Option::Some(Self(bits)),\n-                    $crate::__private::core::option::Option::None => $crate::__private::core::option::Option::None,\n+                    if truncated == bits {\n+                        $crate::__private::core::option::Option::Some(Self(bits))\n+                    } else {\n+                        $crate::__private::core::option::Option::None\n+                    }\n                 }\n-            }\n \n-            \/\/\/ Convert from underlying bit representation, dropping any bits\n-            \/\/\/ that do not correspond to flags.\n-            #[inline]\n-            pub const fn from_bits_truncate(bits: $T) -> Self {\n-                Self($InternalBitFlags::from_bits_truncate(bits))\n-            }\n+                fn from_bits_truncate(bits) {\n+                    if bits == <$T as $crate::Bits>::EMPTY {\n+                        return Self(bits)\n+                    }\n+\n+                    let mut truncated = <$T as $crate::Bits>::EMPTY;\n+\n+                    $(\n+                        __bitflags_expr_safe_attrs!(\n+                            $(#[$attr $($args)*])*\n+                            {\n+                                if bits & $PublicBitFlags::$Flag.bits() == $PublicBitFlags::$Flag.bits() {\n+                                    truncated = truncated | $PublicBitFlags::$Flag.bits()\n+                                }\n+                            }\n+                        );\n+                    )*\n+\n+                    Self(truncated)\n+                }\n \n-            \/\/\/ Convert from underlying bit representation, preserving all\n-            \/\/\/ bits (even those not corresponding to a defined flag).\n-            #[inline]\n-            pub const fn from_bits_retain(bits: $T) -> Self {\n-                Self($InternalBitFlags::from_bits_retain(bits))\n-            }\n+                fn from_bits_retain(bits) {\n+                    Self(bits)\n+                }\n \n-            \/\/\/ Get the value for a flag from its stringified name.\n-            \/\/\/\n-            \/\/\/ Names are _case-sensitive_, so must correspond exactly to\n-            \/\/\/ the identifier given to the flag.\n-            #[inline]\n-            pub fn from_name(name: &str) -> $crate::__private::core::option::Option<Self> {\n-                match $InternalBitFlags::from_name(name) {\n-                    $crate::__private::core::option::Option::Some(bits) => $crate::__private::core::option::Option::Some(Self(bits)),\n-                    $crate::__private::core::option::Option::None => $crate::__private::core::option::Option::None,\n+                fn from_name(name) {\n+                    $(\n+                        __bitflags_expr_safe_attrs!(\n+                            $(#[$attr $($args)*])*\n+                            {\n+                                if name == $crate::__private::core::stringify!($Flag) {\n+                                    return $crate::__private::core::option::Option::Some(Self($PublicBitFlags::$Flag.bits()));\n+                                }\n+                            }\n+                        );\n+                    )*\n+\n+                    let _ = name;\n+                    $crate::__private::core::option::Option::None\n                 }\n-            }\n \n-            \/\/\/ Iterate over enabled flag values.\n-            #[inline]\n-            pub const fn iter(&self) -> $Iter {\n-                self.0.iter()\n-            }\n+                fn is_empty(f) {\n+                    f.0 == Self::empty().0\n+                }\n \n-            \/\/\/ Iterate over enabled flag values with their stringified names.\n-            #[inline]\n-            pub const fn iter_names(&self) -> $IterNames {\n-                self.0.iter_names()\n-            }\n+                fn is_all(f) {\n+                    Self::all().0 | f.0 == f.0\n+                }\n \n-            \/\/\/ Returns `true` if no flags are currently stored.\n-            #[inline]\n-            pub const fn is_empty(&self) -> bool {\n-                self.0.is_empty()\n-            }\n+                fn intersects(f, other) {\n+                    !(Self(f.0 & other.0)).is_empty()\n+                }\n \n-            \/\/\/ Returns `true` if all flags are currently set.\n-            #[inline]\n-            pub const fn is_all(&self) -> bool {\n-                self.0.is_all()\n-            }\n+                fn contains(f, other) {\n+                    (f.0 & other.0) == other.0\n+                }\n \n-            \/\/\/ Returns `true` if there are flags common to both `self` and `other`.\n-            #[inline]\n-            pub const fn intersects(&self, other: Self) -> bool {\n-                self.0.intersects(other.0)\n-            }\n+                fn insert(f, other) {\n+                    f.0 = f.0 | other.0;\n+                }\n \n-            \/\/\/ Returns `true` if all of the flags in `other` are contained within `self`.\n-            #[inline]\n-            pub const fn contains(&self, other: Self) -> bool {\n-                self.0.contains(other.0)\n-            }\n+                fn remove(f, other) {\n+                    f.0 = f.0 & !other.0;\n+                }\n \n-            \/\/\/ Inserts the specified flags in-place.\n-            #[inline]\n-            pub fn insert(&mut self, other: Self) {\n-                self.0.insert(other.0)\n-            }\n+                fn toggle(f, other) {\n+                    f.0 = f.0 ^ other.0;\n+                }\n \n-            \/\/\/ Removes the specified flags in-place.\n-            #[inline]\n-            pub fn remove(&mut self, other: Self) {\n-                self.0.remove(other.0)\n+                fn set(f, other, value) {\n+                    if value {\n+                        f.insert(other);\n+                    } else {\n+                        f.remove(other);\n+                    }\n+                }\n+\n+                fn intersection(f, other) {\n+                    Self(f.0 & other.0)\n+                }\n+\n+                fn union(f, other) {\n+                    Self(f.0 | other.0)\n+                }\n+\n+                fn difference(f, other) {\n+                    Self(f.0 & !other.0)\n+                }\n+\n+                fn symmetric_difference(f, other) {\n+                    Self(f.0 ^ other.0)\n+                }\n+\n+                fn complement(f) {\n+                    Self::from_bits_truncate(!f.0)\n+                }\n             }\n+        }\n+\n+        __impl_public_bitflags_ops!($PublicBitFlags);\n+    };\n+}\n \n-            \/\/\/ Toggles the specified flags in-place.\n+\/\/\/ Implement iterators on the public (user-facing) bitflags type.\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+macro_rules! __impl_public_bitflags_iter {\n+    ($PublicBitFlags:ident) => {\n+        impl $PublicBitFlags {\n+            \/\/\/ Iterate over enabled flag values.\n             #[inline]\n-            pub fn toggle(&mut self, other: Self) {\n-                self.0.toggle(other.0)\n+            pub const fn iter(&self) -> $crate::iter::Iter<$PublicBitFlags> {\n+                $crate::iter::Iter::__private_const_new(<$PublicBitFlags as $crate::Flags>::FLAGS, $PublicBitFlags::from_bits_retain(self.bits()), $PublicBitFlags::from_bits_retain(self.bits()))\n             }\n \n-            \/\/\/ Inserts or removes the specified flags depending on the passed value.\n+            \/\/\/ Iterate over enabled flag values with their stringified names.\n             #[inline]\n-            pub fn set(&mut self, other: Self, value: bool) {\n-                self.0.set(other.0, value)\n+            pub const fn iter_names(&self) -> $crate::iter::IterNames<$PublicBitFlags> {\n+                $crate::iter::IterNames::__private_const_new(<$PublicBitFlags as $crate::Flags>::FLAGS, $PublicBitFlags::from_bits_retain(self.bits()), $PublicBitFlags::from_bits_retain(self.bits()))\n             }\n+        }\n \n-            \/\/\/ Returns the intersection between the flags in `self` and\n-            \/\/\/ `other`.\n-            \/\/\/\n-            \/\/\/ Specifically, the returned set contains only the flags which are\n-            \/\/\/ present in *both* `self` *and* `other`.\n-            \/\/\/\n-            \/\/\/ This is equivalent to using the `&` operator (e.g.\n-            \/\/\/ [`ops::BitAnd`]), as in `flags & other`.\n-            \/\/\/\n-            \/\/\/ [`ops::BitAnd`]: https:\/\/doc.rust-lang.org\/std\/ops\/trait.BitAnd.html\n-            #[inline]\n-            #[must_use]\n-            pub const fn intersection(self, other: Self) -> Self {\n-                Self(self.0.intersection(other.0))\n+        impl $crate::__private::core::iter::IntoIterator for $PublicBitFlags {\n+            type Item = Self;\n+            type IntoIter = $crate::iter::Iter<$PublicBitFlags>;\n+\n+            fn into_iter(self) -> Self::IntoIter {\n+                self.iter()\n             }\n+        }\n+    };\n+}\n \n-            \/\/\/ Returns the union of between the flags in `self` and `other`.\n-            \/\/\/\n-            \/\/\/ Specifically, the returned set contains all flags which are\n-            \/\/\/ present in *either* `self` *or* `other`, including any which are\n-            \/\/\/ present in both (see [`Self::symmetric_difference`] if that\n-            \/\/\/ is undesirable).\n-            \/\/\/\n-            \/\/\/ This is equivalent to using the `|` operator (e.g.\n-            \/\/\/ [`ops::BitOr`]), as in `flags | other`.\n-            \/\/\/\n-            \/\/\/ [`ops::BitOr`]: https:\/\/doc.rust-lang.org\/std\/ops\/trait.BitOr.html\n-            #[inline]\n-            #[must_use]\n-            pub const fn union(self, other: Self) -> Self {\n-                Self(self.0.union(other.0))\n+\/\/\/ Implement traits on the public (user-facing) bitflags type.\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+macro_rules! __impl_public_bitflags_ops {\n+    ($PublicBitFlags:ident) => {\n+        impl $crate::__private::core::fmt::Binary for $PublicBitFlags {\n+            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n+                $crate::__private::core::fmt::Binary::fmt(&self.0, f)\n             }\n+        }\n \n-            \/\/\/ Returns the difference between the flags in `self` and `other`.\n-            \/\/\/\n-            \/\/\/ Specifically, the returned set contains all flags present in\n-            \/\/\/ `self`, except for the ones present in `other`.\n-            \/\/\/\n-            \/\/\/ It is also conceptually equivalent to the \"bit-clear\" operation:\n-            \/\/\/ `flags & !other` (and this syntax is also supported).\n-            \/\/\/\n-            \/\/\/ This is equivalent to using the `-` operator (e.g.\n-            \/\/\/ [`ops::Sub`]), as in `flags - other`.\n-            \/\/\/\n-            \/\/\/ [`ops::Sub`]: https:\/\/doc.rust-lang.org\/std\/ops\/trait.Sub.html\n-            #[inline]\n-            #[must_use]\n-            pub const fn difference(self, other: Self) -> Self {\n-                Self(self.0.difference(other.0))\n+        impl $crate::__private::core::fmt::Octal for $PublicBitFlags {\n+            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n+                $crate::__private::core::fmt::Octal::fmt(&self.0, f)\n             }\n+        }\n \n-            \/\/\/ Returns the [symmetric difference][sym-diff] between the flags\n-            \/\/\/ in `self` and `other`.\n-            \/\/\/\n-            \/\/\/ Specifically, the returned set contains the flags present which\n-            \/\/\/ are present in `self` or `other`, but that are not present in\n-            \/\/\/ both. Equivalently, it contains the flags present in *exactly\n-            \/\/\/ one* of the sets `self` and `other`.\n-            \/\/\/\n-            \/\/\/ This is equivalent to using the `^` operator (e.g.\n-            \/\/\/ [`ops::BitXor`]), as in `flags ^ other`.\n-            \/\/\/\n-            \/\/\/ [sym-diff]: https:\/\/en.wikipedia.org\/wiki\/Symmetric_difference\n-            \/\/\/ [`ops::BitXor`]: https:\/\/doc.rust-lang.org\/std\/ops\/trait.BitXor.html\n-            #[inline]\n-            #[must_use]\n-            pub const fn symmetric_difference(self, other: Self) -> Self {\n-                Self(self.0.symmetric_difference(other.0))\n+        impl $crate::__private::core::fmt::LowerHex for $PublicBitFlags {\n+            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n+                $crate::__private::core::fmt::LowerHex::fmt(&self.0, f)\n             }\n+        }\n \n-            \/\/\/ Returns the complement of this set of flags.\n-            \/\/\/\n-            \/\/\/ Specifically, the returned set contains all the flags which are\n-            \/\/\/ not set in `self`, but which are allowed for this type.\n-            \/\/\/\n-            \/\/\/ Alternatively, it can be thought of as the set difference\n-            \/\/\/ between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n-            \/\/\/\n-            \/\/\/ This is equivalent to using the `!` operator (e.g.\n-            \/\/\/ [`ops::Not`]), as in `!flags`.\n-            \/\/\/\n-            \/\/\/ [`Self::all()`]: Self::all\n-            \/\/\/ [`ops::Not`]: https:\/\/doc.rust-lang.org\/std\/ops\/trait.Not.html\n-            #[inline]\n-            #[must_use]\n-            pub const fn complement(self) -> Self {\n-                Self(self.0.complement())\n+        impl $crate::__private::core::fmt::UpperHex for $PublicBitFlags {\n+            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n+                $crate::__private::core::fmt::UpperHex::fmt(&self.0, f)\n             }\n         }\n \ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -271,7 +337,7 @@ macro_rules! __impl_public_bitflags {\n             \/\/\/ Adds the set of flags.\n             #[inline]\n             fn bitor_assign(&mut self, other: Self) {\n-                self.0 = self.0.union(other.0);\n+                self.0 = self.0 | other.0;\n             }\n         }\n \ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -289,7 +355,7 @@ macro_rules! __impl_public_bitflags {\n             \/\/\/ Toggles the set of flags.\n             #[inline]\n             fn bitxor_assign(&mut self, other: Self) {\n-                self.0 = self.0.symmetric_difference(other.0);\n+                self.0 = self.0 ^ other.0\n             }\n         }\n \ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -307,7 +373,7 @@ macro_rules! __impl_public_bitflags {\n             \/\/\/ Disables all flags disabled in the set.\n             #[inline]\n             fn bitand_assign(&mut self, other: Self) {\n-                self.0 = self.0.intersection(other.0);\n+                self.0 = self.0 & other.0;\n             }\n         }\n \ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -325,7 +391,7 @@ macro_rules! __impl_public_bitflags {\n             \/\/\/ Disables all flags enabled in the set.\n             #[inline]\n             fn sub_assign(&mut self, other: Self) {\n-                self.0 = self.0.difference(other.0);\n+                self.0 = self.0 & !other.0;\n             }\n         }\n \ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -356,92 +422,6 @@ macro_rules! __impl_public_bitflags {\n                 result\n             }\n         }\n-\n-        impl $crate::__private::core::iter::IntoIterator for $PublicBitFlags {\n-            type Item = Self;\n-            type IntoIter = $Iter;\n-\n-            fn into_iter(self) -> Self::IntoIter {\n-                self.0.iter()\n-            }\n-        }\n-\n-        impl $crate::BitFlags for $PublicBitFlags {\n-            type Bits = $T;\n-\n-            type Iter = $Iter;\n-            type IterNames = $IterNames;\n-\n-            fn empty() -> Self {\n-                $PublicBitFlags::empty()\n-            }\n-\n-            fn all() -> Self {\n-                $PublicBitFlags::all()\n-            }\n-\n-            fn bits(&self) -> $T {\n-                $PublicBitFlags::bits(self)\n-            }\n-\n-            fn from_bits(bits: $T) -> $crate::__private::core::option::Option<$PublicBitFlags> {\n-                $PublicBitFlags::from_bits(bits)\n-            }\n-\n-            fn from_bits_truncate(bits: $T) -> $PublicBitFlags {\n-                $PublicBitFlags::from_bits_truncate(bits)\n-            }\n-\n-            fn from_bits_retain(bits: $T) -> $PublicBitFlags {\n-                $PublicBitFlags::from_bits_retain(bits)\n-            }\n-\n-            fn from_name(name: &str) -> $crate::__private::core::option::Option<$PublicBitFlags> {\n-                $PublicBitFlags::from_name(name)\n-            }\n-\n-            fn iter(&self) -> Self::Iter {\n-                $PublicBitFlags::iter(self)\n-            }\n-\n-            fn iter_names(&self) -> Self::IterNames {\n-                $PublicBitFlags::iter_names(self)\n-            }\n-\n-            fn is_empty(&self) -> bool {\n-                $PublicBitFlags::is_empty(self)\n-            }\n-\n-            fn is_all(&self) -> bool {\n-                $PublicBitFlags::is_all(self)\n-            }\n-\n-            fn intersects(&self, other: $PublicBitFlags) -> bool {\n-                $PublicBitFlags::intersects(self, other)\n-            }\n-\n-            fn contains(&self, other: $PublicBitFlags) -> bool {\n-                $PublicBitFlags::contains(self, other)\n-            }\n-\n-            fn insert(&mut self, other: $PublicBitFlags) {\n-                $PublicBitFlags::insert(self, other)\n-            }\n-\n-            fn remove(&mut self, other: $PublicBitFlags) {\n-                $PublicBitFlags::remove(self, other)\n-            }\n-\n-            fn toggle(&mut self, other: $PublicBitFlags) {\n-                $PublicBitFlags::toggle(self, other)\n-            }\n-\n-            fn set(&mut self, other: $PublicBitFlags, value: bool) {\n-                $PublicBitFlags::set(self, other, value)\n-            }\n-        }\n-\n-        impl $crate::__private::ImplementedByBitFlagsMacro for $PublicBitFlags {}\n     };\n }\n \ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -450,7 +430,7 @@ macro_rules! __impl_public_bitflags {\n #[doc(hidden)]\n macro_rules! __impl_public_bitflags_consts {\n     (\n-        $PublicBitFlags:ident {\n+        $PublicBitFlags:ident: $T:ty {\n             $(\n                 $(#[$attr:ident $($args:tt)*])*\n                 $Flag:ident = $value:expr;\ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -460,8 +440,39 @@ macro_rules! __impl_public_bitflags_consts {\n         impl $PublicBitFlags {\n             $(\n                 $(#[$attr $($args)*])*\n+                #[allow(\n+                    deprecated,\n+                    non_upper_case_globals,\n+                )]\n                 pub const $Flag: Self = Self::from_bits_retain($value);\n             )*\n         }\n+\n+        impl $crate::Flags for $PublicBitFlags {\n+            const FLAGS: &'static [$crate::Flag<$PublicBitFlags>] = &[\n+                $(\n+                    __bitflags_expr_safe_attrs!(\n+                        $(#[$attr $($args)*])*\n+                        {\n+                            #[allow(\n+                                deprecated,\n+                                non_upper_case_globals,\n+                            )]\n+                            $crate::Flag::new($crate::__private::core::stringify!($Flag), $PublicBitFlags::$Flag)\n+                        }\n+                    ),\n+                )*\n+            ];\n+\n+            type Bits = $T;\n+\n+            fn bits(&self) -> $T {\n+                $PublicBitFlags::bits(self)\n+            }\n+\n+            fn from_bits_retain(bits: $T) -> $PublicBitFlags {\n+                $PublicBitFlags::from_bits_retain(bits)\n+            }\n+        }\n     };\n }\ndiff --git a\/src\/traits.rs b\/src\/traits.rs\n--- a\/src\/traits.rs\n+++ b\/src\/traits.rs\n@@ -1,23 +1,50 @@\n-use core::ops::{BitAnd, BitAndAssign, BitOr, BitOrAssign, BitXor, BitXorAssign, Not};\n+use core::{fmt, ops::{BitAnd, BitOr, BitXor, Not}};\n \n-\/\/\/ A trait that is automatically implemented for all bitflags.\n-\/\/\/\n-\/\/\/ It should not be implemented manually.\n-pub trait BitFlags: ImplementedByBitFlagsMacro {\n-    \/\/\/ The underlying integer type.\n-    type Bits: Bits;\n+use crate::{parser::{ParseError, ParseHex, WriteHex}, iter};\n \n-    \/\/\/ An iterator over enabled flags in an instance of the type.\n-    type Iter: Iterator<Item = Self>;\n+\/\/\/ Metadata for an individual flag.\n+pub struct Flag<B> {\n+    name: &'static str,\n+    value: B,\n+}\n \n-    \/\/\/ An iterator over the raw names and bits for enabled flags in an instance of the type.\n-    type IterNames: Iterator<Item = (&'static str, Self)>;\n+impl<B> Flag<B> {\n+    \/\/\/ Create a new flag with the given name and value.\n+    pub const fn new(name: &'static str, value: B) -> Self {\n+        Flag { name, value }\n+    }\n+\n+    \/\/\/ Get the name of this flag.\n+    pub const fn name(&self) -> &'static str {\n+        self.name\n+    }\n+\n+    \/\/\/ Get the value of this flag.\n+    pub const fn value(&self) -> &B {\n+        &self.value\n+    }\n+}\n+\n+\/\/\/ A set of flags.\n+\/\/\/\n+\/\/\/ This trait is automatically implemented for flags types defined using the `bitflags!` macro.\n+\/\/\/ It can also be implemented manually for custom flags types.\n+pub trait Flags: Sized + 'static {\n+    \/\/\/ The set of available flags and their names.\n+    const FLAGS: &'static [Flag<Self>];\n+\n+    \/\/\/ The underlying storage type.\n+    type Bits: Bits;\n \n     \/\/\/ Returns an empty set of flags.\n-    fn empty() -> Self;\n+    fn empty() -> Self {\n+        Self::from_bits_retain(Self::Bits::EMPTY)\n+    }\n \n     \/\/\/ Returns the set containing all flags.\n-    fn all() -> Self;\n+    fn all() -> Self {\n+        Self::from_bits_truncate(Self::Bits::ALL)\n+    }\n \n     \/\/\/ Returns the raw value of the flags currently stored.\n     fn bits(&self) -> Self::Bits;\ndiff --git a\/src\/traits.rs b\/src\/traits.rs\n--- a\/src\/traits.rs\n+++ b\/src\/traits.rs\n@@ -28,9 +55,15 @@ pub trait BitFlags: ImplementedByBitFlagsMacro {\n     \/\/\/ Note that each [multi-bit flag] is treated as a unit for this comparison.\n     \/\/\/\n     \/\/\/ [multi-bit flag]: index.html#multi-bit-flags\n-    fn from_bits(bits: Self::Bits) -> Option<Self>\n-    where\n-        Self: Sized;\n+    fn from_bits(bits: Self::Bits) -> Option<Self> {\n+        let truncated = Self::from_bits_truncate(bits);\n+\n+        if truncated.bits() == bits {\n+            Some(truncated)\n+        } else {\n+            None\n+        }\n+    }\n \n     \/\/\/ Convert from underlying bit representation, dropping any bits\n     \/\/\/ that do not correspond to flags.\ndiff --git a\/src\/traits.rs b\/src\/traits.rs\n--- a\/src\/traits.rs\n+++ b\/src\/traits.rs\n@@ -38,81 +71,181 @@ pub trait BitFlags: ImplementedByBitFlagsMacro {\n     \/\/\/ Note that each [multi-bit flag] is treated as a unit for this comparison.\n     \/\/\/\n     \/\/\/ [multi-bit flag]: index.html#multi-bit-flags\n-    fn from_bits_truncate(bits: Self::Bits) -> Self;\n+    fn from_bits_truncate(bits: Self::Bits) -> Self {\n+        if bits == Self::Bits::EMPTY {\n+            return Self::empty();\n+        }\n+\n+        let mut truncated = Self::Bits::EMPTY;\n+\n+        for flag in Self::FLAGS.iter() {\n+            let flag = flag.value();\n+\n+            if bits & flag.bits() == flag.bits() {\n+                truncated = truncated | flag.bits();\n+            }\n+        }\n+\n+        Self::from_bits_retain(truncated)\n+    }\n \n     \/\/\/ Convert from underlying bit representation, preserving all\n     \/\/\/ bits (even those not corresponding to a defined flag).\n     fn from_bits_retain(bits: Self::Bits) -> Self;\n \n     \/\/\/ Get the flag for a particular name.\n-    fn from_name(name: &str) -> Option<Self>\n-    where\n-        Self: Sized;\n+    fn from_name(name: &str) -> Option<Self> {\n+        for flag in Self::FLAGS {\n+            if flag.name() == name {\n+                return Some(Self::from_bits_retain(flag.value().bits()))\n+            }\n+        }\n+\n+        None\n+    }\n \n     \/\/\/ Iterate over enabled flag values.\n-    fn iter(&self) -> Self::Iter;\n+    fn iter(&self) -> iter::Iter<Self> {\n+        iter::Iter::new(self)\n+    }\n \n     \/\/\/ Iterate over the raw names and bits for enabled flag values.\n-    fn iter_names(&self) -> Self::IterNames;\n+    fn iter_names(&self) -> iter::IterNames<Self> {\n+        iter::IterNames::new(self)\n+    }\n \n     \/\/\/ Returns `true` if no flags are currently stored.\n-    fn is_empty(&self) -> bool;\n+    fn is_empty(&self) -> bool {\n+        self.bits() == Self::Bits::EMPTY\n+    }\n \n     \/\/\/ Returns `true` if all flags are currently set.\n-    fn is_all(&self) -> bool;\n+    fn is_all(&self) -> bool {\n+        \/\/ NOTE: We check against `Self::all` here, not `Self::Bits::ALL`\n+        \/\/ because the set of all flags may not use all bits\n+        Self::all().bits() | self.bits() == self.bits()\n+    }\n \n     \/\/\/ Returns `true` if there are flags common to both `self` and `other`.\n-    fn intersects(&self, other: Self) -> bool;\n+    fn intersects(&self, other: Self) -> bool\n+    where\n+        Self: Sized,\n+    {\n+        self.bits() & other.bits() != Self::Bits::EMPTY\n+    }\n \n     \/\/\/ Returns `true` if all of the flags in `other` are contained within `self`.\n-    fn contains(&self, other: Self) -> bool;\n+    fn contains(&self, other: Self) -> bool\n+    where\n+        Self: Sized,\n+    {\n+        self.bits() & other.bits() == other.bits()\n+    }\n \n     \/\/\/ Inserts the specified flags in-place.\n-    fn insert(&mut self, other: Self);\n+    fn insert(&mut self, other: Self)\n+    where\n+        Self: Sized,\n+    {\n+        *self = Self::from_bits_retain(self.bits() | other.bits());\n+    }\n \n     \/\/\/ Removes the specified flags in-place.\n-    fn remove(&mut self, other: Self);\n+    fn remove(&mut self, other: Self)\n+    where\n+        Self: Sized,\n+    {\n+        *self = Self::from_bits_retain(self.bits() & !other.bits());\n+    }\n \n     \/\/\/ Toggles the specified flags in-place.\n-    fn toggle(&mut self, other: Self);\n+    fn toggle(&mut self, other: Self)\n+    where\n+        Self: Sized,\n+    {\n+        *self = Self::from_bits_retain(self.bits() ^ other.bits());\n+    }\n \n     \/\/\/ Inserts or removes the specified flags depending on the passed value.\n-    fn set(&mut self, other: Self, value: bool);\n-}\n+    fn set(&mut self, other: Self, value: bool)\n+    where\n+        Self: Sized,\n+    {\n+        if value {\n+            self.insert(other);\n+        } else {\n+            self.remove(other);\n+        }\n+    }\n \n-\/\/\/ A marker trait that signals that an implementation of `BitFlags` came from the `bitflags!` macro.\n-\/\/\/\n-\/\/\/ There's nothing stopping an end-user from implementing this trait, but we don't guarantee their\n-\/\/\/ manual implementations won't break between non-breaking releases.\n-#[doc(hidden)]\n-pub trait ImplementedByBitFlagsMacro {}\n+    \/\/\/ Returns the intersection between the flags in `self` and\n+    \/\/\/ `other`.\n+    \/\/\/\n+    \/\/\/ Specifically, the returned set contains only the flags which are\n+    \/\/\/ present in *both* `self` *and* `other`.\n+    #[must_use]\n+    fn intersection(self, other: Self) -> Self {\n+        Self::from_bits_retain(self.bits() & other.bits())\n+    }\n \n-\/\/ Not re-exported\n-pub trait Sealed {}\n+    \/\/\/ Returns the union of between the flags in `self` and `other`.\n+    \/\/\/\n+    \/\/\/ Specifically, the returned set contains all flags which are\n+    \/\/\/ present in *either* `self` *or* `other`, including any which are\n+    \/\/\/ present in both (see [`Self::symmetric_difference`] if that\n+    \/\/\/ is undesirable).\n+    #[must_use]\n+    fn union(self, other: Self) -> Self {\n+        Self::from_bits_retain(self.bits() | other.bits())\n+    }\n \n-\/\/ Private implementation details\n-\/\/\n-\/\/ The `Bits`, `PublicFlags`, and `InternalFlags` traits are implementation details of the `bitflags!`\n-\/\/ macro that we're free to change here. They work with the `bitflags!` macro to separate the generated\n-\/\/ code that belongs to end-users, and the generated code that belongs to this library.\n+    \/\/\/ Returns the difference between the flags in `self` and `other`.\n+    \/\/\/\n+    \/\/\/ Specifically, the returned set contains all flags present in\n+    \/\/\/ `self`, except for the ones present in `other`.\n+    \/\/\/\n+    \/\/\/ It is also conceptually equivalent to the \"bit-clear\" operation:\n+    \/\/\/ `flags & !other` (and this syntax is also supported).\n+    #[must_use]\n+    fn difference(self, other: Self) -> Self {\n+        Self::from_bits_retain(self.bits() & !other.bits())\n+    }\n \n-\/\/\/ A private trait that encodes the requirements of underlying bits types that can hold flags.\n-\/\/\/\n-\/\/\/ This trait may be made public at some future point, but it presents a compatibility hazard\n-\/\/\/ so is left internal for now.\n-#[doc(hidden)]\n+    \/\/\/ Returns the [symmetric difference][sym-diff] between the flags\n+    \/\/\/ in `self` and `other`.\n+    \/\/\/\n+    \/\/\/ Specifically, the returned set contains the flags present which\n+    \/\/\/ are present in `self` or `other`, but that are not present in\n+    \/\/\/ both. Equivalently, it contains the flags present in *exactly\n+    \/\/\/ one* of the sets `self` and `other`.\n+    \/\/\/\n+    \/\/\/ [sym-diff]: https:\/\/en.wikipedia.org\/wiki\/Symmetric_difference\n+    #[must_use]\n+    fn symmetric_difference(self, other: Self) -> Self {\n+        Self::from_bits_retain(self.bits() ^ other.bits())\n+    }\n+\n+    \/\/\/ Returns the complement of this set of flags.\n+    \/\/\/\n+    \/\/\/ Specifically, the returned set contains all the flags which are\n+    \/\/\/ not set in `self`, but which are allowed for this type.\n+    #[must_use]\n+    fn complement(self) -> Self {\n+        Self::from_bits_truncate(!self.bits())\n+    }\n+}\n+\n+\/\/\/ Underlying storage for a flags type.\n pub trait Bits:\n     Clone\n     + Copy\n-    + BitAnd\n-    + BitAndAssign\n-    + BitOr\n-    + BitOrAssign\n-    + BitXor\n-    + BitXorAssign\n-    + Not\n+    + PartialEq\n+    + BitAnd<Output = Self>\n+    + BitOr<Output = Self>\n+    + BitXor<Output = Self>\n+    + Not<Output = Self>\n     + Sized\n-    + Sealed\n+    + 'static\n {\n     \/\/\/ The value of `Self` where no bits are set.\n     const EMPTY: Self;\ndiff --git a\/src\/traits.rs b\/src\/traits.rs\n--- a\/src\/traits.rs\n+++ b\/src\/traits.rs\n@@ -121,6 +254,10 @@ pub trait Bits:\n     const ALL: Self;\n }\n \n+\/\/ Not re-exported: prevent custom `Bits` impls being used in the `bitflags!` macro,\n+\/\/ or they may fail to compile based on crate features\n+pub trait Primitive {}\n+\n macro_rules! impl_bits {\n     ($($u:ty, $i:ty,)*) => {\n         $(\ndiff --git a\/src\/traits.rs b\/src\/traits.rs\n--- a\/src\/traits.rs\n+++ b\/src\/traits.rs\n@@ -134,8 +271,32 @@ macro_rules! impl_bits {\n                 const ALL: $i = <$u>::MAX as $i;\n             }\n \n-            impl Sealed for $u {}\n-            impl Sealed for $i {}\n+            impl ParseHex for $u {\n+                fn parse_hex(input: &str) -> Result<Self, ParseError> {\n+                    <$u>::from_str_radix(input, 16).map_err(|_| ParseError::invalid_hex_flag(input))\n+                }\n+            }\n+\n+            impl ParseHex for $i {\n+                fn parse_hex(input: &str) -> Result<Self, ParseError> {\n+                    <$i>::from_str_radix(input, 16).map_err(|_| ParseError::invalid_hex_flag(input))\n+                }\n+            }\n+\n+            impl WriteHex for $u {\n+                fn write_hex<W: fmt::Write>(&self, mut writer: W) -> fmt::Result {\n+                    write!(writer, \"{:x}\", self)\n+                }\n+            }\n+\n+            impl WriteHex for $i {\n+                fn write_hex<W: fmt::Write>(&self, mut writer: W) -> fmt::Result {\n+                    write!(writer, \"{:x}\", self)\n+                }\n+            }\n+\n+            impl Primitive for $i {}\n+            impl Primitive for $u {}\n         )*\n     }\n }\ndiff --git a\/src\/traits.rs b\/src\/traits.rs\n--- a\/src\/traits.rs\n+++ b\/src\/traits.rs\n@@ -152,6 +313,37 @@ impl_bits! {\n \/\/\/ A trait for referencing the `bitflags`-owned internal type\n \/\/\/ without exposing it publicly.\n pub trait PublicFlags {\n+    \/\/\/ The type of the underlying storage.\n+    type Primitive: Primitive;\n+\n     \/\/\/ The type of the internal field on the generated flags type.\n     type Internal;\n }\n+\n+#[deprecated(note = \"use the `Flags` trait instead\")]\n+pub trait BitFlags: ImplementedByBitFlagsMacro + Flags {\n+    \/\/\/ An iterator over enabled flags in an instance of the type.\n+    type Iter: Iterator<Item = Self>;\n+\n+    \/\/\/ An iterator over the raw names and bits for enabled flags in an instance of the type.\n+    type IterNames: Iterator<Item = (&'static str, Self)>;\n+}\n+\n+#[allow(deprecated)]\n+impl<B: Flags> BitFlags for B {\n+    type Iter = iter::Iter<Self>;\n+    type IterNames = iter::IterNames<Self>;\n+}\n+\n+impl<B: Flags> ImplementedByBitFlagsMacro for B {}\n+\n+\/\/\/ A marker trait that signals that an implementation of `BitFlags` came from the `bitflags!` macro.\n+\/\/\/\n+\/\/\/ There's nothing stopping an end-user from implementing this trait, but we don't guarantee their\n+\/\/\/ manual implementations won't break between non-breaking releases.\n+#[doc(hidden)]\n+pub trait ImplementedByBitFlagsMacro {}\n+\n+pub(crate) mod __private {\n+    pub use super::{ImplementedByBitFlagsMacro, PublicFlags};\n+}\n","version":"2.2","repo":"bitflags\/bitflags","environment_setup_commit":"1d8388bf4ce18afde846d220ad8b6e0dc40aae94"}
{"problem_statement":"Debug formatting leads to less desireable output\n[Link to rust playground](https:\/\/play.rust-lang.org\/?version=stable&mode=debug&edition=2018&code=%23%5Bmacro_use%5D%0Aextern%20crate%20bitflags%3B%0A%0Abitflags!%20%7B%0A%20%20%20%20struct%20Flags%3A%20u32%20%7B%0A%20%20%20%20%20%20%20%20const%20A%20%3D%200b00000001%3B%0A%20%20%20%20%20%20%20%20const%20B%20%3D%200b00000010%3B%0A%20%20%20%20%20%20%20%20const%20C%20%3D%200b00000100%3B%0A%20%20%20%20%20%20%20%20const%20ABC%20%3D%20Self%3A%3AA.bits%20%7C%20Self%3A%3AB.bits%20%7C%20Self%3A%3AC.bits%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20Flags%3A%3AA%20%7C%20Flags%3A%3AB%20%7C%20Flags%3A%3AC%20)%3B%0A%7D)\r\n\r\n```rust\r\n#[macro_use]\r\nextern crate bitflags;\r\n\r\nbitflags! {\r\n    struct Flags: u32 {\r\n        const A = 0b00000001;\r\n        const B = 0b00000010;\r\n        const C = 0b00000100;\r\n        const ABC = Self::A.bits | Self::B.bits | Self::C.bits;\r\n    }\r\n}\r\n\r\nfn main() {\r\n    println!(\"{:?}\", Flags::A | Flags::B | Flags::C );\r\n}\r\n```\r\n\r\nprints:\r\n\r\n```bash\r\nA | B | C | ABC\r\n```\r\n\r\nI find it somewhat less helpful that both the expanded (`A | B | C`) and \"compressed\" form (`ABC`) are reported...\r\n\r\nIs there a reason behind this? Is this considered more correct for some reason?\n","test_patch":"diff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -1353,7 +1321,10 @@ mod tests {\n         assert_eq!(UNION, Flags::A | Flags::C);\n         assert_eq!(DIFFERENCE, Flags::all() - Flags::A);\n         assert_eq!(COMPLEMENT, !Flags::C);\n-        assert_eq!(SYM_DIFFERENCE, (Flags::A | Flags::C) ^ (Flags::all() - Flags::A));\n+        assert_eq!(\n+            SYM_DIFFERENCE,\n+            (Flags::A | Flags::C) ^ (Flags::all() - Flags::A)\n+        );\n     }\n \n     #[test]\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -1609,13 +1580,15 @@ mod tests {\n         assert_eq!(format!(\"{:?}\", Flags::A | Flags::B), \"A | B\");\n         assert_eq!(format!(\"{:?}\", Flags::empty()), \"(empty)\");\n         assert_eq!(format!(\"{:?}\", Flags::ABC), \"A | B | C\");\n+\n         let extra = unsafe { Flags::from_bits_unchecked(0xb8) };\n+\n         assert_eq!(format!(\"{:?}\", extra), \"0xb8\");\n         assert_eq!(format!(\"{:?}\", Flags::A | extra), \"A | 0xb8\");\n \n         assert_eq!(\n             format!(\"{:?}\", Flags::ABC | extra),\n-            \"A | B | C | 0xb8\"\n+            \"A | B | C | ABC | 0xb8\"\n         );\n \n         assert_eq!(format!(\"{:?}\", EmptyFlags::empty()), \"(empty)\");\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -1830,7 +1803,8 @@ mod tests {\n     fn test_serde_bitflags_roundtrip() {\n         let flags = SerdeFlags::A | SerdeFlags::B;\n \n-        let deserialized: SerdeFlags = serde_json::from_str(&serde_json::to_string(&flags).unwrap()).unwrap();\n+        let deserialized: SerdeFlags =\n+            serde_json::from_str(&serde_json::to_string(&flags).unwrap()).unwrap();\n \n         assert_eq!(deserialized.bits, flags.bits);\n     }\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -1854,7 +1828,6 @@ mod tests {\n             }\n         }\n \n-\n         let flags = Flags::from_bits(0b00000100);\n         assert_eq!(flags, None);\n         let flags = Flags::from_bits(0b00000101);\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -1875,7 +1848,7 @@ mod tests {\n         let flags = Flags::from_bits_truncate(0b00000101);\n         assert_eq!(flags, Flags::A);\n     }\n-  \n+\n     #[test]\n     fn test_iter() {\n         bitflags! {\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -1887,24 +1860,31 @@ mod tests {\n                 const FOUR_WIN = 0b1000;\n                 #[cfg(unix)]\n                 const FOUR_UNIX = 0b10000;\n+                const FIVE = 0b01000100;\n             }\n         }\n \n         let count = {\n             #[cfg(any(unix, windows))]\n             {\n-                4\n+                5\n             }\n \n             #[cfg(not(any(unix, windows)))]\n             {\n-                3\n+                4\n             }\n         };\n \n         let flags = Flags::all();\n         assert_eq!(flags.iter().count(), count);\n+\n+        for (_, flag) in flags.iter() {\n+            assert!(flags.contains(flag));\n+        }\n+\n         let mut iter = flags.iter();\n+\n         assert_eq!(iter.next().unwrap(), (\"ONE\", Flags::ONE));\n         assert_eq!(iter.next().unwrap(), (\"TWO\", Flags::TWO));\n         assert_eq!(iter.next().unwrap(), (\"THREE\", Flags::THREE));\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -1918,6 +1898,8 @@ mod tests {\n             assert_eq!(iter.next().unwrap(), (\"FOUR_WIN\", Flags::FOUR_WIN));\n         }\n \n+        assert_eq!(iter.next().unwrap(), (\"FIVE\", Flags::FIVE));\n+\n         assert_eq!(iter.next(), None);\n \n         let flags = Flags::empty();\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -1925,7 +1907,9 @@ mod tests {\n \n         let flags = Flags::ONE | Flags::THREE;\n         assert_eq!(flags.iter().count(), 2);\n+\n         let mut iter = flags.iter();\n+\n         assert_eq!(iter.next().unwrap(), (\"ONE\", Flags::ONE));\n         assert_eq!(iter.next().unwrap(), (\"THREE\", Flags::THREE));\n         assert_eq!(iter.next(), None);\ndiff --git a\/tests\/compile-fail\/cfg\/multi.stderr \/dev\/null\n--- a\/tests\/compile-fail\/cfg\/multi.stderr\n+++ \/dev\/null\n@@ -1,17 +0,0 @@\n-error[E0428]: the name `FOO` is defined multiple times\n-  --> tests\/compile-fail\/cfg\/multi.rs:6:1\n-   |\n-6  | \/ bitflags! {\n-7  | |     pub struct Flags: u32 {\n-8  | |         #[cfg(target_os = \"linux\")]\n-9  | |         const FOO = 1;\n-...  |\n-12 | |     }\n-13 | | }\n-   | | ^\n-   | | |\n-   | |_`FOO` redefined here\n-   |   previous definition of the value `FOO` here\n-   |\n-   = note: `FOO` must be defined only once in the value namespace of this trait\n-   = note: this error originates in the macro `__impl_all_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\ndiff --git a\/tests\/compile-fail\/non_integer_base\/all_defined.stderr b\/tests\/compile-fail\/non_integer_base\/all_defined.stderr\n--- a\/tests\/compile-fail\/non_integer_base\/all_defined.stderr\n+++ b\/tests\/compile-fail\/non_integer_base\/all_defined.stderr\n@@ -1,22 +1,16 @@\n-error[E0308]: mismatched types\n-   --> tests\/compile-fail\/non_integer_base\/all_defined.rs:115:1\n+error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n+   --> tests\/compile-fail\/non_integer_base\/all_defined.rs:116:22\n     |\n-115 | \/ bitflags! {\n-116 | |     struct Flags128: MyInt {\n-117 | |         const A = MyInt(0b0000_0001u8);\n-118 | |         const B = MyInt(0b0000_0010u8);\n-119 | |         const C = MyInt(0b0000_0100u8);\n-120 | |     }\n-121 | | }\n-    | |_^ expected struct `MyInt`, found integer\n+116 |     struct Flags128: MyInt {\n+    |                      ^^^^^ the trait `Bits` is not implemented for `MyInt`\n     |\n-    = note: this error originates in the macro `__impl_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-help: try wrapping the expression in `MyInt`\n+note: required by a bound in `bitflags::BitFlags::Bits`\n+   --> src\/bitflags_trait.rs\n     |\n-458 |                 if extra_bits != MyInt(0) {\n-    |                                  ++++++ +\n+    |     type Bits: Bits;\n+    |                ^^^^ required by this bound in `bitflags::BitFlags::Bits`\n \n-error[E0308]: mismatched types\n+error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n    --> tests\/compile-fail\/non_integer_base\/all_defined.rs:115:1\n     |\n 115 | \/ bitflags! {\ndiff --git a\/tests\/compile-fail\/non_integer_base\/all_defined.stderr b\/tests\/compile-fail\/non_integer_base\/all_defined.stderr\n--- a\/tests\/compile-fail\/non_integer_base\/all_defined.stderr\n+++ b\/tests\/compile-fail\/non_integer_base\/all_defined.stderr\n@@ -26,15 +20,11 @@ error[E0308]: mismatched types\n 119 | |         const C = MyInt(0b0000_0100u8);\n 120 | |     }\n 121 | | }\n-    | |_^ expected struct `MyInt`, found integer\n+    | |_^ the trait `Bits` is not implemented for `MyInt`\n     |\n     = note: this error originates in the macro `__impl_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-help: try wrapping the expression in `MyInt`\n-    |\n-508 |                 Self { bits: MyInt(0) }\n-    |                              ++++++ +\n \n-error[E0308]: mismatched types\n+error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n    --> tests\/compile-fail\/non_integer_base\/all_defined.rs:115:1\n     |\n 115 | \/ bitflags! {\ndiff --git a\/tests\/compile-fail\/non_integer_base\/all_defined.stderr b\/tests\/compile-fail\/non_integer_base\/all_defined.stderr\n--- a\/tests\/compile-fail\/non_integer_base\/all_defined.stderr\n+++ b\/tests\/compile-fail\/non_integer_base\/all_defined.stderr\n@@ -44,15 +34,11 @@ error[E0308]: mismatched types\n 119 | |         const C = MyInt(0b0000_0100u8);\n 120 | |     }\n 121 | | }\n-    | |_^ expected struct `MyInt`, found integer\n+    | |_^ the trait `Bits` is not implemented for `MyInt`\n     |\n     = note: this error originates in the macro `__impl_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-help: try wrapping the expression in `MyInt`\n-    |\n-546 |                 if bits == MyInt(0) {\n-    |                            ++++++ +\n \n-error[E0277]: no implementation for `{integer} |= MyInt`\n+error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n    --> tests\/compile-fail\/non_integer_base\/all_defined.rs:115:1\n     |\n 115 | \/ bitflags! {\ndiff --git a\/tests\/compile-fail\/non_integer_base\/all_defined.stderr b\/tests\/compile-fail\/non_integer_base\/all_defined.stderr\n--- a\/tests\/compile-fail\/non_integer_base\/all_defined.stderr\n+++ b\/tests\/compile-fail\/non_integer_base\/all_defined.stderr\n@@ -62,12 +48,11 @@ error[E0277]: no implementation for `{integer} |= MyInt`\n 119 | |         const C = MyInt(0b0000_0100u8);\n 120 | |     }\n 121 | | }\n-    | |_^ no implementation for `{integer} |= MyInt`\n+    | |_^ the trait `Bits` is not implemented for `MyInt`\n     |\n-    = help: the trait `BitOrAssign<MyInt>` is not implemented for `{integer}`\n     = note: this error originates in the macro `__impl_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error[E0308]: mismatched types\n+error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n    --> tests\/compile-fail\/non_integer_base\/all_defined.rs:115:1\n     |\n 115 | \/ bitflags! {\ndiff --git a\/tests\/compile-fail\/non_integer_base\/all_defined.stderr b\/tests\/compile-fail\/non_integer_base\/all_defined.stderr\n--- a\/tests\/compile-fail\/non_integer_base\/all_defined.stderr\n+++ b\/tests\/compile-fail\/non_integer_base\/all_defined.stderr\n@@ -77,28 +62,6 @@ error[E0308]: mismatched types\n 119 | |         const C = MyInt(0b0000_0100u8);\n 120 | |     }\n 121 | | }\n-    | |_^ expected struct `MyInt`, found integer\n+    | |_^ the trait `Bits` is not implemented for `MyInt`\n     |\n     = note: this error originates in the macro `__impl_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-help: try wrapping the expression in `MyInt`\n-    |\n-561 |                 Self { bits: MyInt(truncated) }\n-    |                              ++++++         +\n-\n-error[E0308]: mismatched types\n-   --> tests\/compile-fail\/non_integer_base\/all_defined.rs:115:1\n-    |\n-115 | \/ bitflags! {\n-116 | |     struct Flags128: MyInt {\n-117 | |         const A = MyInt(0b0000_0001u8);\n-118 | |         const B = MyInt(0b0000_0010u8);\n-119 | |         const C = MyInt(0b0000_0100u8);\n-120 | |     }\n-121 | | }\n-    | |_^ expected struct `MyInt`, found integer\n-    |\n-    = note: this error originates in the macro `__impl_all_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-help: try wrapping the expression in `MyInt`\n-    |\n-409 |                 const $Flag: $T = MyInt(0);\n-    |                                   ++++++ +\ndiff --git a\/tests\/compile-fail\/trait\/custom_impl.stderr b\/tests\/compile-fail\/trait\/custom_impl.stderr\n--- a\/tests\/compile-fail\/trait\/custom_impl.stderr\n+++ b\/tests\/compile-fail\/trait\/custom_impl.stderr\n@@ -1,11 +1,11 @@\n error[E0277]: the trait bound `BootlegFlags: ImplementedByBitFlagsMacro` is not satisfied\n- --> $DIR\/custom_impl.rs:5:6\n+ --> tests\/compile-fail\/trait\/custom_impl.rs:5:6\n   |\n 5 | impl BitFlags for BootlegFlags {\n   |      ^^^^^^^^ the trait `ImplementedByBitFlagsMacro` is not implemented for `BootlegFlags`\n   |\n note: required by a bound in `BitFlags`\n- --> $DIR\/bitflags_trait.rs:7:21\n+ --> src\/bitflags_trait.rs\n   |\n-7 | pub trait BitFlags: ImplementedByBitFlagsMacro {\n+  | pub trait BitFlags: ImplementedByBitFlagsMacro {\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `BitFlags`\ndiff --git a\/tests\/compile-fail\/cfg\/multi.rs b\/tests\/compile-pass\/cfg\/redefined-value.rs\n--- a\/tests\/compile-fail\/cfg\/multi.rs\n+++ b\/tests\/compile-pass\/cfg\/redefined-value.rs\n@@ -1,12 +1,11 @@\n #[macro_use]\n extern crate bitflags;\n \n-\/\/ NOTE: Ideally this would work, but our treatment of CFGs\n-\/\/ assumes flags may be missing but not redefined\n bitflags! {\n     pub struct Flags: u32 {\n         #[cfg(target_os = \"linux\")]\n         const FOO = 1;\n+\n         #[cfg(not(target_os = \"linux\"))]\n         const FOO = 2;\n     }\ndiff --git a\/tests\/compile-fail\/cfg\/multi.rs b\/tests\/compile-pass\/cfg\/redefined-value.rs\n--- a\/tests\/compile-fail\/cfg\/multi.rs\n+++ b\/tests\/compile-pass\/cfg\/redefined-value.rs\n@@ -20,6 +19,6 @@ fn main() {\n \n     #[cfg(not(target_os = \"linux\"))]\n     {\n-        assert_eq!(1, Flags::FOO.bits());\n+        assert_eq!(2, Flags::FOO.bits());\n     }\n }\ndiff --git \/dev\/null b\/tests\/compile-pass\/deprecated.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/tests\/compile-pass\/deprecated.rs\n@@ -0,0 +1,14 @@\n+#![deny(warnings)]\n+\n+#[macro_use]\n+extern crate bitflags;\n+\n+bitflags! {\n+    pub struct Flags: u32 {\n+        #[deprecated = \"Use something else\"]\n+        const A = 0b00000001;\n+        const B = 0b00000010;\n+    }\n+}\n+\n+fn main() {}\ndiff --git \/dev\/null b\/tests\/compile-pass\/non_snake_case.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/tests\/compile-pass\/non_snake_case.rs\n@@ -0,0 +1,13 @@\n+#![deny(warnings)]\n+\n+#[macro_use]\n+extern crate bitflags;\n+\n+bitflags! {\n+    pub struct Flags: u32 {\n+        const CamelCase = 0b00000001;\n+        const B = 0b00000010;\n+    }\n+}\n+\n+fn main() {}\n","hints_text":"I think the current algorithm used for debug output is to loop over all flags and append identifiers that correspond to set bits. I think an alternative here that could work would be to short-circuit when we\u2019ve built a format that covers all the set bits. As an implementation note we wouldn\u2019t be able to work off a single source and just mask out bits as we see them, we\u2019ll need to use the whole set of bits to see if a flag is applicable and then a second set that\u2019s masked to see when we\u2019ve catered for all set bits. Otherwise something like this wouldn\u2019t work:\r\n\r\n```\r\nconst A: 0b00000100\r\nconst B: 0b00001100\r\n\r\nlet input = B;\r\n```\r\n\r\nwe\u2019d mask out bit 3 for `A` but then have one leftover for `B` that doesn\u2019t correspond to it. In that example we\u2019d end up writing `A | B` still, but wouldn\u2019t duplicate compound identifiers the same.\r\n\r\nIn general, I\u2019m not sure if there\u2019s a reasonable algorithm that would produce the smallest possible format for any given set of bits.","base_commit":"f38ce72d11ef3e264d4b62f360bd8a5597b916d9","issue_numbers":["215"],"created_at":"2022-05-03T06:59:46Z","pull_number":281,"instance_id":"bitflags__bitflags-281","patch":"diff --git a\/src\/bitflags_trait.rs b\/src\/bitflags_trait.rs\n--- a\/src\/bitflags_trait.rs\n+++ b\/src\/bitflags_trait.rs\n@@ -1,3 +1,5 @@\n+use core::ops::{BitAnd, BitAndAssign, BitOr, BitOrAssign, BitXor, BitXorAssign, Not};\n+\n #[doc(hidden)]\n pub trait ImplementedByBitFlagsMacro {}\n \ndiff --git a\/src\/bitflags_trait.rs b\/src\/bitflags_trait.rs\n--- a\/src\/bitflags_trait.rs\n+++ b\/src\/bitflags_trait.rs\n@@ -5,7 +7,8 @@ pub trait ImplementedByBitFlagsMacro {}\n \/\/\/\n \/\/\/ It should not be implemented manually.\n pub trait BitFlags: ImplementedByBitFlagsMacro {\n-    type Bits;\n+    type Bits: Bits;\n+\n     \/\/\/ Returns an empty set of flags.\n     fn empty() -> Self;\n     \/\/\/ Returns the set containing all flags.\ndiff --git a\/src\/bitflags_trait.rs b\/src\/bitflags_trait.rs\n--- a\/src\/bitflags_trait.rs\n+++ b\/src\/bitflags_trait.rs\n@@ -15,7 +18,8 @@ pub trait BitFlags: ImplementedByBitFlagsMacro {\n     \/\/\/ Convert from underlying bit representation, unless that\n     \/\/\/ representation contains bits that do not correspond to a flag.\n     fn from_bits(bits: Self::Bits) -> Option<Self>\n-    where Self: Sized;\n+    where\n+        Self: Sized;\n     \/\/\/ Convert from underlying bit representation, dropping any bits\n     \/\/\/ that do not correspond to flags.\n     fn from_bits_truncate(bits: Self::Bits) -> Self;\ndiff --git a\/src\/bitflags_trait.rs b\/src\/bitflags_trait.rs\n--- a\/src\/bitflags_trait.rs\n+++ b\/src\/bitflags_trait.rs\n@@ -48,3 +52,58 @@ pub trait BitFlags: ImplementedByBitFlagsMacro {\n     \/\/\/ Inserts or removes the specified flags depending on the passed value.\n     fn set(&mut self, other: Self, value: bool);\n }\n+\n+\/\/ Not re-exported\n+pub trait Sealed {}\n+\n+\/\/\/ A private trait that encodes the requirements of underlying bits types that can hold flags.\n+\/\/\/\n+\/\/\/ This trait may be made public at some future point, but it presents a compatibility hazard\n+\/\/\/ so is left internal for now.\n+#[doc(hidden)]\n+pub trait Bits:\n+    Clone\n+    + Copy\n+    + BitAnd\n+    + BitAndAssign\n+    + BitOr\n+    + BitOrAssign\n+    + BitXor\n+    + BitXorAssign\n+    + Not\n+    + Sized\n+    + Sealed\n+{\n+    \/\/\/ The value of `Self` where no bits are set.\n+    const EMPTY: Self;\n+\n+    \/\/\/ The value of `Self` where all bits are set.\n+    const ALL: Self;\n+}\n+\n+macro_rules! impl_bits {\n+    ($($u:ty, $i:ty,)*) => {\n+        $(\n+            impl Bits for $u {\n+                const EMPTY: $u = 0;\n+                const ALL: $u = <$u>::MAX;\n+            }\n+\n+            impl Bits for $i {\n+                const EMPTY: $i = 0;\n+                const ALL: $i = <$u>::MAX as $i;\n+            }\n+\n+            impl Sealed for $u {}\n+            impl Sealed for $i {}\n+        )*\n+    }\n+}\n+\n+impl_bits! {\n+    u8, i8,\n+    u16, i16,\n+    u32, i32,\n+    u64, i64,\n+    u128, i128,\n+}\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -285,8 +285,8 @@ mod bitflags_trait;\n \n #[doc(hidden)]\n pub mod __private {\n+    pub use crate::bitflags_trait::{Bits, ImplementedByBitFlagsMacro};\n     pub use core;\n-    pub use crate::bitflags_trait::ImplementedByBitFlagsMacro;\n }\n \n \/\/\/ The macro used to generate the flag structure.\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -389,45 +389,6 @@ macro_rules! bitflags {\n     () => {};\n }\n \n-\/\/ A helper macro to implement the `all` function.\n-#[macro_export(local_inner_macros)]\n-#[doc(hidden)]\n-macro_rules! __impl_all_bitflags {\n-    (\n-        $BitFlags:ident: $T:ty {\n-            $(\n-                $(#[$attr:ident $($args:tt)*])*\n-                $Flag:ident = $value:expr;\n-            )+\n-        }\n-    ) => {\n-        \/\/ See `Debug::fmt` for why this approach is taken.\n-        #[allow(non_snake_case)]\n-        trait __BitFlags {\n-            $(\n-                #[allow(deprecated)]\n-                const $Flag: $T = 0;\n-            )+\n-        }\n-        #[allow(non_snake_case)]\n-        impl __BitFlags for $BitFlags {\n-            $(\n-                __impl_bitflags! {\n-                    #[allow(deprecated)]\n-                    $(? #[$attr $($args)*])*\n-                    const $Flag: $T = Self::$Flag.bits;\n-                }\n-            )+\n-        }\n-        Self { bits: $(<Self as __BitFlags>::$Flag)|+ }\n-    };\n-    (\n-        $BitFlags:ident: $T:ty { }\n-    ) => {\n-        Self { bits: 0 }\n-    };\n-}\n-\n #[macro_export(local_inner_macros)]\n #[doc(hidden)]\n macro_rules! __impl_bitflags {\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -455,7 +416,7 @@ macro_rules! __impl_bitflags {\n                 \/\/ Append any extra bits that correspond to flags to the end of the format\n                 let extra_bits = self.bits & !Self::all().bits();\n \n-                if extra_bits != 0 {\n+                if extra_bits != <$T as $crate::__private::Bits>::EMPTY {\n                     if !first {\n                         f.write_str(\" | \")?;\n                     }\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -495,7 +456,14 @@ macro_rules! __impl_bitflags {\n             }\n         }\n \n-        #[allow(dead_code)]\n+        #[allow(\n+            dead_code,\n+            deprecated,\n+            unused_doc_comments,\n+            unused_attributes,\n+            unused_mut,\n+            non_upper_case_globals\n+        )]\n         impl $BitFlags {\n             $(\n                 $(#[$attr $($args)*])*\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -505,20 +473,13 @@ macro_rules! __impl_bitflags {\n             \/\/\/ Returns an empty set of flags.\n             #[inline]\n             pub const fn empty() -> Self {\n-                Self { bits: 0 }\n+                Self { bits: <$T as $crate::__private::Bits>::EMPTY }\n             }\n \n             \/\/\/ Returns the set containing all flags.\n             #[inline]\n             pub const fn all() -> Self {\n-                __impl_all_bitflags! {\n-                    $BitFlags: $T {\n-                        $(\n-                            $(#[$attr $($args)*])*\n-                            $Flag = $value;\n-                        )*\n-                    }\n-                }\n+                Self::from_bits_truncate(<$T as $crate::__private::Bits>::ALL)\n             }\n \n             \/\/\/ Returns the raw value of the flags currently stored.\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -532,8 +493,9 @@ macro_rules! __impl_bitflags {\n             #[inline]\n             pub const fn from_bits(bits: $T) -> $crate::__private::core::option::Option<Self> {\n                 let truncated = Self::from_bits_truncate(bits).bits;\n+\n                 if truncated == bits {\n-                    $crate::__private::core::option::Option::Some(Self{ bits })\n+                    $crate::__private::core::option::Option::Some(Self { bits })\n                 } else {\n                     $crate::__private::core::option::Option::None\n                 }\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -543,15 +505,13 @@ macro_rules! __impl_bitflags {\n             \/\/\/ that do not correspond to flags.\n             #[inline]\n             pub const fn from_bits_truncate(bits: $T) -> Self {\n-                if bits == 0 {\n+                if bits == <$T as $crate::__private::Bits>::EMPTY {\n                     return Self { bits }\n                 }\n \n-                #[allow(unused_mut)]\n-                let mut truncated = 0;\n+                let mut truncated = <$T as $crate::__private::Bits>::EMPTY;\n \n                 $(\n-                    #[allow(unused_doc_comments, unused_attributes)]\n                     $(#[$attr $($args)*])*\n                     if bits & Self::$Flag.bits == Self::$Flag.bits {\n                         truncated |= Self::$Flag.bits\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -719,15 +679,13 @@ macro_rules! __impl_bitflags {\n             }\n \n             \/\/\/ Returns an iterator over set flags and their names.\n-            pub fn iter(mut self) -> impl $crate::__private::core::iter::Iterator<Item = (&'static str, Self)> {\n+            pub fn iter(self) -> impl $crate::__private::core::iter::Iterator<Item = (&'static str, Self)> {\n                 use $crate::__private::core::iter::Iterator as _;\n \n                 const NUM_FLAGS: usize = {\n-                    #[allow(unused_mut)]\n                     let mut num_flags = 0;\n \n                     $(\n-                        #[allow(unused_doc_comments, unused_attributes)]\n                         $(#[$attr $($args)*])*\n                         {\n                             num_flags += 1;\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -739,13 +697,11 @@ macro_rules! __impl_bitflags {\n \n                 const OPTIONS: [$BitFlags; NUM_FLAGS] = [\n                     $(\n-                        #[allow(unused_doc_comments, unused_attributes)]\n                         $(#[$attr $($args)*])*\n                         $BitFlags::$Flag,\n                     )*\n                 ];\n \n-                #[allow(unused_doc_comments, unused_attributes)]\n                 const OPTIONS_NAMES: [&'static str; NUM_FLAGS] = [\n                     $(\n                         $(#[$attr $($args)*])*\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -754,17 +710,29 @@ macro_rules! __impl_bitflags {\n                 ];\n \n                 let mut start = 0;\n+                let mut state = self;\n \n                 $crate::__private::core::iter::from_fn(move || {\n-                    if self.is_empty() || NUM_FLAGS == 0 {\n+                    if state.is_empty() || NUM_FLAGS == 0 {\n                         $crate::__private::core::option::Option::None\n                     } else {\n                         for (flag, flag_name) in OPTIONS[start..NUM_FLAGS].iter().copied()\n                             .zip(OPTIONS_NAMES[start..NUM_FLAGS].iter().copied())\n                         {\n                             start += 1;\n+\n+                            \/\/ NOTE: We check whether the flag exists in self, but remove it from\n+                            \/\/ a different value. This ensure that overlapping flags are handled\n+                            \/\/ properly. Take the following example:\n+                            \/\/\n+                            \/\/ const A: 0b00000001;\n+                            \/\/ const B: 0b00000101;\n+                            \/\/\n+                            \/\/ Given the bits 0b00000101, both A and B are set. But if we removed A\n+                            \/\/ as we encountered it we'd be left with 0b00000100, which doesn't\n+                            \/\/ correspond to a valid flag on its own.\n                             if self.contains(flag) {\n-                                self.remove(flag);\n+                                state.remove(flag);\n \n                                 return $crate::__private::core::option::Option::Some((flag_name, flag))\n                             }\n","version":"1.3","repo":"bitflags\/bitflags","environment_setup_commit":"b14fd2f6e65ff43eabf754680570e4951903d7b2"}
{"problem_statement":"from_bits accepts non existing flags\n```rs\r\n    #[test]\r\n    fn test_from_bits_edge_cases() {\r\n        bitflags! {\r\n            struct Flags: u8 {\r\n                const A = 0b00000001;\r\n                const BC = 0b00000110;\r\n            }\r\n        }\r\n\r\n\r\n        let flags = Flags::from_bits(0b00000100);\r\n        assert!(flags.is_none());\r\n    }\r\n```\r\n\r\nUnless I'm missing something this test should pass but it fails cause from_bits accepts flags that are not declared. \r\n\r\nhttps:\/\/play.rust-lang.org\/?version=stable&mode=debug&edition=2021&gist=6fd4adbddc8b8740cbd35af2306073ca\r\n\r\nThis is related to this issue in the implementation of iterators in this PR https:\/\/github.com\/bitflags\/bitflags\/pull\/204#issuecomment-950304444 Using `from_bits` instead of `from_bits_unchecked` should allow to produce any valid flags that are not a combination of other flags but at the moment `from_bits` seems to accept any flag that is included in a combination even if it's not declared. I can try to send a PR. \n","test_patch":"diff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -1891,6 +1907,37 @@ mod tests {\n         }\n     }\n \n+    #[test]\n+    fn test_from_bits_edge_cases() {\n+        bitflags! {\n+            struct Flags: u8 {\n+                const A = 0b00000001;\n+                const BC = 0b00000110;\n+            }\n+        }\n+\n+\n+        let flags = Flags::from_bits(0b00000100);\n+        assert_eq!(flags, None);\n+        let flags = Flags::from_bits(0b00000101);\n+        assert_eq!(flags, None);\n+    }\n+\n+    #[test]\n+    fn test_from_bits_truncate_edge_cases() {\n+        bitflags! {\n+            struct Flags: u8 {\n+                const A = 0b00000001;\n+                const BC = 0b00000110;\n+            }\n+        }\n+\n+        let flags = Flags::from_bits_truncate(0b00000100);\n+        assert_eq!(flags, Flags::empty());\n+        let flags = Flags::from_bits_truncate(0b00000101);\n+        assert_eq!(flags, Flags::A);\n+    }\n+  \n     #[test]\n     fn test_iter() {\n         bitflags! {\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -1924,22 +1971,4 @@ mod tests {\n         assert_eq!(iter.next().unwrap(), Flags::THREE);\n         assert_eq!(iter.next(), None);\n     }\n-\n-    #[test]\n-    fn test_iter_edge_cases() {\n-        bitflags! {\n-            struct Flags: u8 {\n-                const A = 0b00000001;\n-                const BC = 0b00000110;\n-            }\n-        }\n-\n-\n-        let flags = Flags::all();\n-        assert_eq!(flags.iter().count(), 2);\n-        let mut iter = flags.iter();\n-        assert_eq!(iter.next().unwrap(), Flags::A);\n-        assert_eq!(iter.next().unwrap(), Flags::BC);\n-        assert_eq!(iter.next(), None);\n-    }\n }\ndiff --git a\/tests\/compile-fail\/non_integer_base\/all_defined.stderr.beta b\/tests\/compile-fail\/non_integer_base\/all_defined.stderr.beta\n--- a\/tests\/compile-fail\/non_integer_base\/all_defined.stderr.beta\n+++ b\/tests\/compile-fail\/non_integer_base\/all_defined.stderr.beta\n@@ -49,8 +49,41 @@ error[E0308]: mismatched types\n     = note: this error originates in the macro `__impl_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: try wrapping the expression in `MyInt`\n     |\n-562 |                 if (bits & !Self::all().bits()) == MyInt(0) {\n-    |                                                    ++++++ +\n+574 |                 if bits == MyInt(0) {\n+    |                            ++++++ +\n+\n+error[E0277]: no implementation for `{integer} |= MyInt`\n+   --> $DIR\/all_defined.rs:115:1\n+    |\n+115 | \/ bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^ no implementation for `{integer} |= MyInt`\n+    |\n+    = help: the trait `BitOrAssign<MyInt>` is not implemented for `{integer}`\n+    = note: this error originates in the macro `__impl_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0308]: mismatched types\n+   --> $DIR\/all_defined.rs:115:1\n+    |\n+115 | \/ bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^ expected struct `MyInt`, found integer\n+    |\n+    = note: this error originates in the macro `__impl_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: try wrapping the expression in `MyInt`\n+    |\n+589 |                 Self { bits: MyInt(truncated) }\n+    |                              ++++++         +\n \n error[E0308]: mismatched types\n    --> $DIR\/all_defined.rs:115:1\n","hints_text":"","base_commit":"0141a07e55184304857384b0093d00959f0acfa6","issue_numbers":["275"],"created_at":"2022-04-19T09:54:30Z","pull_number":276,"instance_id":"bitflags__bitflags-276","patch":"diff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -559,10 +559,11 @@ macro_rules! __impl_bitflags {\n             \/\/\/ representation contains bits that do not correspond to a flag.\n             #[inline]\n             pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n-                if (bits & !Self::all().bits()) == 0 {\n-                    $crate::_core::option::Option::Some(Self { bits })\n+                let truncated = Self::from_bits_truncate(bits).bits;\n+                if truncated == bits {\n+                    Some(Self{ bits })\n                 } else {\n-                    $crate::_core::option::Option::None\n+                    None\n                 }\n             }\n \ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -570,7 +571,22 @@ macro_rules! __impl_bitflags {\n             \/\/\/ that do not correspond to flags.\n             #[inline]\n             pub const fn from_bits_truncate(bits: $T) -> Self {\n-                Self { bits: bits & Self::all().bits }\n+                if bits == 0 {\n+                    return Self{ bits }\n+                }\n+\n+                #[allow(unused_mut)]\n+                let mut truncated = 0;\n+\n+                $(\n+                    #[allow(unused_doc_comments, unused_attributes)]\n+                    $(#[$attr $($args)*])*\n+                    if bits & Self::$Flag.bits == Self::$Flag.bits {\n+                        truncated |= Self::$Flag.bits\n+                    }\n+                )*\n+\n+                Self { bits: truncated }\n             }\n \n             \/\/\/ Convert from underlying bit representation, preserving all\n","version":"1.3","repo":"bitflags\/bitflags","environment_setup_commit":"b14fd2f6e65ff43eabf754680570e4951903d7b2"}
{"problem_statement":"Bug: debug pretty-printing unknown flags display 0x0x\nmain.rs\r\n```rust\r\nuse bitflags::bitflags;\r\n\r\nbitflags! {\r\n    struct Flags: u8 {\r\n        const TWO = 0x2;\r\n    }\r\n}\r\n\r\nfn main() {\r\n    let value = 0b11;\r\n    let flags = unsafe { Flags::from_bits_unchecked(value) };\r\n    println!(\"{:?}\", flags);\r\n    println!(\"-----------\");\r\n    println!(\"{:#?}\", flags);\r\n}\r\n```\r\nwill print the following:\r\n```sh\r\nTWO | 0x1\r\n-----------\r\nTWO | 0x0x1\r\n```\r\n\r\nthe expected output would either be 0x1 for both, or 1, and 0x1 respectively\n","test_patch":"diff --git a\/tests\/compile-fail\/trait\/custom_impl.rs b\/tests\/compile-fail\/trait\/custom_impl.rs\n--- a\/tests\/compile-fail\/trait\/custom_impl.rs\n+++ b\/tests\/compile-fail\/trait\/custom_impl.rs\n@@ -62,4 +62,4 @@ impl BitFlags for BootlegFlags {\n     }\n }\n \n-fn main() { }\n+fn main() {}\ndiff --git a\/tests\/compile-pass\/impls\/convert.rs b\/tests\/compile-pass\/impls\/convert.rs\n--- a\/tests\/compile-pass\/impls\/convert.rs\n+++ b\/tests\/compile-pass\/impls\/convert.rs\n@@ -12,6 +12,4 @@ impl From<u32> for Flags {\n     }\n }\n \n-fn main() {\n-\n-}\n+fn main() {}\ndiff --git \/dev\/null b\/tests\/compile-pass\/impls\/fmt.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/tests\/compile-pass\/impls\/fmt.rs\n@@ -0,0 +1,14 @@\n+use bitflags::bitflags;\n+\n+bitflags! {\n+    struct Flags: u8 {\n+        const TWO = 0x2;\n+    }\n+}\n+\n+fn main() {\n+    \/\/ bug #267 (https:\/\/github.com\/bitflags\/bitflags\/issues\/267)\n+    let flags = unsafe { Flags::from_bits_unchecked(0b11) };\n+    assert_eq!(format!(\"{:?}\", flags), \"TWO | 0x1\");\n+    assert_eq!(format!(\"{:#?}\", flags), \"TWO | 0x1\");\n+}\ndiff --git a\/tests\/compile-pass\/redefinition\/stringify.rs b\/tests\/compile-pass\/redefinition\/macros.rs\n--- a\/tests\/compile-pass\/redefinition\/stringify.rs\n+++ b\/tests\/compile-pass\/redefinition\/macros.rs\n@@ -7,6 +7,11 @@ macro_rules! stringify {\n     ($($t:tt)*) => { \"...\" };\n }\n \n+#[allow(unused_macros)]\n+macro_rules! write {\n+    ($($t:tt)*) => { \"...\" };\n+}\n+\n bitflags! {\n     struct Test: u8 {\n         const A = 1;\ndiff --git a\/tests\/compile-pass\/redefinition\/stringify.rs b\/tests\/compile-pass\/redefinition\/macros.rs\n--- a\/tests\/compile-pass\/redefinition\/stringify.rs\n+++ b\/tests\/compile-pass\/redefinition\/macros.rs\n@@ -14,6 +19,6 @@ bitflags! {\n }\n \n fn main() {\n-    \/\/ Just make sure we don't call the redefined `stringify` macro\n-    assert_eq!(format!(\"{:?}\", Test::A), \"A\");\n+    \/\/ Just make sure we don't call the redefined `stringify` or `write` macro\n+    assert_eq!(format!(\"{:?}\", unsafe { Test::from_bits_unchecked(0b11) }), \"A | 0x2\");\n }\n","hints_text":"","base_commit":"1aa25e1b3baf35d3d3840f12fe7e8b55adc0164a","issue_numbers":["267"],"created_at":"2022-01-02T17:22:14Z","pull_number":268,"instance_id":"bitflags__bitflags-268","patch":"diff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -494,8 +494,7 @@ macro_rules! __impl_bitflags {\n                         f.write_str(\" | \")?;\n                     }\n                     first = false;\n-                    f.write_str(\"0x\")?;\n-                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n+                    $crate::_core::write!(f, \"{:#x}\", extra_bits)?;\n                 }\n                 if first {\n                     f.write_str(\"(empty)\")?;\n","version":"1.3","repo":"bitflags\/bitflags","environment_setup_commit":"b14fd2f6e65ff43eabf754680570e4951903d7b2"}
{"problem_statement":"The bitflags macro is not sanitary wrt. standard library types and enumerations\nThe `bitflags` macro, expanded in the prescence of a definition of the type\/value `Ok` errors.\r\nReproduction code:\r\nhttps:\/\/play.rust-lang.org\/?version=stable&mode=debug&edition=2021&gist=3fda3e36c7c6a57e0f7a83c84e56df20\r\n\r\nInterestingly, the relevant function, the `fmt` function from the Debug impl, does use `::bitflags::_core::fmt::Result`, however, it merely returns the value `Ok(())`. \n","test_patch":"diff --git \/dev\/null b\/tests\/compile-pass\/redefinition\/result.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/tests\/compile-pass\/redefinition\/result.rs\n@@ -0,0 +1,15 @@\n+use bitflags::bitflags;\n+\n+\/\/ Checks for possible errors caused by overriding names used by `bitflags!` internally.\n+\n+\/\/ bug #265 (https:\/\/github.com\/bitflags\/bitflags\/issues\/265)\n+\n+pub struct Ok<T>(T);\n+\n+bitflags! {\n+    pub struct Flags: u16{\n+        const FOO = 0x0001;\n+    }\n+}\n+\n+fn main() {}\n","hints_text":"","base_commit":"1aa25e1b3baf35d3d3840f12fe7e8b55adc0164a","issue_numbers":["265"],"created_at":"2021-12-16T09:38:14Z","pull_number":266,"instance_id":"bitflags__bitflags-266","patch":"diff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -500,7 +500,7 @@ macro_rules! __impl_bitflags {\n                 if first {\n                     f.write_str(\"(empty)\")?;\n                 }\n-                Ok(())\n+                $crate::_core::fmt::Result::Ok(())\n             }\n         }\n         impl $crate::_core::fmt::Binary for $BitFlags {\n","version":"1.3","repo":"bitflags\/bitflags","environment_setup_commit":"b14fd2f6e65ff43eabf754680570e4951903d7b2"}
{"problem_statement":"`usize` \/ `isize` aren't supported anymore in `v2.0`\nThis doesn't seem intentional at least and isn't mentioned in the changelog.\n","test_patch":"diff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -1548,4 +1548,57 @@ mod tests {\n \n         assert_eq!(flags, rebuilt);\n     }\n+\n+    #[test]\n+    fn bits_types() {\n+        bitflags! {\n+            pub struct I8: i8 {\n+                const A = 1;\n+            }\n+\n+            pub struct I16: i16 {\n+                const A = 1;\n+            }\n+\n+            pub struct I32: i32 {\n+                const A = 1;\n+            }\n+\n+            pub struct I64: i64 {\n+                const A = 1;\n+            }\n+\n+            pub struct I128: i128 {\n+                const A = 1;\n+            }\n+\n+            pub struct Isize: isize {\n+                const A = 1;\n+            }\n+\n+            pub struct U8: u8 {\n+                const A = 1;\n+            }\n+\n+            pub struct U16: u16 {\n+                const A = 1;\n+            }\n+\n+            pub struct U32: u32 {\n+                const A = 1;\n+            }\n+\n+            pub struct U64: u64 {\n+                const A = 1;\n+            }\n+\n+            pub struct U128: u128 {\n+                const A = 1;\n+            }\n+\n+            pub struct Usize: usize {\n+                const A = 1;\n+            }\n+        }\n+    }\n }\n","hints_text":"In what way are they not supported? What error message do they give? Or is there some other problem with them?\nThey don't implement the new `Bits` trait, which is required to use bitflags: https:\/\/github.com\/bitflags\/bitflags\/blob\/main\/src\/traits.rs#L135-L141\nThanks for pointing this out @CryZe. This is a total oversight, they should implement the `Bits` trait.","base_commit":"8b43d2bb7efbd3d4189fdac92e411ad20c5140b5","issue_numbers":["319"],"created_at":"2023-03-19T08:31:22Z","pull_number":321,"instance_id":"bitflags__bitflags-321","patch":"diff --git a\/src\/traits.rs b\/src\/traits.rs\n--- a\/src\/traits.rs\n+++ b\/src\/traits.rs\n@@ -138,6 +138,7 @@ impl_bits! {\n     u32, i32,\n     u64, i64,\n     u128, i128,\n+    usize, isize,\n }\n \n \/\/\/ A trait for referencing the `bitflags`-owned internal type\n","version":"2.0","repo":"bitflags\/bitflags","environment_setup_commit":"11640f19a7644f3967631733f33ec87b9f911951"}
{"problem_statement":"Display missing extra bits for multi-bit flags\nSee: https:\/\/github.com\/bitflags\/bitflags\/issues\/310#issuecomment-1470122112\r\n\r\nGiven a flags type with two flags, `BIT = 0b0000_0001` and `MASK = 0b0001_1110`, formatting the value `3` should result in `BIT | 0x2`, but instead it gives `BIT`. That extra bit gets lost, so doesn't roundtrip. The problem seems to be in the generated `iter_names` method.\n","test_patch":"diff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -1154,17 +1154,39 @@ mod tests {\n \n     #[test]\n     fn test_display_from_str_roundtrip() {\n-        fn format_parse_case(flags: FmtFlags) {\n+        fn format_parse_case<T: fmt::Debug + fmt::Display + str::FromStr + PartialEq>(flags: T) where <T as str::FromStr>::Err: fmt::Display {\n             assert_eq!(flags, {\n-                match flags.to_string().parse::<FmtFlags>() {\n+                match flags.to_string().parse::<T>() {\n                     Ok(flags) => flags,\n                     Err(e) => panic!(\"failed to parse `{}`: {}\", flags, e),\n                 }\n             });\n         }\n \n-        fn parse_case(expected: FmtFlags, flags: &str) {\n-            assert_eq!(expected, flags.parse::<FmtFlags>().unwrap());\n+        fn parse_case<T: fmt::Debug + str::FromStr + PartialEq>(expected: T, flags: &str) where <T as str::FromStr>::Err: fmt::Display + fmt::Debug {\n+            assert_eq!(expected, flags.parse::<T>().unwrap());\n+        }\n+\n+        bitflags! {\n+            #[derive(Debug, Eq, PartialEq)]\n+            pub struct MultiBitFmtFlags: u8 {\n+                const A = 0b0000_0001u8;\n+                const B = 0b0001_1110u8;\n+            }\n+        }\n+\n+        impl fmt::Display for MultiBitFmtFlags {\n+            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                fmt::Display::fmt(&self.0, f)\n+            }\n+        }\n+\n+        impl str::FromStr for MultiBitFmtFlags {\n+            type Err = crate::parser::ParseError;\n+\n+            fn from_str(s: &str) -> Result<Self, Self::Err> {\n+                Ok(MultiBitFmtFlags(s.parse()?))\n+            }\n         }\n \n         format_parse_case(FmtFlags::empty());\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -1174,6 +1196,7 @@ mod tests {\n         format_parse_case(FmtFlags::\ubb3c\uace0\uae30_\uace0\uc591\uc774);\n         format_parse_case(FmtFlags::from_bits_retain(0xb8));\n         format_parse_case(FmtFlags::from_bits_retain(0x20));\n+        format_parse_case(MultiBitFmtFlags::from_bits_retain(3));\n \n         parse_case(FmtFlags::empty(), \"\");\n         parse_case(FmtFlags::empty(), \" \\r\\n\\t\");\n","hints_text":"","base_commit":"ad0271116e28a79ea880334dd3d06212a224ec09","issue_numbers":["315"],"created_at":"2023-03-16T00:19:13Z","pull_number":316,"instance_id":"bitflags__bitflags-316","patch":"diff --git a\/src\/internal.rs b\/src\/internal.rs\n--- a\/src\/internal.rs\n+++ b\/src\/internal.rs\n@@ -89,7 +89,8 @@ macro_rules! __impl_internal_bitflags {\n \n                 \/\/ Iterate over the valid flags\n                 let mut first = true;\n-                for (name, _) in self.iter_names() {\n+                let mut iter = self.iter_names();\n+                for (name, _) in &mut iter {\n                     if !first {\n                         f.write_str(\" | \")?;\n                     }\ndiff --git a\/src\/internal.rs b\/src\/internal.rs\n--- a\/src\/internal.rs\n+++ b\/src\/internal.rs\n@@ -99,8 +100,7 @@ macro_rules! __impl_internal_bitflags {\n                 }\n \n                 \/\/ Append any extra bits that correspond to flags to the end of the format\n-                let extra_bits = self.bits & !Self::all().bits;\n-\n+                let extra_bits = iter.state.bits();\n                 if extra_bits != <$T as $crate::__private::Bits>::EMPTY {\n                     if !first {\n                         f.write_str(\" | \")?;\n","version":"2.0","repo":"bitflags\/bitflags","environment_setup_commit":"11640f19a7644f3967631733f33ec87b9f911951"}
{"problem_statement":"Consider making a release\n1.3.2 is released 2 years ago and there are valuable changes on `main` since then. When will the next version be released?\n","test_patch":"diff --git a\/CHANGELOG.md b\/CHANGELOG.md\n--- a\/CHANGELOG.md\n+++ b\/CHANGELOG.md\n@@ -1,3 +1,34 @@\n+# 2.0.0-rc.1\n+\n+This is a big release including a few years worth of work on a new `BitFlags` trait, iteration, and better macro organization for future extensibility.\n+\n+## What's Changed\n+* Fix a typo and call out MSRV bump by @KodrAus in https:\/\/github.com\/bitflags\/bitflags\/pull\/259\n+* BitFlags trait by @arturoc in https:\/\/github.com\/bitflags\/bitflags\/pull\/220\n+* Add a hidden trait to discourage manual impls of BitFlags by @KodrAus in https:\/\/github.com\/bitflags\/bitflags\/pull\/261\n+* Sanitize `Ok` by @konsumlamm in https:\/\/github.com\/bitflags\/bitflags\/pull\/266\n+* Fix bug in `Debug` implementation by @konsumlamm in https:\/\/github.com\/bitflags\/bitflags\/pull\/268\n+* Fix a typo in the generated documentation by @wackbyte in https:\/\/github.com\/bitflags\/bitflags\/pull\/271\n+* Use SPDX license format by @atouchet in https:\/\/github.com\/bitflags\/bitflags\/pull\/272\n+* serde tests fail in CI by @arturoc in https:\/\/github.com\/bitflags\/bitflags\/pull\/277\n+* Fix beta test output by @KodrAus in https:\/\/github.com\/bitflags\/bitflags\/pull\/279\n+* Add example to the README.md file by @tiaanl in https:\/\/github.com\/bitflags\/bitflags\/pull\/270\n+* Iterator over all the enabled options by @arturoc in https:\/\/github.com\/bitflags\/bitflags\/pull\/278\n+* from_bits_(truncate) fail with composite flags by @arturoc in https:\/\/github.com\/bitflags\/bitflags\/pull\/276\n+* Add more platform coverage to CI by @KodrAus in https:\/\/github.com\/bitflags\/bitflags\/pull\/280\n+* rework the way cfgs are handled by @KodrAus in https:\/\/github.com\/bitflags\/bitflags\/pull\/281\n+* Split generated code into two types by @KodrAus in https:\/\/github.com\/bitflags\/bitflags\/pull\/282\n+* expose bitflags iters using nameable types by @KodrAus in https:\/\/github.com\/bitflags\/bitflags\/pull\/286\n+* Support creating flags from their names by @KodrAus in https:\/\/github.com\/bitflags\/bitflags\/pull\/287\n+* Update README.md by @KodrAus in https:\/\/github.com\/bitflags\/bitflags\/pull\/288\n+\n+## New Contributors\n+* @wackbyte made their first contribution in https:\/\/github.com\/bitflags\/bitflags\/pull\/271\n+* @atouchet made their first contribution in https:\/\/github.com\/bitflags\/bitflags\/pull\/272\n+* @tiaanl made their first contribution in https:\/\/github.com\/bitflags\/bitflags\/pull\/270\n+\n+**Full Changelog**: https:\/\/github.com\/bitflags\/bitflags\/compare\/1.3.2...2.0.0-rc.1\n+\n # 1.3.2\n \n - Allow `non_snake_case` in generated flags types ([#256])\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -339,7 +339,7 @@\n \/\/! ```\n \n #![cfg_attr(not(test), no_std)]\n-#![doc(html_root_url = \"https:\/\/docs.rs\/bitflags\/1.3.2\")]\n+#![doc(html_root_url = \"https:\/\/docs.rs\/bitflags\/2.0.0-rc.1\")]\n \n #[doc(inline)]\n pub use traits::BitFlags;\n","hints_text":"Hi @yshui \ud83d\udc4b It has been a while since we\u2019ve put a release out. We\u2019ve been working on getting some things sorted for a new major version now that the API surface area is a bit more involved. The last piece of that puzzle is in #286 ","base_commit":"b14fd2f6e65ff43eabf754680570e4951903d7b2","issue_numbers":["285"],"created_at":"2022-10-07T07:06:21Z","pull_number":289,"instance_id":"bitflags__bitflags-289","patch":"diff --git a\/Cargo.toml b\/Cargo.toml\n--- a\/Cargo.toml\n+++ b\/Cargo.toml\n@@ -3,7 +3,7 @@ name = \"bitflags\"\n # NB: When modifying, also modify:\n #   1. html_root_url in lib.rs\n #   2. number in readme (for breaking changes)\n-version = \"1.3.2\"\n+version = \"2.0.0-rc.1\"\n edition = \"2018\"\n authors = [\"The Rust Project Developers\"]\n license = \"MIT OR Apache-2.0\"\ndiff --git a\/README.md b\/README.md\n--- a\/README.md\n+++ b\/README.md\n@@ -17,7 +17,7 @@ Add this to your `Cargo.toml`:\n \n ```toml\n [dependencies]\n-bitflags = \"1.3\"\n+bitflags = \"2.0.0-rc.1\"\n ```\n \n and this to your source code:\ndiff --git a\/README.md b\/README.md\n--- a\/README.md\n+++ b\/README.md\n@@ -35,6 +35,7 @@ use bitflags::bitflags;\n \n \/\/ The `bitflags!` macro generates `struct`s that manage a set of flags.\n bitflags! {\n+    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n     struct Flags: u32 {\n         const A = 0b00000001;\n         const B = 0b00000010;\n","version":"1.3","repo":"bitflags\/bitflags","environment_setup_commit":"b14fd2f6e65ff43eabf754680570e4951903d7b2"}
{"problem_statement":"Add an option for checking for valid bits is in the getter rather than constructor\nHi, I want to use bitflags for generated code that interacts with data in other languages, some of which are bitflags (https:\/\/github.com\/google\/flatbuffers\/pull\/6098). I don't want to drop data so I'd like to use `from_bits_unchecked`. However, it is marked as unsafe. I'd like to submit a PR to add an option to get around this. I have two ideas:\r\n\r\n1) Move the valid-bits-check to the getter: There'll be only one constructor: `from_bits` and the `bits()` getter becomes `bits() -> Result<...>`, `unsafe bits_unchecked()`, and `bits_truncated()`\r\n\r\n2) #200 documents that this crate uses `unsafe` to mean a usage issue rather than a memory issue, so maybe I could make an option to remove the unsafe altogether, and update the generated documentation appropriately?\r\n\r\nWhat are your thoughts on these ideas? Does bitflags depend on the \"bits are truncated to defined flags\" invariant?\n","test_patch":"diff --git a\/.github\/workflows\/rust.yml b\/.github\/workflows\/rust.yml\n--- a\/.github\/workflows\/rust.yml\n+++ b\/.github\/workflows\/rust.yml\n@@ -46,8 +46,17 @@ jobs:\n         profile: minimal\n         toolchain: ${{ matrix.channel }}-${{ matrix.rust_target }}\n \n-    - name: Tests\n-      run: cargo test --features example_generated\n+    - name: Install cargo-hack\n+      run: cargo install cargo-hack\n+\n+    - name: Powerset\n+      run: cargo hack test --feature-powerset --lib --optional-deps \"serde\" --depth 3 --skip rustc-dep-of-std\n+\n+    - name: Docs\n+      run: cargo doc --features example_generated\n+\n+    - name: Smoke test\n+      run: cargo run --manifest-path tests\/smoke-test\/Cargo.toml\n \n   embedded:\n     name: Build (embedded)\ndiff --git a\/Cargo.toml b\/Cargo.toml\n--- a\/Cargo.toml\n+++ b\/Cargo.toml\n@@ -16,16 +16,16 @@ categories = [\"no-std\"]\n description = \"\"\"\n A macro to generate structures which behave like bitflags.\n \"\"\"\n-exclude = [\"bors.toml\"]\n+exclude = [\"tests\", \".github\"]\n \n [dependencies]\n-core = { version = '1.0.0', optional = true, package = 'rustc-std-workspace-core' }\n-compiler_builtins = { version = '0.1.2', optional = true }\n+serde = { version = \"1.0\", optional = true }\n+core = { version = \"1.0.0\", optional = true, package = \"rustc-std-workspace-core\" }\n+compiler_builtins = { version = \"0.1.2\", optional = true }\n \n [dev-dependencies]\n trybuild = \"1.0\"\n rustversion = \"1.0\"\n-serde = \"1.0\"\n serde_derive = \"1.0\"\n serde_json = \"1.0\"\n \ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -845,181 +801,421 @@ macro_rules! __impl_bitflags {\n             }\n         }\n \n-        impl $crate::BitFlags for $BitFlags {\n+        impl $crate::BitFlags for $PublicBitFlags {\n             type Bits = $T;\n \n             fn empty() -> Self {\n-                $BitFlags::empty()\n+                $PublicBitFlags::empty()\n             }\n \n             fn all() -> Self {\n-                $BitFlags::all()\n+                $PublicBitFlags::all()\n             }\n \n             fn bits(&self) -> $T {\n-                $BitFlags::bits(self)\n+                $PublicBitFlags::bits(self)\n             }\n \n-            fn from_bits(bits: $T) -> $crate::__private::core::option::Option<$BitFlags> {\n-                $BitFlags::from_bits(bits)\n+            fn from_bits(bits: $T) -> $crate::__private::core::option::Option<$PublicBitFlags> {\n+                $PublicBitFlags::from_bits(bits)\n             }\n \n-            fn from_bits_truncate(bits: $T) -> $BitFlags {\n-                $BitFlags::from_bits_truncate(bits)\n+            fn from_bits_truncate(bits: $T) -> $PublicBitFlags {\n+                $PublicBitFlags::from_bits_truncate(bits)\n             }\n \n-            unsafe fn from_bits_unchecked(bits: $T) -> $BitFlags {\n-                $BitFlags::from_bits_unchecked(bits)\n+            fn from_bits_retain(bits: $T) -> $PublicBitFlags {\n+                $PublicBitFlags::from_bits_retain(bits)\n             }\n \n             fn is_empty(&self) -> bool {\n-                $BitFlags::is_empty(self)\n+                $PublicBitFlags::is_empty(self)\n             }\n \n             fn is_all(&self) -> bool {\n-                $BitFlags::is_all(self)\n+                $PublicBitFlags::is_all(self)\n             }\n \n-            fn intersects(&self, other: $BitFlags) -> bool {\n-                $BitFlags::intersects(self, other)\n+            fn intersects(&self, other: $PublicBitFlags) -> bool {\n+                $PublicBitFlags::intersects(self, other)\n             }\n \n-            fn contains(&self, other: $BitFlags) -> bool {\n-                $BitFlags::contains(self, other)\n+            fn contains(&self, other: $PublicBitFlags) -> bool {\n+                $PublicBitFlags::contains(self, other)\n             }\n \n-            fn insert(&mut self, other: $BitFlags) {\n-                $BitFlags::insert(self, other)\n+            fn insert(&mut self, other: $PublicBitFlags) {\n+                $PublicBitFlags::insert(self, other)\n             }\n \n-            fn remove(&mut self, other: $BitFlags) {\n-                $BitFlags::remove(self, other)\n+            fn remove(&mut self, other: $PublicBitFlags) {\n+                $PublicBitFlags::remove(self, other)\n             }\n \n-            fn toggle(&mut self, other: $BitFlags) {\n-                $BitFlags::toggle(self, other)\n+            fn toggle(&mut self, other: $PublicBitFlags) {\n+                $PublicBitFlags::toggle(self, other)\n             }\n \n-            fn set(&mut self, other: $BitFlags, value: bool) {\n-                $BitFlags::set(self, other, value)\n+            fn set(&mut self, other: $PublicBitFlags, value: bool) {\n+                $PublicBitFlags::set(self, other, value)\n             }\n         }\n \n-        impl $crate::__private::ImplementedByBitFlagsMacro for $BitFlags {}\n+        impl $crate::__private::ImplementedByBitFlagsMacro for $PublicBitFlags {}\n     };\n+}\n \n-    \/\/ Every attribute that the user writes on a const is applied to the\n-    \/\/ corresponding const that we generate, but within the implementation of\n-    \/\/ Debug and all() we want to ignore everything but #[cfg] attributes. In\n-    \/\/ particular, including a #[deprecated] attribute on those items would fail\n-    \/\/ to compile.\n-    \/\/ https:\/\/github.com\/bitflags\/bitflags\/issues\/109\n-    \/\/\n-    \/\/ Input:\n-    \/\/\n-    \/\/     ? #[cfg(feature = \"advanced\")]\n-    \/\/     ? #[deprecated(note = \"Use something else.\")]\n-    \/\/     ? #[doc = r\"High quality documentation.\"]\n-    \/\/     fn f() -> i32 { \/* ... *\/ }\n-    \/\/\n-    \/\/ Output:\n-    \/\/\n-    \/\/     #[cfg(feature = \"advanced\")]\n-    \/\/     fn f() -> i32 { \/* ... *\/ }\n+\/\/\/ Implement functions on the private (bitflags-facing) bitflags type.\n+\/\/\/\n+\/\/\/ Methods and trait implementations can be freely added here without breaking end-users.\n+\/\/\/ If we want to expose new functionality to `#[derive]`, this is the place to do it.\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+macro_rules! __impl_internal_bitflags {\n     (\n-        $(#[$filtered:meta])*\n-        ? #[cfg $($cfgargs:tt)*]\n-        $(? #[$rest:ident $($restargs:tt)*])*\n-        fn $($item:tt)*\n-    ) => {\n-        __impl_bitflags! {\n-            $(#[$filtered])*\n-            #[cfg $($cfgargs)*]\n-            $(? #[$rest $($restargs)*])*\n-            fn $($item)*\n+        $InternalBitFlags:ident: $T:ty {\n+            $(\n+                $(#[$attr:ident $($args:tt)*])*\n+                $Flag:ident;\n+            )*\n         }\n-    };\n-    (\n-        $(#[$filtered:meta])*\n-        \/\/ $next != `cfg`\n-        ? #[$next:ident $($nextargs:tt)*]\n-        $(? #[$rest:ident $($restargs:tt)*])*\n-        fn $($item:tt)*\n     ) => {\n-        __impl_bitflags! {\n-            $(#[$filtered])*\n-            \/\/ $next filtered out\n-            $(? #[$rest $($restargs)*])*\n-            fn $($item)*\n+        \/\/ Any new library traits impls should be added here\n+        __impl_internal_bitflags_serde! {\n+            $InternalBitFlags: $T {\n+                $(\n+                    $(#[$attr $($args)*])*\n+                    $Flag;\n+                )*\n+            }\n         }\n-    };\n-    (\n-        $(#[$filtered:meta])*\n-        fn $($item:tt)*\n-    ) => {\n-        $(#[$filtered])*\n-        fn $($item)*\n-    };\n \n-    \/\/ Every attribute that the user writes on a const is applied to the\n-    \/\/ corresponding const that we generate, but within the implementation of\n-    \/\/ Debug and all() we want to ignore everything but #[cfg] attributes. In\n-    \/\/ particular, including a #[deprecated] attribute on those items would fail\n-    \/\/ to compile.\n-    \/\/ https:\/\/github.com\/bitflags\/bitflags\/issues\/109\n-    \/\/\n-    \/\/ const version\n-    \/\/\n-    \/\/ Input:\n-    \/\/\n-    \/\/     ? #[cfg(feature = \"advanced\")]\n-    \/\/     ? #[deprecated(note = \"Use something else.\")]\n-    \/\/     ? #[doc = r\"High quality documentation.\"]\n-    \/\/     const f: i32 { \/* ... *\/ }\n-    \/\/\n-    \/\/ Output:\n-    \/\/\n-    \/\/     #[cfg(feature = \"advanced\")]\n-    \/\/     const f: i32 { \/* ... *\/ }\n-    (\n-        $(#[$filtered:meta])*\n-        ? #[cfg $($cfgargs:tt)*]\n-        $(? #[$rest:ident $($restargs:tt)*])*\n-        const $($item:tt)*\n-    ) => {\n-        __impl_bitflags! {\n-            $(#[$filtered])*\n-            #[cfg $($cfgargs)*]\n-            $(? #[$rest $($restargs)*])*\n-            const $($item)*\n+        impl $crate::__private::core::default::Default for $InternalBitFlags {\n+            #[inline]\n+            fn default() -> Self {\n+                $InternalBitFlags::empty()\n+            }\n+        }\n+\n+        impl $crate::__private::core::fmt::Debug for $InternalBitFlags {\n+            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n+                \/\/ Iterate over the valid flags\n+                let mut first = true;\n+                for (name, _) in self.iter() {\n+                    if !first {\n+                        f.write_str(\" | \")?;\n+                    }\n+\n+                    first = false;\n+                    f.write_str(name)?;\n+                }\n+\n+                \/\/ Append any extra bits that correspond to flags to the end of the format\n+                let extra_bits = self.bits & !Self::all().bits;\n+\n+                if extra_bits != <$T as $crate::__private::Bits>::EMPTY {\n+                    if !first {\n+                        f.write_str(\" | \")?;\n+                    }\n+                    first = false;\n+                    $crate::__private::core::write!(f, \"{:#x}\", extra_bits)?;\n+                }\n+\n+                if first {\n+                    f.write_str(\"empty\")?;\n+                }\n+\n+                $crate::__private::core::fmt::Result::Ok(())\n+            }\n+        }\n+\n+        impl $crate::__private::core::fmt::Binary for $InternalBitFlags {\n+            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n+                $crate::__private::core::fmt::Binary::fmt(&self.bits(), f)\n+            }\n+        }\n+\n+        impl $crate::__private::core::fmt::Octal for $InternalBitFlags {\n+            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n+                $crate::__private::core::fmt::Octal::fmt(&self.bits(), f)\n+            }\n+        }\n+\n+        impl $crate::__private::core::fmt::LowerHex for $InternalBitFlags {\n+            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n+                $crate::__private::core::fmt::LowerHex::fmt(&self.bits(), f)\n+            }\n+        }\n+\n+        impl $crate::__private::core::fmt::UpperHex for $InternalBitFlags {\n+            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n+                $crate::__private::core::fmt::UpperHex::fmt(&self.bits(), f)\n+            }\n+        }\n+\n+        #[allow(\n+            dead_code,\n+            deprecated,\n+            unused_doc_comments,\n+            unused_attributes,\n+            unused_mut,\n+            non_upper_case_globals\n+        )]\n+        impl $InternalBitFlags {\n+            #[inline]\n+            pub const fn empty() -> Self {\n+                Self { bits: <$T as $crate::__private::Bits>::EMPTY }\n+            }\n+\n+            #[inline]\n+            pub const fn all() -> Self {\n+                Self::from_bits_truncate(<$T as $crate::__private::Bits>::ALL)\n+            }\n+\n+            #[inline]\n+            pub const fn bits(&self) -> $T {\n+                self.bits\n+            }\n+\n+            #[inline]\n+            pub fn bits_mut(&mut self) -> &mut $T {\n+                &mut self.bits\n+            }\n+\n+            #[inline]\n+            pub const fn from_bits(bits: $T) -> $crate::__private::core::option::Option<Self> {\n+                let truncated = Self::from_bits_truncate(bits).bits;\n+\n+                if truncated == bits {\n+                    $crate::__private::core::option::Option::Some(Self { bits })\n+                } else {\n+                    $crate::__private::core::option::Option::None\n+                }\n+            }\n+\n+            #[inline]\n+            pub const fn from_bits_truncate(bits: $T) -> Self {\n+                if bits == <$T as $crate::__private::Bits>::EMPTY {\n+                    return Self { bits }\n+                }\n+\n+                let mut truncated = <$T as $crate::__private::Bits>::EMPTY;\n+\n+                $(\n+                    $(#[$attr $($args)*])*\n+                    if bits & <$InternalBitFlags as $crate::__private::InternalFlags>::PublicFlags::$Flag.bits() == <$InternalBitFlags as $crate::__private::InternalFlags>::PublicFlags::$Flag.bits() {\n+                        truncated |= <$InternalBitFlags as $crate::__private::InternalFlags>::PublicFlags::$Flag.bits()\n+                    }\n+                )*\n+\n+                Self { bits: truncated }\n+            }\n+\n+            #[inline]\n+            pub const fn from_bits_retain(bits: $T) -> Self {\n+                Self { bits }\n+            }\n+\n+            #[inline]\n+            pub const fn is_empty(&self) -> bool {\n+                self.bits == Self::empty().bits\n+            }\n+\n+            #[inline]\n+            pub const fn is_all(&self) -> bool {\n+                Self::all().bits | self.bits == self.bits\n+            }\n+\n+            #[inline]\n+            pub const fn intersects(&self, other: Self) -> bool {\n+                !(Self { bits: self.bits & other.bits}).is_empty()\n+            }\n+\n+            #[inline]\n+            pub const fn contains(&self, other: Self) -> bool {\n+                (self.bits & other.bits) == other.bits\n+            }\n+\n+            #[inline]\n+            pub fn insert(&mut self, other: Self) {\n+                self.bits |= other.bits;\n+            }\n+\n+            #[inline]\n+            pub fn remove(&mut self, other: Self) {\n+                self.bits &= !other.bits;\n+            }\n+\n+            #[inline]\n+            pub fn toggle(&mut self, other: Self) {\n+                self.bits ^= other.bits;\n+            }\n+\n+            #[inline]\n+            pub fn set(&mut self, other: Self, value: bool) {\n+                if value {\n+                    self.insert(other);\n+                } else {\n+                    self.remove(other);\n+                }\n+            }\n+\n+            #[inline]\n+            #[must_use]\n+            pub const fn intersection(self, other: Self) -> Self {\n+                Self { bits: self.bits & other.bits }\n+            }\n+\n+            #[inline]\n+            #[must_use]\n+            pub const fn union(self, other: Self) -> Self {\n+                Self { bits: self.bits | other.bits }\n+            }\n+\n+            #[inline]\n+            #[must_use]\n+            pub const fn difference(self, other: Self) -> Self {\n+                Self { bits: self.bits & !other.bits }\n+            }\n+\n+            #[inline]\n+            #[must_use]\n+            pub const fn symmetric_difference(self, other: Self) -> Self {\n+                Self { bits: self.bits ^ other.bits }\n+            }\n+\n+            #[inline]\n+            #[must_use]\n+            pub const fn complement(self) -> Self {\n+                Self::from_bits_truncate(!self.bits)\n+            }\n+\n+            pub fn iter(self) -> impl $crate::__private::core::iter::Iterator<Item = (&'static str, $T)> {\n+                use $crate::__private::core::iter::Iterator as _;\n+\n+                const NUM_FLAGS: usize = {\n+                    let mut num_flags = 0;\n+\n+                    $(\n+                        $(#[$attr $($args)*])*\n+                        {\n+                            num_flags += 1;\n+                        }\n+                    )*\n+\n+                    num_flags\n+                };\n+\n+                const OPTIONS: [$T; NUM_FLAGS] = [\n+                    $(\n+                        $(#[$attr $($args)*])*\n+                        <$InternalBitFlags as $crate::__private::InternalFlags>::PublicFlags::$Flag.bits(),\n+                    )*\n+                ];\n+\n+                const OPTIONS_NAMES: [&'static str; NUM_FLAGS] = [\n+                    $(\n+                        $(#[$attr $($args)*])*\n+                        $crate::__private::core::stringify!($Flag),\n+                    )*\n+                ];\n+\n+                let mut start = 0;\n+                let mut state = self;\n+\n+                $crate::__private::core::iter::from_fn(move || {\n+                    if state.is_empty() || NUM_FLAGS == 0 {\n+                        $crate::__private::core::option::Option::None\n+                    } else {\n+                        for (flag, flag_name) in OPTIONS[start..NUM_FLAGS].iter().copied()\n+                            .zip(OPTIONS_NAMES[start..NUM_FLAGS].iter().copied())\n+                        {\n+                            start += 1;\n+\n+                            \/\/ NOTE: We check whether the flag exists in self, but remove it from\n+                            \/\/ a different value. This ensure that overlapping flags are handled\n+                            \/\/ properly. Take the following example:\n+                            \/\/\n+                            \/\/ const A: 0b00000001;\n+                            \/\/ const B: 0b00000101;\n+                            \/\/\n+                            \/\/ Given the bits 0b00000101, both A and B are set. But if we removed A\n+                            \/\/ as we encountered it we'd be left with 0b00000100, which doesn't\n+                            \/\/ correspond to a valid flag on its own.\n+                            if self.contains(Self { bits: flag }) {\n+                                state.remove(Self { bits: flag });\n+\n+                                return $crate::__private::core::option::Option::Some((flag_name, flag))\n+                            }\n+                        }\n+\n+                        $crate::__private::core::option::Option::None\n+                    }\n+                })\n+            }\n         }\n     };\n+}\n+\n+\/\/ Optional features\n+\/\/\n+\/\/ These macros implement additional library traits for the internal bitflags type so that\n+\/\/ the end-user can either implement or derive those same traits based on the implementation\n+\/\/ we provide in `bitflags`.\n+\/\/\n+\/\/ These macros all follow a  similar pattern. If an optional feature of `bitflags` is enabled\n+\/\/ they'll expand to some impl blocks based on a re-export of the library. If the optional feature\n+\/\/ is not enabled then they expand to a no-op.\n+\n+\/\/\/ Implement `Serialize` and `Deserialize` for the internal bitflags type.\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+#[cfg(feature = \"serde\")]\n+macro_rules! __impl_internal_bitflags_serde {\n     (\n-        $(#[$filtered:meta])*\n-        \/\/ $next != `cfg`\n-        ? #[$next:ident $($nextargs:tt)*]\n-        $(? #[$rest:ident $($restargs:tt)*])*\n-        const $($item:tt)*\n+        $InternalBitFlags:ident: $T:ty {\n+            $(\n+                $(#[$attr:ident $($args:tt)*])*\n+                $Flag:ident;\n+            )*\n+        }\n     ) => {\n-        __impl_bitflags! {\n-            $(#[$filtered])*\n-            \/\/ $next filtered out\n-            $(? #[$rest $($restargs)*])*\n-            const $($item)*\n+        impl $crate::__private::serde::Serialize for $InternalBitFlags {\n+            fn serialize<S: $crate::__private::serde::Serializer>(&self, serializer: S) -> $crate::__private::core::result::Result<S::Ok, S::Error> {\n+                $crate::serde_support::serialize_bits_default($crate::__private::core::stringify!($InternalBitFlags), &self.bits, serializer)\n+            }\n         }\n-    };\n+\n+        impl<'de> $crate::__private::serde::Deserialize<'de> for $InternalBitFlags {\n+            fn deserialize<D: $crate::__private::serde::Deserializer<'de>>(deserializer: D) -> $crate::__private::core::result::Result<Self, D::Error> {\n+                let bits = $crate::serde_support::deserialize_bits_default($crate::__private::core::stringify!($InternalBitFlags), deserializer)?;\n+\n+                $crate::__private::core::result::Result::Ok($InternalBitFlags::from_bits_retain(bits))\n+            }\n+        }\n+    }\n+}\n+\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+#[cfg(not(feature = \"serde\"))]\n+macro_rules! __impl_internal_bitflags_serde {\n     (\n-        $(#[$filtered:meta])*\n-        const $($item:tt)*\n-    ) => {\n-        $(#[$filtered])*\n-        const $($item)*\n-    };\n+        $InternalBitFlags:ident: $T:ty {\n+            $(\n+                $(#[$attr:ident $($args:tt)*])*\n+                $Flag:ident;\n+            )*\n+        }\n+    ) => { }\n }\n \n #[cfg(feature = \"example_generated\")]\n pub mod example_generated;\n \n+#[cfg(feature = \"serde\")]\n+pub mod serde_support;\n+\n #[cfg(test)]\n mod tests {\n     use std::collections::hash_map::DefaultHasher;\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -1030,7 +1226,7 @@ mod tests {\n         #[doc = \"> you are the easiest person to fool.\"]\n         #[doc = \"> \"]\n         #[doc = \"> - Richard Feynman\"]\n-        #[derive(Default)]\n+        #[derive(Clone, Copy, Default, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n         struct Flags: u32 {\n             const A = 0b00000001;\n             #[doc = \"<pcwalton> macros are way better at generating code than trans is\"]\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -1039,28 +1235,32 @@ mod tests {\n             #[doc = \"* cmr bed\"]\n             #[doc = \"* strcat table\"]\n             #[doc = \"<strcat> wait what?\"]\n-            const ABC = Self::A.bits | Self::B.bits | Self::C.bits;\n+            const ABC = Self::A.bits() | Self::B.bits() | Self::C.bits();\n         }\n \n+        #[derive(Clone, Copy, Default, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n         struct _CfgFlags: u32 {\n             #[cfg(unix)]\n             const _CFG_A = 0b01;\n             #[cfg(windows)]\n             const _CFG_B = 0b01;\n             #[cfg(unix)]\n-            const _CFG_C = Self::_CFG_A.bits | 0b10;\n+            const _CFG_C = Self::_CFG_A.bits() | 0b10;\n         }\n \n+        #[derive(Clone, Copy, Default, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n         struct AnotherSetOfFlags: i8 {\n             const ANOTHER_FLAG = -1_i8;\n         }\n \n+        #[derive(Clone, Copy, Default, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n         struct LongFlags: u32 {\n             const LONG_A = 0b1111111111111111;\n         }\n     }\n \n     bitflags! {\n+        #[derive(Clone, Copy, Default, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n         struct EmptyFlags: u32 {\n         }\n     }\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -1113,28 +1313,28 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_from_bits_unchecked() {\n-        let extra = unsafe { Flags::from_bits_unchecked(0b1000) };\n-        assert_eq!(unsafe { Flags::from_bits_unchecked(0) }, Flags::empty());\n-        assert_eq!(unsafe { Flags::from_bits_unchecked(0b1) }, Flags::A);\n-        assert_eq!(unsafe { Flags::from_bits_unchecked(0b10) }, Flags::B);\n+    fn test_from_bits_retain() {\n+        let extra = Flags::from_bits_retain(0b1000);\n+        assert_eq!(Flags::from_bits_retain(0), Flags::empty());\n+        assert_eq!(Flags::from_bits_retain(0b1), Flags::A);\n+        assert_eq!(Flags::from_bits_retain(0b10), Flags::B);\n \n         assert_eq!(\n-            unsafe { Flags::from_bits_unchecked(0b11) },\n+            Flags::from_bits_retain(0b11),\n             (Flags::A | Flags::B)\n         );\n         assert_eq!(\n-            unsafe { Flags::from_bits_unchecked(0b1000) },\n+            Flags::from_bits_retain(0b1000),\n             (extra | Flags::empty())\n         );\n         assert_eq!(\n-            unsafe { Flags::from_bits_unchecked(0b1001) },\n+            Flags::from_bits_retain(0b1001),\n             (extra | Flags::A)\n         );\n \n-        let extra = unsafe { EmptyFlags::from_bits_unchecked(0b1000) };\n+        let extra = EmptyFlags::from_bits_retain(0b1000);\n         assert_eq!(\n-            unsafe { EmptyFlags::from_bits_unchecked(0b1000) },\n+            EmptyFlags::from_bits_retain(0b1000),\n             (extra | EmptyFlags::empty())\n         );\n     }\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -1157,7 +1357,7 @@ mod tests {\n         assert!(!Flags::A.is_all());\n         assert!(Flags::ABC.is_all());\n \n-        let extra = unsafe { Flags::from_bits_unchecked(0b1000) };\n+        let extra = Flags::from_bits_retain(0b1000);\n         assert!(!extra.is_all());\n         assert!(!(Flags::A | extra).is_all());\n         assert!((Flags::ABC | extra).is_all());\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -1255,7 +1455,7 @@ mod tests {\n \n     #[test]\n     fn test_operators_unchecked() {\n-        let extra = unsafe { Flags::from_bits_unchecked(0b1000) };\n+        let extra = Flags::from_bits_retain(0b1000);\n         let e1 = Flags::A | Flags::C | extra;\n         let e2 = Flags::B | Flags::C;\n         assert_eq!((e1 | e2), (Flags::ABC | extra)); \/\/ union\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -1274,9 +1474,9 @@ mod tests {\n         let ab = Flags::A.union(Flags::B);\n         let ac = Flags::A.union(Flags::C);\n         let bc = Flags::B.union(Flags::C);\n-        assert_eq!(ab.bits, 0b011);\n-        assert_eq!(bc.bits, 0b110);\n-        assert_eq!(ac.bits, 0b101);\n+        assert_eq!(ab.bits(), 0b011);\n+        assert_eq!(bc.bits(), 0b110);\n+        assert_eq!(ac.bits(), 0b101);\n \n         assert_eq!(ab, Flags::B.union(Flags::A));\n         assert_eq!(ac, Flags::C.union(Flags::A));\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -1329,10 +1529,10 @@ mod tests {\n \n     #[test]\n     fn test_set_ops_unchecked() {\n-        let extra = unsafe { Flags::from_bits_unchecked(0b1000) };\n+        let extra = Flags::from_bits_retain(0b1000);\n         let e1 = Flags::A.union(Flags::C).union(extra);\n         let e2 = Flags::B.union(Flags::C);\n-        assert_eq!(e1.bits, 0b1101);\n+        assert_eq!(e1.bits(), 0b1101);\n         assert_eq!(e1.union(e2), (Flags::ABC | extra));\n         assert_eq!(e1.intersection(e2), Flags::C);\n         assert_eq!(e1.difference(e2), Flags::A | extra);\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -1346,11 +1546,12 @@ mod tests {\n     fn test_set_ops_exhaustive() {\n         \/\/ Define a flag that contains gaps to help exercise edge-cases,\n         \/\/ especially around \"unknown\" flags (e.g. ones outside of `all()`\n-        \/\/ `from_bits_unchecked`).\n+        \/\/ `from_bits_retain`).\n         \/\/ - when lhs and rhs both have different sets of unknown flags.\n         \/\/ - unknown flags at both ends, and in the middle\n         \/\/ - cases with \"gaps\".\n         bitflags! {\n+            #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n             struct Test: u16 {\n                 \/\/ Intentionally no `A`\n                 const B = 0b000000010;\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -1364,12 +1565,12 @@ mod tests {\n             }\n         }\n         let iter_test_flags =\n-            || (0..=0b111_1111_1111).map(|bits| unsafe { Test::from_bits_unchecked(bits) });\n+            || (0..=0b111_1111_1111).map(|bits| Test::from_bits_retain(bits));\n \n         for a in iter_test_flags() {\n             assert_eq!(\n                 a.complement(),\n-                Test::from_bits_truncate(!a.bits),\n+                Test::from_bits_truncate(!a.bits()),\n                 \"wrong result: !({:?})\",\n                 a,\n             );\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -1378,37 +1579,37 @@ mod tests {\n                 \/\/ Check that the named operations produce the expected bitwise\n                 \/\/ values.\n                 assert_eq!(\n-                    a.union(b).bits,\n-                    a.bits | b.bits,\n+                    a.union(b).bits(),\n+                    a.bits() | b.bits(),\n                     \"wrong result: `{:?}` | `{:?}`\",\n                     a,\n                     b,\n                 );\n                 assert_eq!(\n-                    a.intersection(b).bits,\n-                    a.bits & b.bits,\n+                    a.intersection(b).bits(),\n+                    a.bits() & b.bits(),\n                     \"wrong result: `{:?}` & `{:?}`\",\n                     a,\n                     b,\n                 );\n                 assert_eq!(\n-                    a.symmetric_difference(b).bits,\n-                    a.bits ^ b.bits,\n+                    a.symmetric_difference(b).bits(),\n+                    a.bits() ^ b.bits(),\n                     \"wrong result: `{:?}` ^ `{:?}`\",\n                     a,\n                     b,\n                 );\n                 assert_eq!(\n-                    a.difference(b).bits,\n-                    a.bits & !b.bits,\n+                    a.difference(b).bits(),\n+                    a.bits() & !b.bits(),\n                     \"wrong result: `{:?}` - `{:?}`\",\n                     a,\n                     b,\n                 );\n                 \/\/ Note: Difference is checked as both `a - b` and `b - a`\n                 assert_eq!(\n-                    b.difference(a).bits,\n-                    b.bits & !a.bits,\n+                    b.difference(a).bits(),\n+                    b.bits() & !a.bits(),\n                     \"wrong result: `{:?}` - `{:?}`\",\n                     b,\n                     a,\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -1577,28 +1778,28 @@ mod tests {\n \n     #[test]\n     fn test_debug() {\n-        assert_eq!(format!(\"{:?}\", Flags::A | Flags::B), \"A | B\");\n-        assert_eq!(format!(\"{:?}\", Flags::empty()), \"(empty)\");\n-        assert_eq!(format!(\"{:?}\", Flags::ABC), \"A | B | C\");\n+        assert_eq!(format!(\"{:?}\", Flags::A | Flags::B), \"Flags(A | B)\");\n+        assert_eq!(format!(\"{:?}\", Flags::empty()), \"Flags(empty)\");\n+        assert_eq!(format!(\"{:?}\", Flags::ABC), \"Flags(A | B | C)\");\n \n-        let extra = unsafe { Flags::from_bits_unchecked(0xb8) };\n+        let extra = Flags::from_bits_retain(0xb8);\n \n-        assert_eq!(format!(\"{:?}\", extra), \"0xb8\");\n-        assert_eq!(format!(\"{:?}\", Flags::A | extra), \"A | 0xb8\");\n+        assert_eq!(format!(\"{:?}\", extra), \"Flags(0xb8)\");\n+        assert_eq!(format!(\"{:?}\", Flags::A | extra), \"Flags(A | 0xb8)\");\n \n         assert_eq!(\n             format!(\"{:?}\", Flags::ABC | extra),\n-            \"A | B | C | ABC | 0xb8\"\n+            \"Flags(A | B | C | ABC | 0xb8)\"\n         );\n \n-        assert_eq!(format!(\"{:?}\", EmptyFlags::empty()), \"(empty)\");\n+        assert_eq!(format!(\"{:?}\", EmptyFlags::empty()), \"EmptyFlags(empty)\");\n     }\n \n     #[test]\n     fn test_binary() {\n         assert_eq!(format!(\"{:b}\", Flags::ABC), \"111\");\n         assert_eq!(format!(\"{:#b}\", Flags::ABC), \"0b111\");\n-        let extra = unsafe { Flags::from_bits_unchecked(0b1010000) };\n+        let extra = Flags::from_bits_retain(0b1010000);\n         assert_eq!(format!(\"{:b}\", Flags::ABC | extra), \"1010111\");\n         assert_eq!(format!(\"{:#b}\", Flags::ABC | extra), \"0b1010111\");\n     }\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -1607,7 +1808,7 @@ mod tests {\n     fn test_octal() {\n         assert_eq!(format!(\"{:o}\", LongFlags::LONG_A), \"177777\");\n         assert_eq!(format!(\"{:#o}\", LongFlags::LONG_A), \"0o177777\");\n-        let extra = unsafe { LongFlags::from_bits_unchecked(0o5000000) };\n+        let extra = LongFlags::from_bits_retain(0o5000000);\n         assert_eq!(format!(\"{:o}\", LongFlags::LONG_A | extra), \"5177777\");\n         assert_eq!(format!(\"{:#o}\", LongFlags::LONG_A | extra), \"0o5177777\");\n     }\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -1616,7 +1817,7 @@ mod tests {\n     fn test_lowerhex() {\n         assert_eq!(format!(\"{:x}\", LongFlags::LONG_A), \"ffff\");\n         assert_eq!(format!(\"{:#x}\", LongFlags::LONG_A), \"0xffff\");\n-        let extra = unsafe { LongFlags::from_bits_unchecked(0xe00000) };\n+        let extra = LongFlags::from_bits_retain(0xe00000);\n         assert_eq!(format!(\"{:x}\", LongFlags::LONG_A | extra), \"e0ffff\");\n         assert_eq!(format!(\"{:#x}\", LongFlags::LONG_A | extra), \"0xe0ffff\");\n     }\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -1625,17 +1826,19 @@ mod tests {\n     fn test_upperhex() {\n         assert_eq!(format!(\"{:X}\", LongFlags::LONG_A), \"FFFF\");\n         assert_eq!(format!(\"{:#X}\", LongFlags::LONG_A), \"0xFFFF\");\n-        let extra = unsafe { LongFlags::from_bits_unchecked(0xe00000) };\n+        let extra = LongFlags::from_bits_retain(0xe00000);\n         assert_eq!(format!(\"{:X}\", LongFlags::LONG_A | extra), \"E0FFFF\");\n         assert_eq!(format!(\"{:#X}\", LongFlags::LONG_A | extra), \"0xE0FFFF\");\n     }\n \n     mod submodule {\n         bitflags! {\n+            #[derive(Clone, Copy)]\n             pub struct PublicFlags: i8 {\n                 const X = 0;\n             }\n \n+            #[derive(Clone, Copy)]\n             struct PrivateFlags: i8 {\n                 const Y = 0;\n             }\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -1659,6 +1862,7 @@ mod tests {\n \n         bitflags! {\n             \/\/\/ baz\n+            #[derive(Clone, Copy)]\n             struct Flags: foo::Bar {\n                 const A = 0b00000001;\n                 #[cfg(foo)]\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -1672,19 +1876,21 @@ mod tests {\n     #[test]\n     fn test_in_function() {\n         bitflags! {\n-           struct Flags: u8 {\n+            #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+            struct Flags: u8 {\n                 const A = 1;\n                 #[cfg(any())] \/\/ false\n                 const B = 2;\n             }\n         }\n         assert_eq!(Flags::all(), Flags::A);\n-        assert_eq!(format!(\"{:?}\", Flags::A), \"A\");\n+        assert_eq!(format!(\"{:?}\", Flags::A), \"Flags(A)\");\n     }\n \n     #[test]\n     fn test_deprecated() {\n         bitflags! {\n+            #[derive(Clone, Copy)]\n             pub struct TestFlags: u32 {\n                 #[deprecated(note = \"Use something else.\")]\n                 const ONE = 1;\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -1696,6 +1902,7 @@ mod tests {\n     fn test_pub_crate() {\n         mod module {\n             bitflags! {\n+                #[derive(Clone, Copy)]\n                 pub (crate) struct Test: u8 {\n                     const FOO = 1;\n                 }\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -1712,6 +1919,7 @@ mod tests {\n                 bitflags! {\n                     \/\/ `pub (in super)` means only the module `module` will\n                     \/\/ be able to access this.\n+                    #[derive(Clone, Copy)]\n                     pub (in super) struct Test: u8 {\n                         const FOO = 1;\n                     }\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -1737,6 +1945,7 @@ mod tests {\n     #[test]\n     fn test_zero_value_flags() {\n         bitflags! {\n+            #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n             struct Flags: u32 {\n                 const NONE = 0b0;\n                 const SOME = 0b1;\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -1747,8 +1956,8 @@ mod tests {\n         assert!(Flags::SOME.contains(Flags::NONE));\n         assert!(Flags::NONE.is_empty());\n \n-        assert_eq!(format!(\"{:?}\", Flags::empty()), \"(empty)\");\n-        assert_eq!(format!(\"{:?}\", Flags::SOME), \"NONE | SOME\");\n+        assert_eq!(format!(\"{:?}\", Flags::empty()), \"Flags(empty)\");\n+        assert_eq!(format!(\"{:?}\", Flags::SOME), \"Flags(NONE | SOME)\");\n     }\n \n     #[test]\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -1759,69 +1968,33 @@ mod tests {\n     #[test]\n     fn test_u128_bitflags() {\n         bitflags! {\n-            struct Flags128: u128 {\n+            #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+            struct Flags: u128 {\n                 const A = 0x0000_0000_0000_0000_0000_0000_0000_0001;\n                 const B = 0x0000_0000_0000_1000_0000_0000_0000_0000;\n                 const C = 0x8000_0000_0000_0000_0000_0000_0000_0000;\n-                const ABC = Self::A.bits | Self::B.bits | Self::C.bits;\n+                const ABC = Self::A.bits() | Self::B.bits() | Self::C.bits();\n             }\n         }\n \n-        assert_eq!(Flags128::ABC, Flags128::A | Flags128::B | Flags128::C);\n-        assert_eq!(Flags128::A.bits, 0x0000_0000_0000_0000_0000_0000_0000_0001);\n-        assert_eq!(Flags128::B.bits, 0x0000_0000_0000_1000_0000_0000_0000_0000);\n-        assert_eq!(Flags128::C.bits, 0x8000_0000_0000_0000_0000_0000_0000_0000);\n+        assert_eq!(Flags::ABC, Flags::A | Flags::B | Flags::C);\n+        assert_eq!(Flags::A.bits(), 0x0000_0000_0000_0000_0000_0000_0000_0001);\n+        assert_eq!(Flags::B.bits(), 0x0000_0000_0000_1000_0000_0000_0000_0000);\n+        assert_eq!(Flags::C.bits(), 0x8000_0000_0000_0000_0000_0000_0000_0000);\n         assert_eq!(\n-            Flags128::ABC.bits,\n+            Flags::ABC.bits(),\n             0x8000_0000_0000_1000_0000_0000_0000_0001\n         );\n-        assert_eq!(format!(\"{:?}\", Flags128::A), \"A\");\n-        assert_eq!(format!(\"{:?}\", Flags128::B), \"B\");\n-        assert_eq!(format!(\"{:?}\", Flags128::C), \"C\");\n-        assert_eq!(format!(\"{:?}\", Flags128::ABC), \"A | B | C\");\n-    }\n-\n-    #[test]\n-    fn test_serde_bitflags_serialize() {\n-        let flags = SerdeFlags::A | SerdeFlags::B;\n-\n-        let serialized = serde_json::to_string(&flags).unwrap();\n-\n-        assert_eq!(serialized, r#\"{\"bits\":3}\"#);\n-    }\n-\n-    #[test]\n-    fn test_serde_bitflags_deserialize() {\n-        let deserialized: SerdeFlags = serde_json::from_str(r#\"{\"bits\":12}\"#).unwrap();\n-\n-        let expected = SerdeFlags::C | SerdeFlags::D;\n-\n-        assert_eq!(deserialized.bits, expected.bits);\n-    }\n-\n-    #[test]\n-    fn test_serde_bitflags_roundtrip() {\n-        let flags = SerdeFlags::A | SerdeFlags::B;\n-\n-        let deserialized: SerdeFlags =\n-            serde_json::from_str(&serde_json::to_string(&flags).unwrap()).unwrap();\n-\n-        assert_eq!(deserialized.bits, flags.bits);\n-    }\n-\n-    bitflags! {\n-        #[derive(serde_derive::Serialize, serde_derive::Deserialize)]\n-        struct SerdeFlags: u32 {\n-            const A = 1;\n-            const B = 2;\n-            const C = 4;\n-            const D = 8;\n-        }\n+        assert_eq!(format!(\"{:?}\", Flags::A), \"Flags(A)\");\n+        assert_eq!(format!(\"{:?}\", Flags::B), \"Flags(B)\");\n+        assert_eq!(format!(\"{:?}\", Flags::C), \"Flags(C)\");\n+        assert_eq!(format!(\"{:?}\", Flags::ABC), \"Flags(A | B | C)\");\n     }\n \n     #[test]\n     fn test_from_bits_edge_cases() {\n         bitflags! {\n+            #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n             struct Flags: u8 {\n                 const A = 0b00000001;\n                 const BC = 0b00000110;\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -1837,6 +2010,7 @@ mod tests {\n     #[test]\n     fn test_from_bits_truncate_edge_cases() {\n         bitflags! {\n+            #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n             struct Flags: u8 {\n                 const A = 0b00000001;\n                 const BC = 0b00000110;\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -1852,6 +2026,7 @@ mod tests {\n     #[test]\n     fn test_iter() {\n         bitflags! {\n+            #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n             struct Flags: u32 {\n                 const ONE  = 0b001;\n                 const TWO  = 0b010;\ndiff --git \/dev\/null b\/src\/serde_support.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/src\/serde_support.rs\n@@ -0,0 +1,84 @@\n+use core::fmt;\n+use serde::{Serializer, Deserializer, Serialize, Deserialize, ser::SerializeStruct, de::{Error, MapAccess, Visitor}};\n+\n+\/\/ These methods are compatible with the result of `#[derive(Serialize, Deserialize)]` on bitflags `1.0` types\n+\n+pub fn serialize_bits_default<B: Serialize, S: Serializer>(name: &'static str, bits: &B, serializer: S) -> Result<S::Ok, S::Error> {\n+    let mut serialize_struct = serializer.serialize_struct(name, 1)?;\n+    serialize_struct.serialize_field(\"bits\", bits)?;\n+    serialize_struct.end()\n+}\n+\n+pub fn deserialize_bits_default<'de, B: Deserialize<'de>, D: Deserializer<'de>>(name: &'static str, deserializer: D) -> Result<B, D::Error> {\n+    struct BitsVisitor<T>(core::marker::PhantomData<T>);\n+\n+    impl<'de, T: Deserialize<'de>> Visitor<'de> for BitsVisitor<T> {\n+        type Value = T;\n+\n+        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+            formatter.write_str(\"a primitive bitflags value wrapped in a struct\")\n+        }\n+\n+        fn visit_map<A: MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {\n+            let mut bits = None;\n+\n+            while let Some(key) = map.next_key()? {\n+                match key {\n+                    \"bits\" => {\n+                        if bits.is_some() {\n+                            return Err(Error::duplicate_field(\"bits\"));\n+                        }\n+\n+                        bits = Some(map.next_value()?);\n+                    }\n+                    v => return Err(Error::unknown_field(v, &[\"bits\"]))\n+                }\n+            }\n+\n+            bits.ok_or_else(|| Error::missing_field(\"bits\"))\n+        }\n+    }\n+\n+    deserializer.deserialize_struct(name, &[\"bits\"], BitsVisitor(Default::default()))\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    bitflags! {\n+        #[derive(serde_derive::Serialize, serde_derive::Deserialize)]\n+        struct SerdeFlags: u32 {\n+            const A = 1;\n+            const B = 2;\n+            const C = 4;\n+            const D = 8;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_serde_bitflags_default_serialize() {\n+        let flags = SerdeFlags::A | SerdeFlags::B;\n+\n+        let serialized = serde_json::to_string(&flags).unwrap();\n+\n+        assert_eq!(serialized, r#\"{\"bits\":3}\"#);\n+    }\n+\n+    #[test]\n+    fn test_serde_bitflags_default_deserialize() {\n+        let deserialized: SerdeFlags = serde_json::from_str(r#\"{\"bits\":12}\"#).unwrap();\n+\n+        let expected = SerdeFlags::C | SerdeFlags::D;\n+\n+        assert_eq!(deserialized.bits(), expected.bits());\n+    }\n+\n+    #[test]\n+    fn test_serde_bitflags_default_roundtrip() {\n+        let flags = SerdeFlags::A | SerdeFlags::B;\n+\n+        let deserialized: SerdeFlags =\n+            serde_json::from_str(&serde_json::to_string(&flags).unwrap()).unwrap();\n+\n+        assert_eq!(deserialized.bits(), flags.bits());\n+    }\n+}\n\\ No newline at end of file\ndiff --git a\/tests\/basic.rs b\/tests\/basic.rs\n--- a\/tests\/basic.rs\n+++ b\/tests\/basic.rs\n@@ -4,13 +4,14 @@ use bitflags::bitflags;\n \n bitflags! {\n     \/\/\/ baz\n+    #[derive(Debug, PartialEq, Eq)]\n     struct Flags: u32 {\n         const A = 0b00000001;\n         #[doc = \"bar\"]\n         const B = 0b00000010;\n         const C = 0b00000100;\n         #[doc = \"foo\"]\n-        const ABC = Flags::A.bits | Flags::B.bits | Flags::C.bits;\n+        const ABC = Flags::A.bits() | Flags::B.bits() | Flags::C.bits();\n     }\n }\n \ndiff --git a\/tests\/compile-fail\/impls\/copy.stderr \/dev\/null\n--- a\/tests\/compile-fail\/impls\/copy.stderr\n+++ \/dev\/null\n@@ -1,27 +0,0 @@\n-error[E0119]: conflicting implementations of trait `std::marker::Copy` for type `Flags`\n- --> $DIR\/copy.rs:3:1\n-  |\n-3 | \/ bitflags! {\n-4 | |     #[derive(Clone, Copy)]\n-  | |                     ---- first implementation here\n-5 | |     struct Flags: u32 {\n-6 | |         const A = 0b00000001;\n-7 | |     }\n-8 | | }\n-  | |_^ conflicting implementation for `Flags`\n-  |\n-  = note: this error originates in the derive macro `Copy` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0119]: conflicting implementations of trait `std::clone::Clone` for type `Flags`\n- --> $DIR\/copy.rs:3:1\n-  |\n-3 | \/ bitflags! {\n-4 | |     #[derive(Clone, Copy)]\n-  | |              ----- first implementation here\n-5 | |     struct Flags: u32 {\n-6 | |         const A = 0b00000001;\n-7 | |     }\n-8 | | }\n-  | |_^ conflicting implementation for `Flags`\n-  |\n-  = note: this error originates in the derive macro `Clone` (in Nightly builds, run with -Z macro-backtrace for more info)\ndiff --git a\/tests\/compile-fail\/impls\/eq.stderr \/dev\/null\n--- a\/tests\/compile-fail\/impls\/eq.stderr\n+++ \/dev\/null\n@@ -1,55 +0,0 @@\n-error[E0119]: conflicting implementations of trait `std::marker::StructuralPartialEq` for type `Flags`\n- --> $DIR\/eq.rs:3:1\n-  |\n-3 | \/ bitflags! {\n-4 | |     #[derive(PartialEq, Eq)]\n-  | |              --------- first implementation here\n-5 | |     struct Flags: u32 {\n-6 | |         const A = 0b00000001;\n-7 | |     }\n-8 | | }\n-  | |_^ conflicting implementation for `Flags`\n-  |\n-  = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0119]: conflicting implementations of trait `std::cmp::PartialEq` for type `Flags`\n- --> $DIR\/eq.rs:3:1\n-  |\n-3 | \/ bitflags! {\n-4 | |     #[derive(PartialEq, Eq)]\n-  | |              --------- first implementation here\n-5 | |     struct Flags: u32 {\n-6 | |         const A = 0b00000001;\n-7 | |     }\n-8 | | }\n-  | |_^ conflicting implementation for `Flags`\n-  |\n-  = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0119]: conflicting implementations of trait `std::marker::StructuralEq` for type `Flags`\n- --> $DIR\/eq.rs:3:1\n-  |\n-3 | \/ bitflags! {\n-4 | |     #[derive(PartialEq, Eq)]\n-  | |                         -- first implementation here\n-5 | |     struct Flags: u32 {\n-6 | |         const A = 0b00000001;\n-7 | |     }\n-8 | | }\n-  | |_^ conflicting implementation for `Flags`\n-  |\n-  = note: this error originates in the derive macro `Eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0119]: conflicting implementations of trait `std::cmp::Eq` for type `Flags`\n- --> $DIR\/eq.rs:3:1\n-  |\n-3 | \/ bitflags! {\n-4 | |     #[derive(PartialEq, Eq)]\n-  | |                         -- first implementation here\n-5 | |     struct Flags: u32 {\n-6 | |         const A = 0b00000001;\n-7 | |     }\n-8 | | }\n-  | |_^ conflicting implementation for `Flags`\n-  |\n-  = note: this error originates in the derive macro `Eq` (in Nightly builds, run with -Z macro-backtrace for more info)\ndiff --git a\/tests\/compile-fail\/non_integer_base\/all_defined.stderr b\/tests\/compile-fail\/non_integer_base\/all_defined.stderr\n--- a\/tests\/compile-fail\/non_integer_base\/all_defined.stderr\n+++ b\/tests\/compile-fail\/non_integer_base\/all_defined.stderr\n@@ -4,6 +4,16 @@ error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n 116 |     struct Flags128: MyInt {\n     |                      ^^^^^ the trait `Bits` is not implemented for `MyInt`\n     |\n+    = help: the following other types implement trait `Bits`:\n+              i128\n+              i16\n+              i32\n+              i64\n+              i8\n+              u128\n+              u16\n+              u32\n+            and 2 others\n note: required by a bound in `bitflags::BitFlags::Bits`\n    --> src\/bitflags_trait.rs\n     |\ndiff --git a\/tests\/compile-fail\/non_integer_base\/all_defined.stderr b\/tests\/compile-fail\/non_integer_base\/all_defined.stderr\n--- a\/tests\/compile-fail\/non_integer_base\/all_defined.stderr\n+++ b\/tests\/compile-fail\/non_integer_base\/all_defined.stderr\n@@ -22,7 +32,17 @@ error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n 121 | | }\n     | |_^ the trait `Bits` is not implemented for `MyInt`\n     |\n-    = note: this error originates in the macro `__impl_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+    = help: the following other types implement trait `Bits`:\n+              i128\n+              i16\n+              i32\n+              i64\n+              i8\n+              u128\n+              u16\n+              u32\n+            and 2 others\n+    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n    --> tests\/compile-fail\/non_integer_base\/all_defined.rs:115:1\ndiff --git a\/tests\/compile-fail\/non_integer_base\/all_defined.stderr b\/tests\/compile-fail\/non_integer_base\/all_defined.stderr\n--- a\/tests\/compile-fail\/non_integer_base\/all_defined.stderr\n+++ b\/tests\/compile-fail\/non_integer_base\/all_defined.stderr\n@@ -36,7 +56,17 @@ error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n 121 | | }\n     | |_^ the trait `Bits` is not implemented for `MyInt`\n     |\n-    = note: this error originates in the macro `__impl_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+    = help: the following other types implement trait `Bits`:\n+              i128\n+              i16\n+              i32\n+              i64\n+              i8\n+              u128\n+              u16\n+              u32\n+            and 2 others\n+    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n    --> tests\/compile-fail\/non_integer_base\/all_defined.rs:115:1\ndiff --git a\/tests\/compile-fail\/non_integer_base\/all_defined.stderr b\/tests\/compile-fail\/non_integer_base\/all_defined.stderr\n--- a\/tests\/compile-fail\/non_integer_base\/all_defined.stderr\n+++ b\/tests\/compile-fail\/non_integer_base\/all_defined.stderr\n@@ -50,7 +80,69 @@ error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n 121 | | }\n     | |_^ the trait `Bits` is not implemented for `MyInt`\n     |\n-    = note: this error originates in the macro `__impl_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+    = help: the following other types implement trait `Bits`:\n+              i128\n+              i16\n+              i32\n+              i64\n+              i8\n+              u128\n+              u16\n+              u32\n+            and 2 others\n+    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: can't compare `MyInt` with `_` in const contexts\n+   --> tests\/compile-fail\/non_integer_base\/all_defined.rs:115:1\n+    |\n+115 | \/ bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^ no implementation for `MyInt == _`\n+    |\n+    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n+note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests\/compile-fail\/non_integer_base\/all_defined.rs:115:1\n+    |\n+115 | \/ bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: can't compare `MyInt` with `_` in const contexts\n+   --> tests\/compile-fail\/non_integer_base\/all_defined.rs:115:1\n+    |\n+115 | \/ bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^ no implementation for `MyInt == _`\n+    |\n+    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n+note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests\/compile-fail\/non_integer_base\/all_defined.rs:115:1\n+    |\n+115 | \/ bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n    --> tests\/compile-fail\/non_integer_base\/all_defined.rs:115:1\ndiff --git a\/tests\/compile-fail\/non_integer_base\/all_defined.stderr b\/tests\/compile-fail\/non_integer_base\/all_defined.stderr\n--- a\/tests\/compile-fail\/non_integer_base\/all_defined.stderr\n+++ b\/tests\/compile-fail\/non_integer_base\/all_defined.stderr\n@@ -64,4 +156,142 @@ error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n 121 | | }\n     | |_^ the trait `Bits` is not implemented for `MyInt`\n     |\n-    = note: this error originates in the macro `__impl_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+    = help: the following other types implement trait `Bits`:\n+              i128\n+              i16\n+              i32\n+              i64\n+              i8\n+              u128\n+              u16\n+              u32\n+            and 2 others\n+    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n+   --> tests\/compile-fail\/non_integer_base\/all_defined.rs:115:1\n+    |\n+115 | \/ bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^ the trait `Bits` is not implemented for `MyInt`\n+    |\n+    = help: the following other types implement trait `Bits`:\n+              i128\n+              i16\n+              i32\n+              i64\n+              i8\n+              u128\n+              u16\n+              u32\n+            and 2 others\n+    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: can't compare `MyInt` with `_` in const contexts\n+   --> tests\/compile-fail\/non_integer_base\/all_defined.rs:115:1\n+    |\n+115 | \/ bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^ no implementation for `MyInt == _`\n+    |\n+    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n+note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests\/compile-fail\/non_integer_base\/all_defined.rs:115:1\n+    |\n+115 | \/ bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: can't compare `MyInt` with `_` in const contexts\n+   --> tests\/compile-fail\/non_integer_base\/all_defined.rs:115:1\n+    |\n+115 | \/ bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^ no implementation for `MyInt == _`\n+    |\n+    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n+note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests\/compile-fail\/non_integer_base\/all_defined.rs:115:1\n+    |\n+115 | \/ bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: can't compare `MyInt` with `_` in const contexts\n+   --> tests\/compile-fail\/non_integer_base\/all_defined.rs:115:1\n+    |\n+115 | \/ bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^ no implementation for `MyInt == _`\n+    |\n+    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n+note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests\/compile-fail\/non_integer_base\/all_defined.rs:115:1\n+    |\n+115 | \/ bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: can't compare `MyInt` with `_` in const contexts\n+   --> tests\/compile-fail\/non_integer_base\/all_defined.rs:115:1\n+    |\n+115 | \/ bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^ no implementation for `MyInt == _`\n+    |\n+    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n+note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests\/compile-fail\/non_integer_base\/all_defined.rs:115:1\n+    |\n+115 | \/ bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\ndiff --git a\/tests\/compile-fail\/non_integer_base\/all_missing.stderr b\/tests\/compile-fail\/non_integer_base\/all_missing.stderr\n--- a\/tests\/compile-fail\/non_integer_base\/all_missing.stderr\n+++ b\/tests\/compile-fail\/non_integer_base\/all_missing.stderr\n@@ -1,5 +1,5 @@\n error[E0204]: the trait `Copy` may not be implemented for this type\n-  --> $DIR\/all_missing.rs:5:1\n+  --> tests\/compile-fail\/non_integer_base\/all_missing.rs:5:1\n    |\n 5  | \/ bitflags! {\n 6  | |     struct Flags128: MyInt {\ndiff --git a\/tests\/compile-fail\/non_integer_base\/all_missing.stderr b\/tests\/compile-fail\/non_integer_base\/all_missing.stderr\n--- a\/tests\/compile-fail\/non_integer_base\/all_missing.stderr\n+++ b\/tests\/compile-fail\/non_integer_base\/all_missing.stderr\n@@ -10,4 +10,4 @@ error[E0204]: the trait `Copy` may not be implemented for this type\n 11 | | }\n    | |_^ this field does not implement `Copy`\n    |\n-   = note: this error originates in the derive macro `Copy` (in Nightly builds, run with -Z macro-backtrace for more info)\n+   = note: this error originates in the derive macro `Copy` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\ndiff --git \/dev\/null b\/tests\/compile-fail\/redefined.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/tests\/compile-fail\/redefined.rs\n@@ -0,0 +1,14 @@\n+#[macro_use]\n+extern crate bitflags;\n+\n+bitflags! {\n+    pub struct Flags1 {\n+        const A = 1;\n+    }\n+}\n+\n+bitflags! {\n+    pub struct Flags1 {\n+        const A = 1;\n+    }\n+}\ndiff --git \/dev\/null b\/tests\/compile-fail\/redefined.stderr\nnew file mode 100644\n--- \/dev\/null\n+++ b\/tests\/compile-fail\/redefined.stderr\n@@ -0,0 +1,17 @@\n+error: no rules expected the token `{`\n+ --> tests\/compile-fail\/redefined.rs:5:23\n+  |\n+5 |     pub struct Flags1 {\n+  |                       ^ no rules expected this token in macro call\n+\n+error: no rules expected the token `{`\n+  --> tests\/compile-fail\/redefined.rs:11:23\n+   |\n+11 |     pub struct Flags1 {\n+   |                       ^ no rules expected this token in macro call\n+\n+error[E0601]: `main` function not found in crate `$CRATE`\n+  --> tests\/compile-fail\/redefined.rs:14:2\n+   |\n+14 | }\n+   |  ^ consider adding a `main` function to `$DIR\/tests\/compile-fail\/redefined.rs`\ndiff --git \/dev\/null b\/tests\/compile-fail\/syntax\/missing_type.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/tests\/compile-fail\/syntax\/missing_type.rs\n@@ -0,0 +1,8 @@\n+#[macro_use]\n+extern crate bitflags;\n+\n+bitflags! {\n+    pub struct Flags1 {\n+        const A = 1;\n+    }\n+}\ndiff --git \/dev\/null b\/tests\/compile-fail\/syntax\/missing_type.stderr\nnew file mode 100644\n--- \/dev\/null\n+++ b\/tests\/compile-fail\/syntax\/missing_type.stderr\n@@ -0,0 +1,11 @@\n+error: no rules expected the token `{`\n+ --> tests\/compile-fail\/syntax\/missing_type.rs:5:23\n+  |\n+5 |     pub struct Flags1 {\n+  |                       ^ no rules expected this token in macro call\n+\n+error[E0601]: `main` function not found in crate `$CRATE`\n+ --> tests\/compile-fail\/syntax\/missing_type.rs:8:2\n+  |\n+8 | }\n+  |  ^ consider adding a `main` function to `$DIR\/tests\/compile-fail\/syntax\/missing_type.rs`\ndiff --git \/dev\/null b\/tests\/compile-fail\/syntax\/missing_value.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/tests\/compile-fail\/syntax\/missing_value.rs\n@@ -0,0 +1,8 @@\n+#[macro_use]\n+extern crate bitflags;\n+\n+bitflags! {\n+    pub struct Flags1 {\n+        const A;\n+    }\n+}\ndiff --git \/dev\/null b\/tests\/compile-fail\/syntax\/missing_value.stderr\nnew file mode 100644\n--- \/dev\/null\n+++ b\/tests\/compile-fail\/syntax\/missing_value.stderr\n@@ -0,0 +1,11 @@\n+error: no rules expected the token `{`\n+ --> tests\/compile-fail\/syntax\/missing_value.rs:5:23\n+  |\n+5 |     pub struct Flags1 {\n+  |                       ^ no rules expected this token in macro call\n+\n+error[E0601]: `main` function not found in crate `$CRATE`\n+ --> tests\/compile-fail\/syntax\/missing_value.rs:8:2\n+  |\n+8 | }\n+  |  ^ consider adding a `main` function to `$DIR\/tests\/compile-fail\/syntax\/missing_value.rs`\ndiff --git a\/tests\/compile-fail\/trait\/custom_impl.rs b\/tests\/compile-fail\/trait\/custom_impl.rs\n--- a\/tests\/compile-fail\/trait\/custom_impl.rs\n+++ b\/tests\/compile-fail\/trait\/custom_impl.rs\n@@ -25,7 +25,7 @@ impl BitFlags for BootlegFlags {\n         unimplemented!()\n     }\n \n-    unsafe fn from_bits_unchecked(_: u32) -> BootlegFlags {\n+    fn from_bits_retain(_: u32) -> BootlegFlags {\n         unimplemented!()\n     }\n \ndiff --git a\/tests\/compile-fail\/visibility\/private_field.rs \/dev\/null\n--- a\/tests\/compile-fail\/visibility\/private_field.rs\n+++ \/dev\/null\n@@ -1,13 +0,0 @@\n-mod example {\n-    use bitflags::bitflags;\n-\n-    bitflags! {\n-        pub struct Flags1: u32 {\n-            const FLAG_A = 0b00000001;\n-        }\n-    }\n-}\n-\n-fn main() {\n-    let flag1 = example::Flags1::FLAG_A.bits;\n-}\ndiff --git a\/tests\/compile-fail\/visibility\/private_field.stderr \/dev\/null\n--- a\/tests\/compile-fail\/visibility\/private_field.stderr\n+++ \/dev\/null\n@@ -1,10 +0,0 @@\n-error[E0616]: field `bits` of struct `Flags1` is private\n-  --> $DIR\/private_field.rs:12:41\n-   |\n-12 |     let flag1 = example::Flags1::FLAG_A.bits;\n-   |                                         ^^^^ private field\n-   |\n-help: a method `bits` also exists, call it with parentheses\n-   |\n-12 |     let flag1 = example::Flags1::FLAG_A.bits();\n-   |                                             ++\ndiff --git a\/tests\/compile-fail\/visibility\/private_flags.rs b\/tests\/compile-fail\/visibility\/private_flags.rs\n--- a\/tests\/compile-fail\/visibility\/private_flags.rs\n+++ b\/tests\/compile-fail\/visibility\/private_flags.rs\n@@ -13,6 +13,6 @@ mod example {\n }\n \n fn main() {\n-    let flag1 = example::Flags1::FLAG_A;\n-    let flag2 = example::Flags2::FLAG_B;\n+    let _ = example::Flags1::FLAG_A;\n+    let _ = example::Flags2::FLAG_B;\n }\ndiff --git a\/tests\/compile-fail\/visibility\/private_flags.stderr b\/tests\/compile-fail\/visibility\/private_flags.stderr\n--- a\/tests\/compile-fail\/visibility\/private_flags.stderr\n+++ b\/tests\/compile-fail\/visibility\/private_flags.stderr\n@@ -1,11 +1,11 @@\n error[E0603]: struct `Flags2` is private\n-  --> $DIR\/private_flags.rs:17:26\n+  --> tests\/compile-fail\/visibility\/private_flags.rs:17:22\n    |\n-17 |     let flag2 = example::Flags2::FLAG_B;\n-   |                          ^^^^^^ private struct\n+17 |     let _ = example::Flags2::FLAG_B;\n+   |                      ^^^^^^ private struct\n    |\n note: the struct `Flags2` is defined here\n-  --> $DIR\/private_flags.rs:4:5\n+  --> tests\/compile-fail\/visibility\/private_flags.rs:4:5\n    |\n 4  | \/     bitflags! {\n 5  | |         pub struct Flags1: u32 {\ndiff --git a\/tests\/compile-pass\/impls\/fmt.rs b\/tests\/compile-pass\/impls\/fmt.rs\n--- a\/tests\/compile-pass\/impls\/fmt.rs\n+++ b\/tests\/compile-pass\/impls\/fmt.rs\n@@ -1,6 +1,7 @@\n use bitflags::bitflags;\n \n bitflags! {\n+    #[derive(Debug)]\n     struct Flags: u8 {\n         const TWO = 0x2;\n     }\ndiff --git a\/tests\/compile-pass\/impls\/fmt.rs b\/tests\/compile-pass\/impls\/fmt.rs\n--- a\/tests\/compile-pass\/impls\/fmt.rs\n+++ b\/tests\/compile-pass\/impls\/fmt.rs\n@@ -8,7 +9,7 @@ bitflags! {\n \n fn main() {\n     \/\/ bug #267 (https:\/\/github.com\/bitflags\/bitflags\/issues\/267)\n-    let flags = unsafe { Flags::from_bits_unchecked(0b11) };\n-    assert_eq!(format!(\"{:?}\", flags), \"TWO | 0x1\");\n-    assert_eq!(format!(\"{:#?}\", flags), \"TWO | 0x1\");\n+    let flags = Flags::from_bits_retain(0b11);\n+    assert_eq!(format!(\"{:?}\", flags), \"Flags(TWO | 0x1)\");\n+    assert_eq!(format!(\"{:#?}\", flags), \"Flags(\\n    TWO | 0x1,\\n)\");\n }\ndiff --git \/dev\/null b\/tests\/compile-pass\/item_positions.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/tests\/compile-pass\/item_positions.rs\n@@ -0,0 +1,52 @@\n+#[macro_use]\n+extern crate bitflags;\n+\n+bitflags! {\n+    pub struct Flags1: u32 {\n+        const A = 1;\n+    }\n+}\n+\n+bitflags! {\n+    pub struct Flags2: u32 {\n+        const A = 1;\n+    }\n+}\n+\n+pub mod nested {\n+    bitflags! {\n+        pub struct Flags1: u32 {\n+            const A = 1;\n+        }\n+    }\n+\n+    bitflags! {\n+        pub struct Flags2: u32 {\n+            const A = 1;\n+        }\n+    }\n+}\n+\n+pub const _: () = {\n+    bitflags! {\n+        pub struct Flags1: u32 {\n+            const A = 1;\n+        }\n+    }\n+};\n+\n+fn main() {\n+    bitflags! {\n+        pub struct Flags1: u32 {\n+            const A = 1;\n+        }\n+    }\n+\n+    let _ = {\n+        bitflags! {\n+            pub struct Flags2: u32 {\n+                const A = 1;\n+            }\n+        }\n+    };\n+}\ndiff --git a\/tests\/compile-pass\/no_prelude.rs b\/tests\/compile-pass\/no_prelude.rs\n--- a\/tests\/compile-pass\/no_prelude.rs\n+++ b\/tests\/compile-pass\/no_prelude.rs\n@@ -7,7 +7,7 @@ bitflags::bitflags! {\n         const A = 0b00000001;\n         const B = 0b00000010;\n         const C = 0b00000100;\n-        const ABC = Flags::A.bits | Flags::B.bits | Flags::C.bits;\n+        const ABC = Flags::A.bits() | Flags::B.bits() | Flags::C.bits();\n     }\n }\n \ndiff --git a\/tests\/compile-pass\/redefinition\/macros.rs b\/tests\/compile-pass\/redefinition\/macros.rs\n--- a\/tests\/compile-pass\/redefinition\/macros.rs\n+++ b\/tests\/compile-pass\/redefinition\/macros.rs\n@@ -13,6 +13,7 @@ macro_rules! write {\n }\n \n bitflags! {\n+    #[derive(Debug)]\n     struct Test: u8 {\n         const A = 1;\n     }\ndiff --git a\/tests\/compile-pass\/redefinition\/macros.rs b\/tests\/compile-pass\/redefinition\/macros.rs\n--- a\/tests\/compile-pass\/redefinition\/macros.rs\n+++ b\/tests\/compile-pass\/redefinition\/macros.rs\n@@ -20,5 +21,5 @@ bitflags! {\n \n fn main() {\n     \/\/ Just make sure we don't call the redefined `stringify` or `write` macro\n-    assert_eq!(format!(\"{:?}\", unsafe { Test::from_bits_unchecked(0b11) }), \"A | 0x2\");\n+    assert_eq!(format!(\"{:?}\", Test::from_bits_retain(0b11)), \"Test(A | 0x2)\");\n }\ndiff --git a\/tests\/compile-pass\/visibility\/bits_field.rs b\/tests\/compile-pass\/visibility\/bits_field.rs\n--- a\/tests\/compile-pass\/visibility\/bits_field.rs\n+++ b\/tests\/compile-pass\/visibility\/bits_field.rs\n@@ -7,5 +7,5 @@ bitflags! {\n }\n \n fn main() {\n-    assert_eq!(0b00000001, Flags1::FLAG_A.bits);\n+    assert_eq!(0b00000001, Flags1::FLAG_A.bits());\n }\ndiff --git \/dev\/null b\/tests\/smoke-test\/Cargo.toml\nnew file mode 100644\n--- \/dev\/null\n+++ b\/tests\/smoke-test\/Cargo.toml\n@@ -0,0 +1,8 @@\n+[package]\n+name = \"bitflags-smoke-test\"\n+version = \"0.0.0\"\n+edition = \"2021\"\n+publish = false\n+\n+[dependencies.bitflags]\n+path = \"..\/..\/\"\ndiff --git \/dev\/null b\/tests\/smoke-test\/src\/main.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/tests\/smoke-test\/src\/main.rs\n@@ -0,0 +1,15 @@\n+use bitflags::bitflags;\n+\n+bitflags! {\n+    #[derive(Debug)]\n+    pub struct Flags: u32 {\n+        const A = 0b00000001;\n+        const B = 0b00000010;\n+        const C = 0b00000100;\n+        const ABC = Flags::A.bits() | Flags::B.bits() | Flags::C.bits();\n+    }\n+}\n+\n+fn main() {\n+    println!(\"{:?}\", Flags::ABC);\n+}\n","hints_text":"Related: #188, #200, #207, #208, #211\n@niklasf @KodrAus worked on #200 \nBump!\r\n\r\nI'll do the PR if needed\nHi @CasperN! :wave:\r\n\r\nWe can't consider any changes to the `bits()` method, because the library is already stable.\r\n\r\nThe way we modeled this originally was that the flags represents a closed enum, where the set specified in the definition is the complete set of possible flags the enum could combine. Since not all valid bit patterns of the underlying integer type are valid bit patterns of the flags it's not safe for us to simply accept any integer and treat it as valid flags. So we made the `unchecked` method unsafe.\r\n\r\nIf we wanted to clean up the semantics we could consider allowing an `#[open]` attribute or something on the `bitflags!` definition itself, so you'd declare an open bitflags that could happily accept any integer, assuming it's not the source-of-truth for what flags exist:\r\n\r\n```rust\r\nbitflags! {\r\n    #[open]\r\n    struct Flags: u32 {\r\n        const A = 0b00000001;\r\n        const B = 0b00000010;\r\n    }\r\n}\r\n```\r\n\r\nThen let these `#[open]` bitflags have `#[repr(transparent)]` and so can be soundly transmuted to and from the given integer type, making `from_bits_unchecked` safe.\r\n\r\nWhat do you think?\nWe could also use `#[repr(transparent)]` for this. I don\u2019t think that\u2019s too much of a semantic hijacking, so long as it also does apply the attribute.","base_commit":"810dc35aba3df7314de01b93c7aa137968e925d4","issue_numbers":["228"],"created_at":"2022-05-25T04:14:38Z","pull_number":282,"instance_id":"bitflags__bitflags-282","patch":"diff --git a\/src\/bitflags_trait.rs b\/src\/bitflags_trait.rs\n--- a\/src\/bitflags_trait.rs\n+++ b\/src\/bitflags_trait.rs\n@@ -1,8 +1,5 @@\n use core::ops::{BitAnd, BitAndAssign, BitOr, BitOrAssign, BitXor, BitXorAssign, Not};\n \n-#[doc(hidden)]\n-pub trait ImplementedByBitFlagsMacro {}\n-\n \/\/\/ A trait that is automatically implemented for all bitflags.\n \/\/\/\n \/\/\/ It should not be implemented manually.\ndiff --git a\/src\/bitflags_trait.rs b\/src\/bitflags_trait.rs\n--- a\/src\/bitflags_trait.rs\n+++ b\/src\/bitflags_trait.rs\n@@ -25,16 +22,7 @@ pub trait BitFlags: ImplementedByBitFlagsMacro {\n     fn from_bits_truncate(bits: Self::Bits) -> Self;\n     \/\/\/ Convert from underlying bit representation, preserving all\n     \/\/\/ bits (even those not corresponding to a defined flag).\n-    \/\/\/\n-    \/\/\/ # Safety\n-    \/\/\/\n-    \/\/\/ The caller of the `bitflags!` macro can chose to allow or\n-    \/\/\/ disallow extra bits for their bitflags type.\n-    \/\/\/\n-    \/\/\/ The caller of `from_bits_unchecked()` has to ensure that\n-    \/\/\/ all bits correspond to a defined flag or that extra bits\n-    \/\/\/ are valid for this bitflags type.\n-    unsafe fn from_bits_unchecked(bits: Self::Bits) -> Self;\n+    fn from_bits_retain(bits: Self::Bits) -> Self;\n     \/\/\/ Returns `true` if no flags are currently stored.\n     fn is_empty(&self) -> bool;\n     \/\/\/ Returns `true` if all flags are currently set.\ndiff --git a\/src\/bitflags_trait.rs b\/src\/bitflags_trait.rs\n--- a\/src\/bitflags_trait.rs\n+++ b\/src\/bitflags_trait.rs\n@@ -53,9 +41,22 @@ pub trait BitFlags: ImplementedByBitFlagsMacro {\n     fn set(&mut self, other: Self, value: bool);\n }\n \n+\/\/\/ A marker trait that signals that an implementation of `BitFlags` came from the `bitflags!` macro.\n+\/\/\/\n+\/\/\/ There's nothing stopping an end-user from implementing this trait, but we don't guarantee their\n+\/\/\/ manual implementations won't break between non-breaking releases.\n+#[doc(hidden)]\n+pub trait ImplementedByBitFlagsMacro {}\n+\n \/\/ Not re-exported\n pub trait Sealed {}\n \n+\/\/ Private implementation details\n+\/\/\n+\/\/ The `Bits`, `PublicFlags`, and `InternalFlags` traits are implementation details of the `bitflags!`\n+\/\/ macro that we're free to change here. They work with the `bitflags!` macro to separate the generated\n+\/\/ code that belongs to end-users, and the generated code that belongs to this library.\n+\n \/\/\/ A private trait that encodes the requirements of underlying bits types that can hold flags.\n \/\/\/\n \/\/\/ This trait may be made public at some future point, but it presents a compatibility hazard\ndiff --git a\/src\/bitflags_trait.rs b\/src\/bitflags_trait.rs\n--- a\/src\/bitflags_trait.rs\n+++ b\/src\/bitflags_trait.rs\n@@ -107,3 +108,11 @@ impl_bits! {\n     u64, i64,\n     u128, i128,\n }\n+\n+pub trait PublicFlags {\n+    type InternalFlags;\n+}\n+\n+pub trait InternalFlags {\n+    type PublicFlags;\n+}\ndiff --git a\/src\/example_generated.rs b\/src\/example_generated.rs\n--- a\/src\/example_generated.rs\n+++ b\/src\/example_generated.rs\n@@ -9,6 +9,35 @@ bitflags! {\n         const A = 0b00000001;\n         const B = 0b00000010;\n         const C = 0b00000100;\n-        const ABC = Self::A.bits | Self::B.bits | Self::C.bits;\n+        const ABC = Self::A.bits() | Self::B.bits() | Self::C.bits();\n     }\n }\n+\n+\/\/\/ This is the same internal field available as `self.0` on bitflags types.\n+\/\/\/ These types aren't reachable by callers of `bitflags!`, they don't appear in the API of your\n+\/\/\/ crate, but you can still interact with them through `self.0` in the module that defines the\n+\/\/\/ bitflags type.\n+\/\/\/\n+\/\/\/ You can use this example as a reference for what methods are available to all internal bitflags\n+\/\/\/ fields if you want to add custom functionality to your bitflags types.\n+\/\/\/\n+\/\/\/ Note that this struct is just for documentation purposes only, it must not be used outside\n+\/\/\/ this crate.\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[repr(transparent)]\n+pub struct FlagsField {\n+    bits: u32,\n+}\n+\n+__impl_internal_bitflags! {\n+    FlagsField: u32 {\n+        A;\n+        B;\n+        C;\n+        ABC;\n+    }\n+}\n+\n+impl crate::__private::InternalFlags for FlagsField {\n+    type PublicFlags = Flags;\n+}\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -21,11 +21,12 @@\n \/\/! use bitflags::bitflags;\n \/\/!\n \/\/! bitflags! {\n+\/\/!     #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n \/\/!     struct Flags: u32 {\n \/\/!         const A = 0b00000001;\n \/\/!         const B = 0b00000010;\n \/\/!         const C = 0b00000100;\n-\/\/!         const ABC = Self::A.bits | Self::B.bits | Self::C.bits;\n+\/\/!         const ABC = Self::A.bits() | Self::B.bits() | Self::C.bits();\n \/\/!     }\n \/\/! }\n \/\/!\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -51,6 +52,7 @@\n \/\/! use bitflags::bitflags;\n \/\/!\n \/\/! bitflags! {\n+\/\/!     #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n \/\/!     struct Flags: u32 {\n \/\/!         const A = 0b00000001;\n \/\/!         const B = 0b00000010;\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -59,14 +61,7 @@\n \/\/!\n \/\/! impl Flags {\n \/\/!     pub fn clear(&mut self) {\n-\/\/!         self.bits = 0;  \/\/ The `bits` field can be accessed from within the\n-\/\/!                         \/\/ same module where the `bitflags!` macro was invoked.\n-\/\/!     }\n-\/\/! }\n-\/\/!\n-\/\/! impl fmt::Display for Flags {\n-\/\/!     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-\/\/!         write!(f, \"hi!\")\n+\/\/!         *self.0.bits_mut() = 0;\n \/\/!     }\n \/\/! }\n \/\/!\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -74,9 +69,8 @@\n \/\/!     let mut flags = Flags::A | Flags::B;\n \/\/!     flags.clear();\n \/\/!     assert!(flags.is_empty());\n-\/\/!     assert_eq!(format!(\"{}\", flags), \"hi!\");\n-\/\/!     assert_eq!(format!(\"{:?}\", Flags::A | Flags::B), \"A | B\");\n-\/\/!     assert_eq!(format!(\"{:?}\", Flags::B), \"B\");\n+\/\/!     assert_eq!(format!(\"{:?}\", Flags::A | Flags::B), \"Flags(A | B)\");\n+\/\/!     assert_eq!(format!(\"{:?}\", Flags::B), \"Flags(B)\");\n \/\/! }\n \/\/! ```\n \/\/!\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -91,10 +85,12 @@\n \/\/!     use bitflags::bitflags;\n \/\/!\n \/\/!     bitflags! {\n+\/\/!         #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n \/\/!         pub struct Flags1: u32 {\n \/\/!             const A = 0b00000001;\n \/\/!         }\n \/\/!\n+\/\/!         #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n \/\/! #       pub\n \/\/!         struct Flags2: u32 {\n \/\/!             const B = 0b00000010;\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -123,6 +119,7 @@\n \/\/!\n \/\/! bitflags! {\n \/\/!     #[repr(transparent)]\n+\/\/!     #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n \/\/!     struct Flags: u32 {\n \/\/!         const A = 0b00000001;\n \/\/!         const B = 0b00000010;\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -133,13 +130,8 @@\n \/\/!\n \/\/! # Trait implementations\n \/\/!\n-\/\/! The `Copy`, `Clone`, `PartialEq`, `Eq`, `PartialOrd`, `Ord` and `Hash`\n-\/\/! traits are automatically derived for the `struct`s using the `derive` attribute.\n-\/\/! Additional traits can be derived by providing an explicit `derive`\n-\/\/! attribute on `struct`.\n-\/\/!\n-\/\/! The `Extend` and `FromIterator` traits are implemented for the `struct`s,\n-\/\/! too: `Extend` adds the union of the instances of the `struct` iterated over,\n+\/\/! The `Extend` and `FromIterator` traits are implemented for the `struct`s.\n+\/\/! `Extend` adds the union of the instances of the `struct` iterated over,\n \/\/! while `FromIterator` calculates the union.\n \/\/!\n \/\/! The `Binary`, `Debug`, `LowerHex`, `Octal` and `UpperHex` traits are also\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -167,7 +159,7 @@\n \/\/!                defined flag\n \/\/! - `from_bits_truncate`: convert from underlying bit representation, dropping\n \/\/!                         any bits that do not correspond to defined flags\n-\/\/! - `from_bits_unchecked`: convert from underlying bit representation, keeping\n+\/\/! - `from_bits_retain`: convert from underlying bit representation, keeping\n \/\/!                          all bits (even those not corresponding to defined\n \/\/!                          flags)\n \/\/! - `is_empty`: `true` if no flags are currently stored\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -204,7 +196,7 @@\n \/\/!\n \/\/! bitflags! {\n \/\/!     \/\/ Results in default value with bits: 0\n-\/\/!     #[derive(Default)]\n+\/\/!     #[derive(Default, Clone, Copy, Debug, PartialEq, Eq, Hash)]\n \/\/!     struct Flags: u32 {\n \/\/!         const A = 0b00000001;\n \/\/!         const B = 0b00000010;\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -224,6 +216,7 @@\n \/\/! use bitflags::bitflags;\n \/\/!\n \/\/! bitflags! {\n+\/\/!     #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n \/\/!     struct Flags: u32 {\n \/\/!         const A = 0b00000001;\n \/\/!         const B = 0b00000010;\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -252,6 +245,7 @@\n \/\/! use bitflags::bitflags;\n \/\/!\n \/\/! bitflags! {\n+\/\/!     #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n \/\/!     struct Flags: u32 {\n \/\/!         const NONE = 0b00000000;\n \/\/!         const SOME = 0b00000001;\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -285,10 +279,62 @@ mod bitflags_trait;\n \n #[doc(hidden)]\n pub mod __private {\n-    pub use crate::bitflags_trait::{Bits, ImplementedByBitFlagsMacro};\n+    pub use crate::bitflags_trait::{Bits, ImplementedByBitFlagsMacro, InternalFlags, PublicFlags};\n     pub use core;\n+\n+    #[cfg(feature = \"serde\")]\n+    pub use serde;\n }\n \n+\/*\n+How does the bitflags crate work?\n+\n+This library generates `struct`s in the end-user's crate with a bunch of constants on it that represent flags.\n+The difference between `bitflags` and a lot of other libraries is that we don't actually control the generated `struct` in the end.\n+It's part of the end-user's crate, so it belongs to them. That makes it difficult to extend `bitflags` with new functionality\n+because we could end up breaking valid code that was already written.\n+\n+Our solution is to split the type we generate into two: the public struct owned by the end-user, and an internal struct owned by `bitflags` (us).\n+To give you an example, let's say we had a crate that called `bitflags!`:\n+\n+```rust\n+bitflags! {\n+    pub struct MyFlags: u32 {\n+        const A = 1;\n+        const B = 2;\n+    }\n+}\n+```\n+\n+What they'd end up with looks something like this:\n+\n+```rust\n+pub struct MyFlags(<MyFlags as PublicFlags>::InternalFlags);\n+\n+const _: () = {\n+    #[repr(transparent)]\n+    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+    pub struct MyInternalFlags {\n+        bits: u32,\n+    }\n+\n+    impl PublicFlags for MyFlags {\n+        type InternalFlags = InternalFlags;\n+    }\n+\n+    impl InternalFlags for MyInternalFlags {\n+        type PublicFlags = MyFlags;\n+    }\n+};\n+```\n+\n+If we want to expose something like a new trait impl for generated flags types, we add it to our generated `MyInternalFlags`,\n+and let `#[derive]` on `MyFlags` pick up that implementation, if an end-user chooses to add one.\n+\n+The public API is generated in the `__impl_bitflags_public!` macro, and the internal API is generated in\n+the `__impl_bitflags_internal!` macro.\n+*\/\n+\n \/\/\/ The macro used to generate the flag structure.\n \/\/\/\n \/\/\/ See the [crate level docs](..\/bitflags\/index.html) for complete documentation.\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -299,11 +345,12 @@ pub mod __private {\n \/\/\/ use bitflags::bitflags;\n \/\/\/\n \/\/\/ bitflags! {\n+\/\/\/     #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n \/\/\/     struct Flags: u32 {\n \/\/\/         const A = 0b00000001;\n \/\/\/         const B = 0b00000010;\n \/\/\/         const C = 0b00000100;\n-\/\/\/         const ABC = Self::A.bits | Self::B.bits | Self::C.bits;\n+\/\/\/         const ABC = Self::A.bits() | Self::B.bits() | Self::C.bits();\n \/\/\/     }\n \/\/\/ }\n \/\/\/\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -326,6 +373,7 @@ pub mod __private {\n \/\/\/ use bitflags::bitflags;\n \/\/\/\n \/\/\/ bitflags! {\n+\/\/\/     #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n \/\/\/     struct Flags: u32 {\n \/\/\/         const A = 0b00000001;\n \/\/\/         const B = 0b00000010;\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -334,14 +382,7 @@ pub mod __private {\n \/\/\/\n \/\/\/ impl Flags {\n \/\/\/     pub fn clear(&mut self) {\n-\/\/\/         self.bits = 0;  \/\/ The `bits` field can be accessed from within the\n-\/\/\/                         \/\/ same module where the `bitflags!` macro was invoked.\n-\/\/\/     }\n-\/\/\/ }\n-\/\/\/\n-\/\/\/ impl fmt::Display for Flags {\n-\/\/\/     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-\/\/\/         write!(f, \"hi!\")\n+\/\/\/         *self.0.bits_mut() = 0;\n \/\/\/     }\n \/\/\/ }\n \/\/\/\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -349,9 +390,8 @@ pub mod __private {\n \/\/\/     let mut flags = Flags::A | Flags::B;\n \/\/\/     flags.clear();\n \/\/\/     assert!(flags.is_empty());\n-\/\/\/     assert_eq!(format!(\"{}\", flags), \"hi!\");\n-\/\/\/     assert_eq!(format!(\"{:?}\", Flags::A | Flags::B), \"A | B\");\n-\/\/\/     assert_eq!(format!(\"{:?}\", Flags::B), \"B\");\n+\/\/\/     assert_eq!(format!(\"{:?}\", Flags::A | Flags::B), \"Flags(A | B)\");\n+\/\/\/     assert_eq!(format!(\"{:?}\", Flags::B), \"Flags(B)\");\n \/\/\/ }\n \/\/\/ ```\n #[macro_export(local_inner_macros)]\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -368,12 +408,9 @@ macro_rules! bitflags {\n         $($t:tt)*\n     ) => {\n         $(#[$outer])*\n-        #[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]\n-        $vis struct $BitFlags {\n-            bits: $T,\n-        }\n+        $vis struct $BitFlags(<$BitFlags as $crate::__private::PublicFlags>::InternalFlags);\n \n-        __impl_bitflags! {\n+        __impl_public_bitflags! {\n             $BitFlags: $T {\n                 $(\n                     $(#[$inner $($args)*])*\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -382,6 +419,31 @@ macro_rules! bitflags {\n             }\n         }\n \n+        const _: () = {\n+            #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+            #[repr(transparent)]\n+            $vis struct InternalFlags {\n+                bits: $T,\n+            }\n+\n+            __impl_internal_bitflags! {\n+                InternalFlags: $T {\n+                    $(\n+                        $(#[$inner $($args)*])*\n+                        $Flag;\n+                    )*\n+                }\n+            }\n+\n+            impl $crate::__private::InternalFlags for InternalFlags {\n+                type PublicFlags = $BitFlags;\n+            }\n+\n+            impl $crate::__private::PublicFlags for $BitFlags {\n+                type InternalFlags = InternalFlags;\n+            }\n+        };\n+\n         bitflags! {\n             $($t)*\n         }\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -389,70 +451,42 @@ macro_rules! bitflags {\n     () => {};\n }\n \n+\/\/\/ Implement functions on the public (user-facing) bitflags type.\n+\/\/\/\n+\/\/\/ We need to be careful about adding new methods and trait implementations here because they\n+\/\/\/ could conflict with items added by the end-user.\n #[macro_export(local_inner_macros)]\n #[doc(hidden)]\n-macro_rules! __impl_bitflags {\n+macro_rules! __impl_public_bitflags {\n     (\n-        $BitFlags:ident: $T:ty {\n+        $PublicBitFlags:ident: $T:ty {\n             $(\n                 $(#[$attr:ident $($args:tt)*])*\n                 $Flag:ident = $value:expr;\n             )*\n         }\n     ) => {\n-        impl $crate::__private::core::fmt::Debug for $BitFlags {\n+        impl $crate::__private::core::fmt::Binary for $PublicBitFlags {\n             fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n-                \/\/ Iterate over the valid flags\n-                let mut first = true;\n-                for (name, _) in self.iter() {\n-                    if !first {\n-                        f.write_str(\" | \")?;\n-                    }\n-\n-                    first = false;\n-                    f.write_str(name)?;\n-                }\n-\n-                \/\/ Append any extra bits that correspond to flags to the end of the format\n-                let extra_bits = self.bits & !Self::all().bits();\n-\n-                if extra_bits != <$T as $crate::__private::Bits>::EMPTY {\n-                    if !first {\n-                        f.write_str(\" | \")?;\n-                    }\n-                    first = false;\n-                    $crate::__private::core::write!(f, \"{:#x}\", extra_bits)?;\n-                }\n-\n-                if first {\n-                    f.write_str(\"(empty)\")?;\n-                }\n-\n-                $crate::__private::core::fmt::Result::Ok(())\n-            }\n-        }\n-\n-        impl $crate::__private::core::fmt::Binary for $BitFlags {\n-            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n-                $crate::__private::core::fmt::Binary::fmt(&self.bits, f)\n+                $crate::__private::core::fmt::Binary::fmt(&self.0, f)\n             }\n         }\n \n-        impl $crate::__private::core::fmt::Octal for $BitFlags {\n+        impl $crate::__private::core::fmt::Octal for $PublicBitFlags {\n             fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n-                $crate::__private::core::fmt::Octal::fmt(&self.bits, f)\n+                $crate::__private::core::fmt::Octal::fmt(&self.0, f)\n             }\n         }\n \n-        impl $crate::__private::core::fmt::LowerHex for $BitFlags {\n+        impl $crate::__private::core::fmt::LowerHex for $PublicBitFlags {\n             fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n-                $crate::__private::core::fmt::LowerHex::fmt(&self.bits, f)\n+                $crate::__private::core::fmt::LowerHex::fmt(&self.0, f)\n             }\n         }\n \n-        impl $crate::__private::core::fmt::UpperHex for $BitFlags {\n+        impl $crate::__private::core::fmt::UpperHex for $PublicBitFlags {\n             fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n-                $crate::__private::core::fmt::UpperHex::fmt(&self.bits, f)\n+                $crate::__private::core::fmt::UpperHex::fmt(&self.0, f)\n             }\n         }\n \ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -464,40 +498,37 @@ macro_rules! __impl_bitflags {\n             unused_mut,\n             non_upper_case_globals\n         )]\n-        impl $BitFlags {\n+        impl $PublicBitFlags {\n             $(\n                 $(#[$attr $($args)*])*\n-                pub const $Flag: Self = Self { bits: $value };\n+                pub const $Flag: Self = Self::from_bits_retain($value);\n             )*\n \n             \/\/\/ Returns an empty set of flags.\n             #[inline]\n             pub const fn empty() -> Self {\n-                Self { bits: <$T as $crate::__private::Bits>::EMPTY }\n+                Self(<$PublicBitFlags as $crate::__private::PublicFlags>::InternalFlags::empty())\n             }\n \n             \/\/\/ Returns the set containing all flags.\n             #[inline]\n             pub const fn all() -> Self {\n-                Self::from_bits_truncate(<$T as $crate::__private::Bits>::ALL)\n+                Self(<$PublicBitFlags as $crate::__private::PublicFlags>::InternalFlags::all())\n             }\n \n             \/\/\/ Returns the raw value of the flags currently stored.\n             #[inline]\n             pub const fn bits(&self) -> $T {\n-                self.bits\n+                self.0.bits()\n             }\n \n             \/\/\/ Convert from underlying bit representation, unless that\n             \/\/\/ representation contains bits that do not correspond to a flag.\n             #[inline]\n             pub const fn from_bits(bits: $T) -> $crate::__private::core::option::Option<Self> {\n-                let truncated = Self::from_bits_truncate(bits).bits;\n-\n-                if truncated == bits {\n-                    $crate::__private::core::option::Option::Some(Self { bits })\n-                } else {\n-                    $crate::__private::core::option::Option::None\n+                match <$PublicBitFlags as $crate::__private::PublicFlags>::InternalFlags::from_bits(bits) {\n+                    $crate::__private::core::option::Option::Some(bits) => $crate::__private::core::option::Option::Some(Self(bits)),\n+                    $crate::__private::core::option::Option::None => $crate::__private::core::option::Option::None,\n                 }\n             }\n \ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -505,20 +536,7 @@ macro_rules! __impl_bitflags {\n             \/\/\/ that do not correspond to flags.\n             #[inline]\n             pub const fn from_bits_truncate(bits: $T) -> Self {\n-                if bits == <$T as $crate::__private::Bits>::EMPTY {\n-                    return Self { bits }\n-                }\n-\n-                let mut truncated = <$T as $crate::__private::Bits>::EMPTY;\n-\n-                $(\n-                    $(#[$attr $($args)*])*\n-                    if bits & Self::$Flag.bits == Self::$Flag.bits {\n-                        truncated |= Self::$Flag.bits\n-                    }\n-                )*\n-\n-                Self { bits: truncated }\n+                Self(<$PublicBitFlags as $crate::__private::PublicFlags>::InternalFlags::from_bits_truncate(bits))\n             }\n \n             \/\/\/ Convert from underlying bit representation, preserving all\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -529,64 +547,60 @@ macro_rules! __impl_bitflags {\n             \/\/\/ The caller of the `bitflags!` macro can choose to allow or\n             \/\/\/ disallow extra bits for their bitflags type.\n             \/\/\/\n-            \/\/\/ The caller of `from_bits_unchecked()` has to ensure that\n+            \/\/\/ The caller of `from_bits_retain()` has to ensure that\n             \/\/\/ all bits correspond to a defined flag or that extra bits\n             \/\/\/ are valid for this bitflags type.\n             #[inline]\n-            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n-                Self { bits }\n+            pub const fn from_bits_retain(bits: $T) -> Self {\n+                Self(<$PublicBitFlags as $crate::__private::PublicFlags>::InternalFlags::from_bits_retain(bits))\n             }\n \n             \/\/\/ Returns `true` if no flags are currently stored.\n             #[inline]\n             pub const fn is_empty(&self) -> bool {\n-                self.bits() == Self::empty().bits()\n+                self.0.is_empty()\n             }\n \n             \/\/\/ Returns `true` if all flags are currently set.\n             #[inline]\n             pub const fn is_all(&self) -> bool {\n-                Self::all().bits | self.bits == self.bits\n+                self.0.is_all()\n             }\n \n             \/\/\/ Returns `true` if there are flags common to both `self` and `other`.\n             #[inline]\n             pub const fn intersects(&self, other: Self) -> bool {\n-                !(Self { bits: self.bits & other.bits}).is_empty()\n+                self.0.intersects(other.0)\n             }\n \n             \/\/\/ Returns `true` if all of the flags in `other` are contained within `self`.\n             #[inline]\n             pub const fn contains(&self, other: Self) -> bool {\n-                (self.bits & other.bits) == other.bits\n+                self.0.contains(other.0)\n             }\n \n             \/\/\/ Inserts the specified flags in-place.\n             #[inline]\n             pub fn insert(&mut self, other: Self) {\n-                self.bits |= other.bits;\n+                self.0.insert(other.0)\n             }\n \n             \/\/\/ Removes the specified flags in-place.\n             #[inline]\n             pub fn remove(&mut self, other: Self) {\n-                self.bits &= !other.bits;\n+                self.0.remove(other.0)\n             }\n \n             \/\/\/ Toggles the specified flags in-place.\n             #[inline]\n             pub fn toggle(&mut self, other: Self) {\n-                self.bits ^= other.bits;\n+                self.0.toggle(other.0)\n             }\n \n             \/\/\/ Inserts or removes the specified flags depending on the passed value.\n             #[inline]\n             pub fn set(&mut self, other: Self, value: bool) {\n-                if value {\n-                    self.insert(other);\n-                } else {\n-                    self.remove(other);\n-                }\n+                self.0.set(other.0, value)\n             }\n \n             \/\/\/ Returns the intersection between the flags in `self` and\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -602,7 +616,7 @@ macro_rules! __impl_bitflags {\n             #[inline]\n             #[must_use]\n             pub const fn intersection(self, other: Self) -> Self {\n-                Self { bits: self.bits & other.bits }\n+                Self(self.0.intersection(other.0))\n             }\n \n             \/\/\/ Returns the union of between the flags in `self` and `other`.\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -619,7 +633,7 @@ macro_rules! __impl_bitflags {\n             #[inline]\n             #[must_use]\n             pub const fn union(self, other: Self) -> Self {\n-                Self { bits: self.bits | other.bits }\n+                Self(self.0.union(other.0))\n             }\n \n             \/\/\/ Returns the difference between the flags in `self` and `other`.\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -637,7 +651,7 @@ macro_rules! __impl_bitflags {\n             #[inline]\n             #[must_use]\n             pub const fn difference(self, other: Self) -> Self {\n-                Self { bits: self.bits & !other.bits }\n+                Self(self.0.difference(other.0))\n             }\n \n             \/\/\/ Returns the [symmetric difference][sym-diff] between the flags\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -656,7 +670,7 @@ macro_rules! __impl_bitflags {\n             #[inline]\n             #[must_use]\n             pub const fn symmetric_difference(self, other: Self) -> Self {\n-                Self { bits: self.bits ^ other.bits }\n+                Self(self.0.symmetric_difference(other.0))\n             }\n \n             \/\/\/ Returns the complement of this set of flags.\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -675,159 +689,101 @@ macro_rules! __impl_bitflags {\n             #[inline]\n             #[must_use]\n             pub const fn complement(self) -> Self {\n-                Self::from_bits_truncate(!self.bits)\n+                Self(self.0.complement())\n             }\n \n             \/\/\/ Returns an iterator over set flags and their names.\n             pub fn iter(self) -> impl $crate::__private::core::iter::Iterator<Item = (&'static str, Self)> {\n                 use $crate::__private::core::iter::Iterator as _;\n \n-                const NUM_FLAGS: usize = {\n-                    let mut num_flags = 0;\n-\n-                    $(\n-                        $(#[$attr $($args)*])*\n-                        {\n-                            num_flags += 1;\n-                        }\n-                    )*\n-\n-                    num_flags\n-                };\n-\n-                const OPTIONS: [$BitFlags; NUM_FLAGS] = [\n-                    $(\n-                        $(#[$attr $($args)*])*\n-                        $BitFlags::$Flag,\n-                    )*\n-                ];\n-\n-                const OPTIONS_NAMES: [&'static str; NUM_FLAGS] = [\n-                    $(\n-                        $(#[$attr $($args)*])*\n-                        $crate::__private::core::stringify!($Flag),\n-                    )*\n-                ];\n-\n-                let mut start = 0;\n-                let mut state = self;\n-\n-                $crate::__private::core::iter::from_fn(move || {\n-                    if state.is_empty() || NUM_FLAGS == 0 {\n-                        $crate::__private::core::option::Option::None\n-                    } else {\n-                        for (flag, flag_name) in OPTIONS[start..NUM_FLAGS].iter().copied()\n-                            .zip(OPTIONS_NAMES[start..NUM_FLAGS].iter().copied())\n-                        {\n-                            start += 1;\n-\n-                            \/\/ NOTE: We check whether the flag exists in self, but remove it from\n-                            \/\/ a different value. This ensure that overlapping flags are handled\n-                            \/\/ properly. Take the following example:\n-                            \/\/\n-                            \/\/ const A: 0b00000001;\n-                            \/\/ const B: 0b00000101;\n-                            \/\/\n-                            \/\/ Given the bits 0b00000101, both A and B are set. But if we removed A\n-                            \/\/ as we encountered it we'd be left with 0b00000100, which doesn't\n-                            \/\/ correspond to a valid flag on its own.\n-                            if self.contains(flag) {\n-                                state.remove(flag);\n-\n-                                return $crate::__private::core::option::Option::Some((flag_name, flag))\n-                            }\n-                        }\n-\n-                        $crate::__private::core::option::Option::None\n-                    }\n-                })\n+                self.0.iter().map(|(name, bits)| (name, Self::from_bits_retain(bits)))\n             }\n \n         }\n \n-        impl $crate::__private::core::ops::BitOr for $BitFlags {\n+        impl $crate::__private::core::ops::BitOr for $PublicBitFlags {\n             type Output = Self;\n \n             \/\/\/ Returns the union of the two sets of flags.\n             #[inline]\n-            fn bitor(self, other: $BitFlags) -> Self {\n-                Self { bits: self.bits | other.bits }\n+            fn bitor(self, other: $PublicBitFlags) -> Self {\n+                self.union(other)\n             }\n         }\n \n-        impl $crate::__private::core::ops::BitOrAssign for $BitFlags {\n+        impl $crate::__private::core::ops::BitOrAssign for $PublicBitFlags {\n             \/\/\/ Adds the set of flags.\n             #[inline]\n             fn bitor_assign(&mut self, other: Self) {\n-                self.bits |= other.bits;\n+                self.0 = self.0.union(other.0);\n             }\n         }\n \n-        impl $crate::__private::core::ops::BitXor for $BitFlags {\n+        impl $crate::__private::core::ops::BitXor for $PublicBitFlags {\n             type Output = Self;\n \n             \/\/\/ Returns the left flags, but with all the right flags toggled.\n             #[inline]\n             fn bitxor(self, other: Self) -> Self {\n-                Self { bits: self.bits ^ other.bits }\n+                self.symmetric_difference(other)\n             }\n         }\n \n-        impl $crate::__private::core::ops::BitXorAssign for $BitFlags {\n+        impl $crate::__private::core::ops::BitXorAssign for $PublicBitFlags {\n             \/\/\/ Toggles the set of flags.\n             #[inline]\n             fn bitxor_assign(&mut self, other: Self) {\n-                self.bits ^= other.bits;\n+                self.0 = self.0.symmetric_difference(other.0);\n             }\n         }\n \n-        impl $crate::__private::core::ops::BitAnd for $BitFlags {\n+        impl $crate::__private::core::ops::BitAnd for $PublicBitFlags {\n             type Output = Self;\n \n             \/\/\/ Returns the intersection between the two sets of flags.\n             #[inline]\n             fn bitand(self, other: Self) -> Self {\n-                Self { bits: self.bits & other.bits }\n+                self.intersection(other)\n             }\n         }\n \n-        impl $crate::__private::core::ops::BitAndAssign for $BitFlags {\n+        impl $crate::__private::core::ops::BitAndAssign for $PublicBitFlags {\n             \/\/\/ Disables all flags disabled in the set.\n             #[inline]\n             fn bitand_assign(&mut self, other: Self) {\n-                self.bits &= other.bits;\n+                self.0 = self.0.intersection(other.0);\n             }\n         }\n \n-        impl $crate::__private::core::ops::Sub for $BitFlags {\n+        impl $crate::__private::core::ops::Sub for $PublicBitFlags {\n             type Output = Self;\n \n             \/\/\/ Returns the set difference of the two sets of flags.\n             #[inline]\n             fn sub(self, other: Self) -> Self {\n-                Self { bits: self.bits & !other.bits }\n+                self.difference(other)\n             }\n         }\n \n-        impl $crate::__private::core::ops::SubAssign for $BitFlags {\n+        impl $crate::__private::core::ops::SubAssign for $PublicBitFlags {\n             \/\/\/ Disables all flags enabled in the set.\n             #[inline]\n             fn sub_assign(&mut self, other: Self) {\n-                self.bits &= !other.bits;\n+                self.0 = self.0.difference(other.0);\n             }\n         }\n \n-        impl $crate::__private::core::ops::Not for $BitFlags {\n+        impl $crate::__private::core::ops::Not for $PublicBitFlags {\n             type Output = Self;\n \n             \/\/\/ Returns the complement of this set of flags.\n             #[inline]\n             fn not(self) -> Self {\n-                Self { bits: !self.bits } & Self::all()\n+                self.complement()\n             }\n         }\n \n-        impl $crate::__private::core::iter::Extend<$BitFlags> for $BitFlags {\n+        impl $crate::__private::core::iter::Extend<$PublicBitFlags> for $PublicBitFlags {\n             fn extend<T: $crate::__private::core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                 for item in iterator {\n                     self.insert(item)\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -835,7 +791,7 @@ macro_rules! __impl_bitflags {\n             }\n         }\n \n-        impl $crate::__private::core::iter::FromIterator<$BitFlags> for $BitFlags {\n+        impl $crate::__private::core::iter::FromIterator<$PublicBitFlags> for $PublicBitFlags {\n             fn from_iter<T: $crate::__private::core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                 use $crate::__private::core::iter::Extend;\n \n","version":"1.3","repo":"bitflags\/bitflags","environment_setup_commit":"b14fd2f6e65ff43eabf754680570e4951903d7b2"}
{"problem_statement":"Bitflags reverses order of multiline doc comments\nWhen compiling code like\r\n```\r\nbitflags! {\r\n    pub struct AdjustFlags: u32 {\r\n        \/\/\/ Add buf.time to the current time. If buf.status includes the ADJ_NANO flag, then buf.time.tv_usec is interpreted as a nanosecond value;\r\n        \/\/\/ otherwise it is interpreted as microseconds.\r\n        \/\/\/\r\n        \/\/\/ The value of buf.time is the sum of its two fields, but the field buf.time.tv_usec must always be nonnegative.\r\n        \/\/\/ The following example shows how to normalize a timeval with nanosecond resolution.\r\n        \/\/\/\r\n        \/\/\/ ```C\r\n        \/\/\/ while (buf.time.tv_usec < 0) {\r\n        \/\/\/     buf.time.tv_sec  -= 1;\r\n        \/\/\/     buf.time.tv_usec += 1000000000;\r\n        \/\/\/ }\r\n        \/\/\/ ```\r\n        const SETOFFSET = libc::ADJ_SETOFFSET;\r\n    }\r\n}\r\n```\r\n\r\nThe doc-comments order is reversed on compile, causing issues with generated docs and the doctest.\r\n\r\nThis bug only occurs on bitflags 2.2.0 and not on earlier versions\n","test_patch":"diff --git \/dev\/null b\/tests\/compile-pass\/large.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/tests\/compile-pass\/large.rs\n@@ -0,0 +1,311 @@\n+\/*\n+Copyright (c) 2016 Anatoly Ikorsky\n+\n+Permission is hereby granted, free of charge, to any\n+person obtaining a copy of this software and associated\n+documentation files (the \"Software\"), to deal in the\n+Software without restriction, including without\n+limitation the rights to use, copy, modify, merge,\n+publish, distribute, sublicense, and\/or sell copies of\n+the Software, and to permit persons to whom the Software\n+is furnished to do so, subject to the following\n+conditions:\n+\n+The above copyright notice and this permission notice\n+shall be included in all copies or substantial portions\n+of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF\n+ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n+TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n+PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT\n+SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR\n+IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+DEALINGS IN THE SOFTWARE.\n+*\/\n+\n+#[macro_use]\n+extern crate bitflags;\n+\n+bitflags! {\n+    \/\/\/ Client capability flags\n+    #[derive(PartialEq, Eq, Hash, Debug, Clone, Copy)]\n+    pub struct CapabilityFlags: u32 {\n+        \/\/\/ Use the improved version of Old Password Authentication. Assumed to be set since 4.1.1.\n+        const CLIENT_LONG_PASSWORD                  = 0x0000_0001;\n+    \n+        \/\/\/ Send found rows instead of affected rows in EOF_Packet.\n+        const CLIENT_FOUND_ROWS                     = 0x0000_0002;\n+    \n+        \/\/\/ Get all column flags.\n+        \/\/\/ Longer flags in Protocol::ColumnDefinition320.\n+        \/\/\/\n+        \/\/\/ ### Server\n+        \/\/\/ Supports longer flags.\n+        \/\/\/\n+        \/\/\/ ### Client\n+        \/\/\/ Expects longer flags.\n+        const CLIENT_LONG_FLAG                      = 0x0000_0004;\n+    \n+        \/\/\/ Database (schema) name can be specified on connect in Handshake Response Packet.\n+        \/\/\/ ### Server\n+        \/\/\/ Supports schema-name in Handshake Response Packet.\n+        \/\/\/\n+        \/\/\/ ### Client\n+        \/\/\/ Handshake Response Packet contains a schema-name.\n+        const CLIENT_CONNECT_WITH_DB                = 0x0000_0008;\n+    \n+        \/\/\/ Don't allow database.table.column.\n+        const CLIENT_NO_SCHEMA                      = 0x0000_0010;\n+    \n+        \/\/\/ Compression protocol supported.\n+        \/\/\/\n+        \/\/\/ ### Server\n+        \/\/\/ Supports compression.\n+        \/\/\/\n+        \/\/\/ ### Client\n+        \/\/\/ Switches to Compression compressed protocol after successful authentication.\n+        const CLIENT_COMPRESS                       = 0x0000_0020;\n+    \n+        \/\/\/ Special handling of ODBC behavior.\n+        const CLIENT_ODBC                           = 0x0000_0040;\n+    \n+        \/\/\/ Can use LOAD DATA LOCAL.\n+        \/\/\/\n+        \/\/\/ ### Server\n+        \/\/\/ Enables the LOCAL INFILE request of LOAD DATA|XML.\n+        \/\/\/\n+        \/\/\/ ### Client\n+        \/\/\/ Will handle LOCAL INFILE request.\n+        const CLIENT_LOCAL_FILES                    = 0x0000_0080;\n+    \n+        \/\/\/ Ignore spaces before '('.\n+        \/\/\/\n+        \/\/\/ ### Server\n+        \/\/\/ Parser can ignore spaces before '('.\n+        \/\/\/\n+        \/\/\/ ### Client\n+        \/\/\/ Let the parser ignore spaces before '('.\n+        const CLIENT_IGNORE_SPACE                   = 0x0000_0100;\n+    \n+        const CLIENT_PROTOCOL_41                    = 0x0000_0200;\n+    \n+        \/\/\/ This is an interactive client.\n+        \/\/\/ Use System_variables::net_wait_timeout versus System_variables::net_interactive_timeout.\n+        \/\/\/\n+        \/\/\/ ### Server\n+        \/\/\/ Supports interactive and noninteractive clients.\n+        \/\/\/\n+        \/\/\/ ### Client\n+        \/\/\/ Client is interactive.\n+        const CLIENT_INTERACTIVE                    = 0x0000_0400;\n+    \n+        \/\/\/ Use SSL encryption for the session.\n+        \/\/\/\n+        \/\/\/ ### Server\n+        \/\/\/ Supports SSL\n+        \/\/\/\n+        \/\/\/ ### Client\n+        \/\/\/ Switch to SSL after sending the capability-flags.\n+        const CLIENT_SSL                            = 0x0000_0800;\n+    \n+        \/\/\/ Client only flag. Not used.\n+        \/\/\/\n+        \/\/\/ ### Client\n+        \/\/\/ Do not issue SIGPIPE if network failures occur (libmysqlclient only).\n+        const CLIENT_IGNORE_SIGPIPE                 = 0x0000_1000;\n+    \n+        \/\/\/ Client knows about transactions.\n+        \/\/\/\n+        \/\/\/ ### Server\n+        \/\/\/ Can send status flags in OK_Packet \/ EOF_Packet.\n+        \/\/\/\n+        \/\/\/ ### Client\n+        \/\/\/ Expects status flags in OK_Packet \/ EOF_Packet.\n+        \/\/\/\n+        \/\/\/ ### Note\n+        \/\/\/ This flag is optional in 3.23, but always set by the server since 4.0.\n+        const CLIENT_TRANSACTIONS                   = 0x0000_2000;\n+    \n+        const CLIENT_RESERVED                       = 0x0000_4000;\n+    \n+        const CLIENT_SECURE_CONNECTION              = 0x0000_8000;\n+    \n+        \/\/\/ Enable\/disable multi-stmt support.\n+        \/\/\/ Also sets CLIENT_MULTI_RESULTS. Currently not checked anywhere.\n+        \/\/\/\n+        \/\/\/ ### Server\n+        \/\/\/ Can handle multiple statements per COM_QUERY and COM_STMT_PREPARE.\n+        \/\/\/\n+        \/\/\/ ### Client\n+        \/\/\/ May send multiple statements per COM_QUERY and COM_STMT_PREPARE.\n+        const CLIENT_MULTI_STATEMENTS               = 0x0001_0000;\n+    \n+        \/\/\/ Enable\/disable multi-results.\n+        \/\/\/\n+        \/\/\/ ### Server\n+        \/\/\/ Can send multiple resultsets for COM_QUERY. Error if the server needs to send\n+        \/\/\/ them and client does not support them.\n+        \/\/\/\n+        \/\/\/ ### Client\n+        \/\/\/ Can handle multiple resultsets for COM_QUERY.\n+        \/\/\/\n+        \/\/\/ ### Requires\n+        \/\/\/ `CLIENT_PROTOCOL_41`\n+        const CLIENT_MULTI_RESULTS                  = 0x0002_0000;\n+    \n+        \/\/\/ Multi-results and OUT parameters in PS-protocol.\n+        \/\/\/\n+        \/\/\/ ### Server\n+        \/\/\/ Can send multiple resultsets for COM_STMT_EXECUTE.\n+        \/\/\/\n+        \/\/\/ ### Client\n+        \/\/\/ Can handle multiple resultsets for COM_STMT_EXECUTE.\n+        \/\/\/\n+        \/\/\/ ### Requires\n+        \/\/\/ `CLIENT_PROTOCOL_41`\n+        const CLIENT_PS_MULTI_RESULTS               = 0x0004_0000;\n+    \n+        \/\/\/ Client supports plugin authentication.\n+        \/\/\/\n+        \/\/\/ ### Server\n+        \/\/\/ Sends extra data in Initial Handshake Packet and supports the pluggable\n+        \/\/\/ authentication protocol.\n+        \/\/\/\n+        \/\/\/ ### Client\n+        \/\/\/ Supports authentication plugins.\n+        \/\/\/\n+        \/\/\/ ### Requires\n+        \/\/\/ `CLIENT_PROTOCOL_41`\n+        const CLIENT_PLUGIN_AUTH                    = 0x0008_0000;\n+    \n+        \/\/\/ Client supports connection attributes.\n+        \/\/\/\n+        \/\/\/ ### Server\n+        \/\/\/ Permits connection attributes in Protocol::HandshakeResponse41.\n+        \/\/\/\n+        \/\/\/ ### Client\n+        \/\/\/ Sends connection attributes in Protocol::HandshakeResponse41.\n+        const CLIENT_CONNECT_ATTRS                  = 0x0010_0000;\n+    \n+        \/\/\/ Enable authentication response packet to be larger than 255 bytes.\n+        \/\/\/ When the ability to change default plugin require that the initial password\n+        \/\/\/ field in the Protocol::HandshakeResponse41 paclet can be of arbitrary size.\n+        \/\/\/ However, the 4.1 client-server protocol limits the length of the auth-data-field\n+        \/\/\/ sent from client to server to 255 bytes. The solution is to change the type of\n+        \/\/\/ the field to a true length encoded string and indicate the protocol change with\n+        \/\/\/ this client capability flag.\n+        \/\/\/\n+        \/\/\/ ### Server\n+        \/\/\/ Understands length-encoded integer for auth response data in\n+        \/\/\/ Protocol::HandshakeResponse41.\n+        \/\/\/\n+        \/\/\/ ### Client\n+        \/\/\/ Length of auth response data in Protocol::HandshakeResponse41 is a\n+        \/\/\/ length-encoded integer.\n+        \/\/\/\n+        \/\/\/ ### Note\n+        \/\/\/ The flag was introduced in 5.6.6, but had the wrong value.\n+        const CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA = 0x0020_0000;\n+    \n+        \/\/\/ Don't close the connection for a user account with expired password.\n+        \/\/\/\n+        \/\/\/ ### Server\n+        \/\/\/ Announces support for expired password extension.\n+        \/\/\/\n+        \/\/\/ ### Client\n+        \/\/\/ Can handle expired passwords.\n+        const CLIENT_CAN_HANDLE_EXPIRED_PASSWORDS   = 0x0040_0000;\n+    \n+        \/\/\/ Capable of handling server state change information.\n+        \/\/\/ Its a hint to the server to include the state change information in OK_Packet.\n+        \/\/\/\n+        \/\/\/ ### Server\n+        \/\/\/ Can set SERVER_SESSION_STATE_CHANGED in the SERVER_STATUS_flags_enum and send\n+        \/\/\/ Session State Information in a OK_Packet.\n+        \/\/\/\n+        \/\/\/ ### Client\n+        \/\/\/ Expects the server to send Session State Information in a OK_Packet.\n+        const CLIENT_SESSION_TRACK                  = 0x0080_0000;\n+    \n+        \/\/\/ Client no longer needs EOF_Packet and will use OK_Packet instead.\n+        \/\/\/\n+        \/\/\/ ### Server\n+        \/\/\/ Can send OK after a Text Resultset.\n+        \/\/\/\n+        \/\/\/ ### Client\n+        \/\/\/ Expects an OK_Packet (instead of EOF_Packet) after the resultset\n+        \/\/\/ rows of a Text Resultset.\n+        \/\/\/\n+        \/\/\/ ### Background\n+        \/\/\/ To support CLIENT_SESSION_TRACK, additional information must be sent after all\n+        \/\/\/ successful commands. Although the OK_Packet is extensible, the EOF_Packet is\n+        \/\/\/ not due to the overlap of its bytes with the content of the Text Resultset Row.\n+        \/\/\/\n+        \/\/\/ Therefore, the EOF_Packet in the Text Resultset is replaced with an OK_Packet.\n+        \/\/\/ EOF_Packet is deprecated as of MySQL 5.7.5.\n+        const CLIENT_DEPRECATE_EOF                  = 0x0100_0000;\n+    \n+        \/\/\/ The client can handle optional metadata information in the resultset.\n+        const CLIENT_OPTIONAL_RESULTSET_METADATA    = 0x0200_0000;\n+    \n+        \/\/\/ Compression protocol extended to support zstd compression method.\n+        \/\/\/\n+        \/\/\/ This capability flag is used to send zstd compression level between client and server\n+        \/\/\/ provided both client and server are enabled with this flag.\n+        \/\/\/\n+        \/\/\/ # Server\n+        \/\/\/\n+        \/\/\/ Server sets this flag when global variable protocol-compression-algorithms has zstd\n+        \/\/\/ in its list of supported values.\n+        \/\/\/\n+        \/\/\/ # Client\n+        \/\/\/\n+        \/\/\/ Client sets this flag when it is configured to use zstd compression method.\n+        const CLIENT_ZSTD_COMPRESSION_ALGORITHM     = 0x0400_0000;\n+    \n+        \/\/\/ Support optional extension for query parameters into the COM_QUERY\n+        \/\/\/ and COM_STMT_EXECUTE packets.\n+        \/\/\/\n+        \/\/\/ # Server\n+        \/\/\/\n+        \/\/\/ Expects an optional part containing the query parameter set(s).\n+        \/\/\/ Executes the query for each set of parameters or returns an error if more than 1 set\n+        \/\/\/ of parameters is sent and the server can't execute it.\n+        \/\/\/\n+        \/\/\/ # Client\n+        \/\/\/\n+        \/\/\/ Can send the optional part containing the query parameter set(s).\n+        const CLIENT_QUERY_ATTRIBUTES               = 0x0800_0000;\n+    \n+        \/\/\/ Support Multi factor authentication.\n+        \/\/\/\n+        \/\/\/ # Server\n+        \/\/\/\n+        \/\/\/ Server sends AuthNextFactor packet after every nth factor\n+        \/\/\/ authentication method succeeds, except the last factor authentication.\n+        \/\/\/\n+        \/\/\/ # Client\n+        \/\/\/\n+        \/\/\/ Client reads AuthNextFactor packet sent by server\n+        \/\/\/ and initiates next factor authentication method.\n+        const MULTI_FACTOR_AUTHENTICATION           = 0x1000_0000;\n+    \n+        \/\/\/ Client or server supports progress reports within error packet.\n+        const CLIENT_PROGRESS_OBSOLETE              = 0x2000_0000;\n+    \n+        \/\/\/ Verify server certificate. Client only flag.\n+        \/\/\/\n+        \/\/\/ Deprecated in favor of \u2013ssl-mode.\n+        const CLIENT_SSL_VERIFY_SERVER_CERT         = 0x4000_0000;\n+    \n+        \/\/\/ Don't reset the options after an unsuccessful connect. Client only flag.\n+        const CLIENT_REMEMBER_OPTIONS               = 0x8000_0000;\n+    }\n+}\n+\n+fn main() {\n+\n+}\n","hints_text":"This should be trivially fixed by swapping the order attributes are \"pushed\" in `__declare_bitflags`. We've already yanked `2.2.0` because it requires a lot more recursion, but will keep this open to make sure any new approach doesn't reverse the order of attributes.","base_commit":"cbcafa710fc31172511e62efa06ad9eb214e4734","issue_numbers":["344"],"created_at":"2023-04-24T04:29:26Z","pull_number":345,"instance_id":"bitflags__bitflags-345","patch":"diff --git a\/src\/example_generated.rs b\/src\/example_generated.rs\n--- a\/src\/example_generated.rs\n+++ b\/src\/example_generated.rs\n@@ -33,8 +33,17 @@ __impl_public_bitflags! {\n \n __impl_public_bitflags_consts! {\n     Flags {\n+        \/\/\/ Field `A`.\n+        \/\/\/\n+        \/\/\/ This flag has the value `0b00000001`.\n         A = 0b00000001;\n+        \/\/\/ Field `B`.\n+        \/\/\/\n+        \/\/\/ This flag has the value `0b00000010`.\n         B = 0b00000010;\n+        \/\/\/ Field `C`.\n+        \/\/\/\n+        \/\/\/ This flag has the value `0b00000100`.\n         C = 0b00000100;\n         ABC = Self::A.bits() | Self::B.bits() | Self::C.bits();\n     }\ndiff --git a\/src\/internal.rs b\/src\/internal.rs\n--- a\/src\/internal.rs\n+++ b\/src\/internal.rs\n@@ -224,10 +224,14 @@ macro_rules! __impl_internal_bitflags {\n                 let mut truncated = <$T as $crate::__private::Bits>::EMPTY;\n \n                 $(\n-                    $(#[$attr $($args)*])*\n-                    if bits & $BitFlags::$Flag.bits() == $BitFlags::$Flag.bits() {\n-                        truncated |= $BitFlags::$Flag.bits()\n-                    }\n+                    __expr_safe_flags!(\n+                        $(#[$attr $($args)*])*\n+                        {\n+                            if bits & $BitFlags::$Flag.bits() == $BitFlags::$Flag.bits() {\n+                                truncated |= $BitFlags::$Flag.bits()\n+                            }\n+                        }\n+                    );\n                 )*\n \n                 Self { bits: truncated }\ndiff --git a\/src\/internal.rs b\/src\/internal.rs\n--- a\/src\/internal.rs\n+++ b\/src\/internal.rs\n@@ -240,13 +244,19 @@ macro_rules! __impl_internal_bitflags {\n \n             #[inline]\n             pub fn from_name(name: &str) -> $crate::__private::core::option::Option<Self> {\n-                match name {\n-                    $(\n+                $(\n+                    __expr_safe_flags!(\n                         $(#[$attr $($args)*])*\n-                        $crate::__private::core::stringify!($Flag) => $crate::__private::core::option::Option::Some(Self { bits: $BitFlags::$Flag.bits() }),\n-                    )*\n-                    _ => $crate::__private::core::option::Option::None,\n-                }\n+                        {\n+                            if name == $crate::__private::core::stringify!($Flag) {\n+                                return $crate::__private::core::option::Option::Some(Self { bits: $BitFlags::$Flag.bits() });\n+                            }\n+                        }\n+                    );\n+                )*\n+\n+                let _ = name;\n+                $crate::__private::core::option::Option::None\n             }\n \n             #[inline]\ndiff --git a\/src\/internal.rs b\/src\/internal.rs\n--- a\/src\/internal.rs\n+++ b\/src\/internal.rs\n@@ -384,10 +394,12 @@ macro_rules! __impl_internal_bitflags {\n                     let mut num_flags = 0;\n \n                     $(\n-                        $(#[$attr $($args)*])*\n-                        {\n-                            num_flags += 1;\n-                        }\n+                        __expr_safe_flags!(\n+                            $(#[$attr $($args)*])*\n+                            {\n+                                { num_flags += 1; }\n+                            }\n+                        );\n                     )*\n \n                     num_flags\ndiff --git a\/src\/internal.rs b\/src\/internal.rs\n--- a\/src\/internal.rs\n+++ b\/src\/internal.rs\n@@ -395,15 +407,23 @@ macro_rules! __impl_internal_bitflags {\n \n                 const OPTIONS: [$T; NUM_FLAGS] = [\n                     $(\n-                        $(#[$attr $($args)*])*\n-                        $BitFlags::$Flag.bits(),\n+                        __expr_safe_flags!(\n+                            $(#[$attr $($args)*])*\n+                            {\n+                                $BitFlags::$Flag.bits()\n+                            }\n+                        ),\n                     )*\n                 ];\n \n                 const OPTIONS_NAMES: [&'static str; NUM_FLAGS] = [\n                     $(\n-                        $(#[$attr $($args)*])*\n-                        $crate::__private::core::stringify!($Flag),\n+                        __expr_safe_flags!(\n+                            $(#[$attr $($args)*])*\n+                            {\n+                                $crate::__private::core::stringify!($Flag)\n+                            }\n+                        ),\n                     )*\n                 ];\n \ndiff --git a\/src\/internal.rs b\/src\/internal.rs\n--- a\/src\/internal.rs\n+++ b\/src\/internal.rs\n@@ -439,3 +459,112 @@ macro_rules! __impl_internal_bitflags {\n         }\n     };\n }\n+\n+\/\/\/ A macro that processed the input to `bitflags!` and shuffles attributes around\n+\/\/\/ based on whether or not they're \"expression-safe\".\n+\/\/\/\n+\/\/\/ This macro is a token-tree muncher that works on 2 levels:\n+\/\/\/\n+\/\/\/ For each attribute, we explicitly match on its identifier, like `cfg` to determine\n+\/\/\/ whether or not it should be considered expression-safe.\n+\/\/\/\n+\/\/\/ If you find yourself with an attribute that should be considered expression-safe\n+\/\/\/ and isn't, it can be added here.\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+macro_rules! __expr_safe_flags {\n+    \/\/ Entrypoint: Move all flags and all attributes into `unprocessed` lists\n+    \/\/ where they'll be munched one-at-a-time\n+    (\n+        $(#[$inner:ident $($args:tt)*])*\n+        { $e:expr }\n+    ) => {\n+        __expr_safe_flags! {\n+            expr: { $e },\n+            attrs: {\n+                \/\/ All attributes start here\n+                unprocessed: [$(#[$inner $($args)*])*],\n+                processed: {\n+                    \/\/ Attributes that are safe on expressions go here\n+                    expr: [],\n+                },\n+            },\n+        }\n+    };\n+    \/\/ Process the next attribute on the current flag\n+    \/\/ `cfg`: The next flag should be propagated to expressions\n+    \/\/ NOTE: You can copy this rules block and replace `cfg` with\n+    \/\/ your attribute name that should be considered expression-safe\n+    (\n+        expr: { $e:expr },\n+            attrs: {\n+            unprocessed: [\n+                \/\/ cfg matched here\n+                #[cfg $($args:tt)*]\n+                $($attrs_rest:tt)*\n+            ],\n+            processed: {\n+                expr: [$($expr:tt)*],\n+            },\n+        },\n+    ) => {\n+        __expr_safe_flags! {\n+            expr: { $e },\n+            attrs: {\n+                unprocessed: [\n+                    $($attrs_rest)*\n+                ],\n+                processed: {\n+                    expr: [\n+                        $($expr)*\n+                        \/\/ cfg added here\n+                        #[cfg $($args)*]\n+                    ],\n+                },\n+            },\n+        }\n+    };\n+    \/\/ Process the next attribute on the current flag\n+    \/\/ `$other`: The next flag should not be propagated to expressions\n+    (\n+        expr: { $e:expr },\n+            attrs: {\n+            unprocessed: [\n+                \/\/ $other matched here\n+                #[$other:ident $($args:tt)*]\n+                $($attrs_rest:tt)*\n+            ],\n+            processed: {\n+                expr: [$($expr:tt)*],\n+            },\n+        },\n+    ) => {\n+        __expr_safe_flags! {\n+            expr: { $e },\n+                attrs: {\n+                unprocessed: [\n+                    $($attrs_rest)*\n+                ],\n+                processed: {\n+                    expr: [\n+                        \/\/ $other not added here\n+                        $($expr)*\n+                    ],\n+                },\n+            },\n+        }\n+    };\n+    \/\/ Once all attributes on all flags are processed, generate the actual code\n+    (\n+        expr: { $e:expr },\n+        attrs: {\n+            unprocessed: [],\n+            processed: {\n+                expr: [$(#[$expr:ident $($exprargs:tt)*])*],\n+            },\n+        },\n+    ) => {\n+        $(#[$expr $($exprargs)*])*\n+        { $e }\n+    }\n+}\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -558,315 +558,6 @@ macro_rules! bitflags {\n         }\n \n         $($t:tt)*\n-    ) => {\n-        __declare_bitflags!(\n-            $(#[$outer])*\n-            $vis struct $BitFlags: $T {\n-                $(\n-                    $(#[$inner $($args)*])*\n-                    const $Flag = $value;\n-                )*\n-            }\n-        );\n-\n-        bitflags! {\n-            $($t)*\n-        }\n-    };\n-    () => {};\n-}\n-\n-\/\/\/ A macro that processed the input to `bitflags!` and shuffles attributes around\n-\/\/\/ based on whether or not they're \"expression-safe\".\n-\/\/\/\n-\/\/\/ This macro is a token-tree muncher that works on 2 levels:\n-\/\/\/\n-\/\/\/ 1. Each flag, like `#[cfg(true)] const A: 42`\n-\/\/\/ 2. Each attribute on that flag, like `#[cfg(true)]`\n-\/\/\/\n-\/\/\/ Flags and attributes start in an \"unprocessed\" list, and are shifted one token\n-\/\/\/ at a time into an appropriate processed list until the unprocessed lists are empty.\n-\/\/\/\n-\/\/\/ For each attribute, we explicitly match on its identifier, like `cfg` to determine\n-\/\/\/ whether or not it should be considered expression-safe.\n-\/\/\/\n-\/\/\/ If you find yourself with an attribute that should be considered expression-safe\n-\/\/\/ and isn't, it can be added here.\n-#[macro_export(local_inner_macros)]\n-#[doc(hidden)]\n-macro_rules! __declare_bitflags {\n-    \/\/ Entrypoint: Move all flags and all attributes into `unprocessed` lists\n-    \/\/ where they'll be munched one-at-a-time\n-    (\n-        $(#[$outer:meta])*\n-        $vis:vis struct $BitFlags:ident: $T:ty {\n-            $(\n-                $(#[$inner:ident $($args:tt)*])*\n-                const $Flag:ident = $value:expr;\n-            )*\n-        }\n-    ) => {\n-        __declare_bitflags! {\n-            decl: {\n-                attrs: [$(#[$outer])*],\n-                vis: $vis,\n-                ident: $BitFlags,\n-                ty: $T,\n-            },\n-            flags: {\n-                \/\/ All flags start here\n-                unprocessed: [\n-                    $(\n-                        {\n-                            ident: $Flag,\n-                            value: $value,\n-                            attrs: {\n-                                \/\/ All attributes start here\n-                                unprocessed: [$(#[$inner $($args)*])*],\n-                                processed: {\n-                                    \/\/ Attributes that should be added to item declarations go here\n-                                    decl: [],\n-                                    \/\/ Attributes that are safe on expressions go here\n-                                    expr: [],\n-                                }\n-                            },\n-                        },\n-                    )*\n-                ],\n-                \/\/ Flags that have had their attributes sorted are pushed here\n-                processed: [],\n-            }\n-        }\n-    };\n-    \/\/ Process the next attribute on the current flag\n-    \/\/ `cfg`: The next flag should be propagated to expressions\n-    \/\/ NOTE: You can copy this rules block and replace `cfg` with\n-    \/\/ your attribute name that should be considered expression-safe\n-    (\n-        decl: {\n-            attrs: [$(#[$outer:meta])*],\n-            vis: $vis:vis,\n-            ident: $BitFlags:ident,\n-            ty: $T:ty,\n-        },\n-        flags: {\n-            unprocessed: [\n-                {\n-                    ident: $Flag:ident,\n-                    value: $value:expr,\n-                    attrs: {\n-                        unprocessed: [\n-                            \/\/ cfg matched here\n-                            #[cfg $($args:tt)*]\n-                            $($attrs_rest:tt)*\n-                        ],\n-                        processed: {\n-                            decl: [$($decl:tt)*],\n-                            expr: [$($expr:tt)*],\n-                        }\n-                    },\n-                },\n-                $($flags_rest:tt)*\n-            ],\n-            processed: [\n-                $($flags:tt)*\n-            ],\n-        }\n-    ) => {\n-        __declare_bitflags! {\n-            decl: {\n-                attrs: [$(#[$outer])*],\n-                vis: $vis,\n-                ident: $BitFlags,\n-                ty: $T,\n-            },\n-            flags: {\n-                unprocessed: [\n-                    {\n-                        ident: $Flag,\n-                        value: $value,\n-                        attrs: {\n-                            unprocessed: [\n-                                $($attrs_rest)*\n-                            ],\n-                            processed: {\n-                                decl: [\n-                                    \/\/ cfg added here\n-                                    #[cfg $($args)*]\n-                                    $($decl)*\n-                                ],\n-                                expr: [\n-                                    \/\/ cfg added here\n-                                    #[cfg $($args)*]\n-                                    $($expr)*\n-                                ],\n-                            }\n-                        },\n-                    },\n-                    $($flags_rest)*\n-                ],\n-                processed: [\n-                    $($flags)*\n-                ],\n-            }\n-        }\n-    };\n-    \/\/ Process the next attribute on the current flag\n-    \/\/ `$other`: The next flag should not be propagated to expressions\n-    (\n-        decl: {\n-            attrs: [$(#[$outer:meta])*],\n-            vis: $vis:vis,\n-            ident: $BitFlags:ident,\n-            ty: $T:ty,\n-        },\n-        flags: {\n-            unprocessed: [\n-                {\n-                    ident: $Flag:ident,\n-                    value: $value:expr,\n-                    attrs: {\n-                        unprocessed: [\n-                            \/\/ $other matched here\n-                            #[$other:ident $($args:tt)*]\n-                            $($attrs_rest:tt)*\n-                        ],\n-                        processed: {\n-                            decl: [$($decl:tt)*],\n-                            expr: [$($expr:tt)*],\n-                        }\n-                    },\n-                },\n-                $($flags_rest:tt)*\n-            ],\n-            processed: [\n-                $($flags:tt)*\n-            ],\n-        }\n-    ) => {\n-        __declare_bitflags! {\n-            decl: {\n-                attrs: [$(#[$outer])*],\n-                vis: $vis,\n-                ident: $BitFlags,\n-                ty: $T,\n-            },\n-            flags: {\n-                unprocessed: [\n-                    {\n-                        ident: $Flag,\n-                        value: $value,\n-                        attrs: {\n-                            unprocessed: [\n-                                $($attrs_rest)*\n-                            ],\n-                            processed: {\n-                                decl: [\n-                                    \/\/ $other added here\n-                                    #[$other $($args)*]\n-                                    $($decl)*\n-                                ],\n-                                expr: [\n-                                    \/\/ $other not added here\n-                                    $($expr)*\n-                                ],\n-                            }\n-                        },\n-                    },\n-                    $($flags_rest)*\n-                ],\n-                processed: [\n-                    $($flags)*\n-                ],\n-            }\n-        }\n-    };\n-    \/\/ Complete the current flag once there are no unprocessed attributes left\n-    (\n-        decl: {\n-            attrs: [$(#[$outer:meta])*],\n-            vis: $vis:vis,\n-            ident: $BitFlags:ident,\n-            ty: $T:ty,\n-        },\n-        flags: {\n-            unprocessed: [\n-                {\n-                    ident: $Flag:ident,\n-                    value: $value:expr,\n-                    attrs: {\n-                        unprocessed: [],\n-                        processed: {\n-                            decl: [$($decl:tt)*],\n-                            expr: [$($expr:tt)*],\n-                        }\n-                    },\n-                },\n-                $($flags_rest:tt)*\n-            ],\n-            processed: [\n-                $($flags:tt)*\n-            ],\n-        }\n-    ) => {\n-        __declare_bitflags! {\n-            decl: {\n-                attrs: [$(#[$outer])*],\n-                vis: $vis,\n-                ident: $BitFlags,\n-                ty: $T,\n-            },\n-            flags: {\n-                unprocessed: [\n-                    $($flags_rest)*\n-                ],\n-                processed: [\n-                    $($flags)*\n-                    {\n-                        ident: $Flag,\n-                        value: $value,\n-                        attrs: {\n-                            unprocessed: [],\n-                            processed: {\n-                                decl: [\n-                                    $($decl)*\n-                                ],\n-                                expr: [\n-                                    $($expr)*\n-                                ],\n-                            }\n-                        },\n-                    },\n-                ],\n-            }\n-        }\n-    };\n-    \/\/ Once all attributes on all flags are processed, generate the actual code\n-    (\n-        decl: {\n-            attrs: [$(#[$outer:meta])*],\n-            vis: $vis:vis,\n-            ident: $BitFlags:ident,\n-            ty: $T:ty,\n-        },\n-        flags: {\n-            unprocessed: [],\n-            processed: [\n-                $(\n-                    {\n-                        ident: $Flag:ident,\n-                        value: $value:expr,\n-                        attrs: {\n-                            unprocessed: [],\n-                            processed: {\n-                                decl: [$(#[$decl:ident $($declargs:tt)*])*],\n-                                expr: [$(#[$expr:ident $($exprargs:tt)*])*],\n-                            }\n-                        },\n-                    },\n-                )*\n-            ],\n-        }\n     ) => {\n         \/\/ Declared in the scope of the `bitflags!` call\n         \/\/ This type appears in the end-user's API\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -879,7 +570,7 @@ macro_rules! __declare_bitflags {\n         __impl_public_bitflags_consts! {\n             $BitFlags {\n                 $(\n-                    $(#[$decl $($declargs)*])*\n+                    $(#[$inner $($args)*])*\n                     #[allow(\n                         dead_code,\n                         deprecated,\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -912,7 +603,7 @@ macro_rules! __declare_bitflags {\n             __impl_internal_bitflags! {\n                 InternalBitFlags: $T, $BitFlags, Iter, IterRaw {\n                     $(\n-                        $(#[$expr $($exprargs)*])*\n+                        $(#[$inner $($args)*])*\n                         $Flag;\n                     )*\n                 }\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -922,7 +613,7 @@ macro_rules! __declare_bitflags {\n             __impl_external_bitflags! {\n                 InternalBitFlags: $T {\n                     $(\n-                        $(#[$expr $($exprargs)*])*\n+                        $(#[$inner $($args)*])*\n                         $Flag;\n                     )*\n                 }\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -932,7 +623,12 @@ macro_rules! __declare_bitflags {\n                 $BitFlags: $T, InternalBitFlags, Iter, IterRaw;\n             }\n         };\n-    }\n+\n+        bitflags! {\n+            $($t)*\n+        }\n+    };\n+    () => {};\n }\n \n #[macro_use]\n","version":"2.2","repo":"bitflags\/bitflags","environment_setup_commit":"1d8388bf4ce18afde846d220ad8b6e0dc40aae94"}
{"problem_statement":"Cannot use `#[doc(alias)]`\nThe following code:\r\n```rs\r\nbitflags::bitflags! {\r\n  #[doc(alias = \"SYMBOLIC_LINK_FLAGS\")]\r\n  pub struct SymbolicLinkFlags:u32 {\r\n    #[doc(alias = \"SYMBOLIC_LINK_FLAG_DIRECTORY\")]\r\n    const DIRECTORY = 0x1;\r\n    #[doc(alias = \"SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE\")]\r\n    const ALLOW_UNPRIVILEGED_CREATE = 0x2;\r\n  }\r\n}\r\n```\r\nProduces the error:\r\n```\r\nerror: `#[doc(alias = \"...\")]` isn't allowed on expression\r\n  --> src\\fs.rs:67:15\r\n   |\r\n67 |         #[doc(alias = \"SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE\")]\r\n   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n```\n","test_patch":"diff --git \/dev\/null b\/tests\/compile-pass\/doc_alias.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/tests\/compile-pass\/doc_alias.rs\n@@ -0,0 +1,14 @@\n+#[macro_use]\n+extern crate bitflags;\n+\n+bitflags! {\n+    #[doc(alias = \"FLAG\")]\n+    pub struct Flags: u8 {\n+        #[doc(alias = \"FLAG_A\")]\n+        const A = 1;\n+    }\n+}\n+\n+fn main() {\n+    \n+}\n","hints_text":"This is a general problem for attributes that can't be applied to expressions now. In methods like `from_name` we now generate code like this:\r\n\r\n```rust\r\n#[inline]\r\npub fn from_name(name: &str) -> ::bitflags::__private::core::option::Option<Self> {\r\n    match name {\r\n        #[doc(alias = \"SYMBOLIC_LINK_FLAG_DIRECTORY\")]\r\n        \"DIRECTORY\" => ::bitflags::__private::core::option::Option::Some(Self {\r\n            bits: SymbolicLinkFlags::DIRECTORY.bits(),\r\n        }),\r\n        #[doc(alias = \"SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE\")]\r\n        \"ALLOW_UNPRIVILEGED_CREATE\" => {\r\n            ::bitflags::__private::core::option::Option::Some(Self {\r\n                bits: SymbolicLinkFlags::ALLOW_UNPRIVILEGED_CREATE.bits(),\r\n            })\r\n        }\r\n        _ => ::bitflags::__private::core::option::Option::None,\r\n    }\r\n}\r\n```\r\n\r\nI think the quickest fix would be to introduce a helper macro that filtered out some attributes like `#[doc(..)]` for these match arms. Any more of these that come up in the future could be added to that macro.\nWhat kinds of attributes would be useful to apply there other than `cfg`?\nI can't really think of any besides maybe `#[allow]`, but we handle those on the item itself. I think it would be fair to flip this into an allow-list so only `cfg` attributes get propagated.","base_commit":"dc971042c8132a5381ab3e2165983ee7f9d44c63","issue_numbers":["308"],"created_at":"2023-04-18T00:36:26Z","pull_number":341,"instance_id":"bitflags__bitflags-341","patch":"diff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -558,6 +558,315 @@ macro_rules! bitflags {\n         }\n \n         $($t:tt)*\n+    ) => {\n+        __declare_bitflags!(\n+            $(#[$outer])*\n+            $vis struct $BitFlags: $T {\n+                $(\n+                    $(#[$inner $($args)*])*\n+                    const $Flag = $value;\n+                )*\n+            }\n+        );\n+\n+        bitflags! {\n+            $($t)*\n+        }\n+    };\n+    () => {};\n+}\n+\n+\/\/\/ A macro that processed the input to `bitflags!` and shuffles attributes around\n+\/\/\/ based on whether or not they're \"expression-safe\".\n+\/\/\/\n+\/\/\/ This macro is a token-tree muncher that works on 2 levels:\n+\/\/\/\n+\/\/\/ 1. Each flag, like `#[cfg(true)] const A: 42`\n+\/\/\/ 2. Each attribute on that flag, like `#[cfg(true)]`\n+\/\/\/\n+\/\/\/ Flags and attributes start in an \"unprocessed\" list, and are shifted one token\n+\/\/\/ at a time into an appropriate processed list until the unprocessed lists are empty.\n+\/\/\/\n+\/\/\/ For each attribute, we explicitly match on its identifier, like `cfg` to determine\n+\/\/\/ whether or not it should be considered expression-safe.\n+\/\/\/\n+\/\/\/ If you find yourself with an attribute that should be considered expression-safe\n+\/\/\/ and isn't, it can be added here.\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+macro_rules! __declare_bitflags {\n+    \/\/ Entrypoint: Move all flags and all attributes into `unprocessed` lists\n+    \/\/ where they'll be munched one-at-a-time\n+    (\n+        $(#[$outer:meta])*\n+        $vis:vis struct $BitFlags:ident: $T:ty {\n+            $(\n+                $(#[$inner:ident $($args:tt)*])*\n+                const $Flag:ident = $value:expr;\n+            )*\n+        }\n+    ) => {\n+        __declare_bitflags! {\n+            decl: {\n+                attrs: [$(#[$outer])*],\n+                vis: $vis,\n+                ident: $BitFlags,\n+                ty: $T,\n+            },\n+            flags: {\n+                \/\/ All flags start here\n+                unprocessed: [\n+                    $(\n+                        {\n+                            ident: $Flag,\n+                            value: $value,\n+                            attrs: {\n+                                \/\/ All attributes start here\n+                                unprocessed: [$(#[$inner $($args)*])*],\n+                                processed: {\n+                                    \/\/ Attributes that should be added to item declarations go here\n+                                    decl: [],\n+                                    \/\/ Attributes that are safe on expressions go here\n+                                    expr: [],\n+                                }\n+                            },\n+                        },\n+                    )*\n+                ],\n+                \/\/ Flags that have had their attributes sorted are pushed here\n+                processed: [],\n+            }\n+        }\n+    };\n+    \/\/ Process the next attribute on the current flag\n+    \/\/ `cfg`: The next flag should be propagated to expressions\n+    \/\/ NOTE: You can copy this rules block and replace `cfg` with\n+    \/\/ your attribute name that should be considered expression-safe\n+    (\n+        decl: {\n+            attrs: [$(#[$outer:meta])*],\n+            vis: $vis:vis,\n+            ident: $BitFlags:ident,\n+            ty: $T:ty,\n+        },\n+        flags: {\n+            unprocessed: [\n+                {\n+                    ident: $Flag:ident,\n+                    value: $value:expr,\n+                    attrs: {\n+                        unprocessed: [\n+                            \/\/ cfg matched here\n+                            #[cfg $($args:tt)*]\n+                            $($attrs_rest:tt)*\n+                        ],\n+                        processed: {\n+                            decl: [$($decl:tt)*],\n+                            expr: [$($expr:tt)*],\n+                        }\n+                    },\n+                },\n+                $($flags_rest:tt)*\n+            ],\n+            processed: [\n+                $($flags:tt)*\n+            ],\n+        }\n+    ) => {\n+        __declare_bitflags! {\n+            decl: {\n+                attrs: [$(#[$outer])*],\n+                vis: $vis,\n+                ident: $BitFlags,\n+                ty: $T,\n+            },\n+            flags: {\n+                unprocessed: [\n+                    {\n+                        ident: $Flag,\n+                        value: $value,\n+                        attrs: {\n+                            unprocessed: [\n+                                $($attrs_rest)*\n+                            ],\n+                            processed: {\n+                                decl: [\n+                                    \/\/ cfg added here\n+                                    #[cfg $($args)*]\n+                                    $($decl)*\n+                                ],\n+                                expr: [\n+                                    \/\/ cfg added here\n+                                    #[cfg $($args)*]\n+                                    $($expr)*\n+                                ],\n+                            }\n+                        },\n+                    },\n+                    $($flags_rest)*\n+                ],\n+                processed: [\n+                    $($flags)*\n+                ],\n+            }\n+        }\n+    };\n+    \/\/ Process the next attribute on the current flag\n+    \/\/ `$other`: The next flag should not be propagated to expressions\n+    (\n+        decl: {\n+            attrs: [$(#[$outer:meta])*],\n+            vis: $vis:vis,\n+            ident: $BitFlags:ident,\n+            ty: $T:ty,\n+        },\n+        flags: {\n+            unprocessed: [\n+                {\n+                    ident: $Flag:ident,\n+                    value: $value:expr,\n+                    attrs: {\n+                        unprocessed: [\n+                            \/\/ $other matched here\n+                            #[$other:ident $($args:tt)*]\n+                            $($attrs_rest:tt)*\n+                        ],\n+                        processed: {\n+                            decl: [$($decl:tt)*],\n+                            expr: [$($expr:tt)*],\n+                        }\n+                    },\n+                },\n+                $($flags_rest:tt)*\n+            ],\n+            processed: [\n+                $($flags:tt)*\n+            ],\n+        }\n+    ) => {\n+        __declare_bitflags! {\n+            decl: {\n+                attrs: [$(#[$outer])*],\n+                vis: $vis,\n+                ident: $BitFlags,\n+                ty: $T,\n+            },\n+            flags: {\n+                unprocessed: [\n+                    {\n+                        ident: $Flag,\n+                        value: $value,\n+                        attrs: {\n+                            unprocessed: [\n+                                $($attrs_rest)*\n+                            ],\n+                            processed: {\n+                                decl: [\n+                                    \/\/ $other added here\n+                                    #[$other $($args)*]\n+                                    $($decl)*\n+                                ],\n+                                expr: [\n+                                    \/\/ $other not added here\n+                                    $($expr)*\n+                                ],\n+                            }\n+                        },\n+                    },\n+                    $($flags_rest)*\n+                ],\n+                processed: [\n+                    $($flags)*\n+                ],\n+            }\n+        }\n+    };\n+    \/\/ Complete the current flag once there are no unprocessed attributes left\n+    (\n+        decl: {\n+            attrs: [$(#[$outer:meta])*],\n+            vis: $vis:vis,\n+            ident: $BitFlags:ident,\n+            ty: $T:ty,\n+        },\n+        flags: {\n+            unprocessed: [\n+                {\n+                    ident: $Flag:ident,\n+                    value: $value:expr,\n+                    attrs: {\n+                        unprocessed: [],\n+                        processed: {\n+                            decl: [$($decl:tt)*],\n+                            expr: [$($expr:tt)*],\n+                        }\n+                    },\n+                },\n+                $($flags_rest:tt)*\n+            ],\n+            processed: [\n+                $($flags:tt)*\n+            ],\n+        }\n+    ) => {\n+        __declare_bitflags! {\n+            decl: {\n+                attrs: [$(#[$outer])*],\n+                vis: $vis,\n+                ident: $BitFlags,\n+                ty: $T,\n+            },\n+            flags: {\n+                unprocessed: [\n+                    $($flags_rest)*\n+                ],\n+                processed: [\n+                    $($flags)*\n+                    {\n+                        ident: $Flag,\n+                        value: $value,\n+                        attrs: {\n+                            unprocessed: [],\n+                            processed: {\n+                                decl: [\n+                                    $($decl)*\n+                                ],\n+                                expr: [\n+                                    $($expr)*\n+                                ],\n+                            }\n+                        },\n+                    },\n+                ],\n+            }\n+        }\n+    };\n+    \/\/ Once all attributes on all flags are processed, generate the actual code\n+    (\n+        decl: {\n+            attrs: [$(#[$outer:meta])*],\n+            vis: $vis:vis,\n+            ident: $BitFlags:ident,\n+            ty: $T:ty,\n+        },\n+        flags: {\n+            unprocessed: [],\n+            processed: [\n+                $(\n+                    {\n+                        ident: $Flag:ident,\n+                        value: $value:expr,\n+                        attrs: {\n+                            unprocessed: [],\n+                            processed: {\n+                                decl: [$(#[$decl:ident $($declargs:tt)*])*],\n+                                expr: [$(#[$expr:ident $($exprargs:tt)*])*],\n+                            }\n+                        },\n+                    },\n+                )*\n+            ],\n+        }\n     ) => {\n         \/\/ Declared in the scope of the `bitflags!` call\n         \/\/ This type appears in the end-user's API\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -570,7 +879,7 @@ macro_rules! bitflags {\n         __impl_public_bitflags_consts! {\n             $BitFlags {\n                 $(\n-                    $(#[$inner $($args)*])*\n+                    $(#[$decl $($declargs)*])*\n                     #[allow(\n                         dead_code,\n                         deprecated,\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -603,7 +912,7 @@ macro_rules! bitflags {\n             __impl_internal_bitflags! {\n                 InternalBitFlags: $T, $BitFlags, Iter, IterRaw {\n                     $(\n-                        $(#[$inner $($args)*])*\n+                        $(#[$expr $($exprargs)*])*\n                         $Flag;\n                     )*\n                 }\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -613,7 +922,7 @@ macro_rules! bitflags {\n             __impl_external_bitflags! {\n                 InternalBitFlags: $T {\n                     $(\n-                        $(#[$inner $($args)*])*\n+                        $(#[$expr $($exprargs)*])*\n                         $Flag;\n                     )*\n                 }\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -623,12 +932,7 @@ macro_rules! bitflags {\n                 $BitFlags: $T, InternalBitFlags, Iter, IterRaw;\n             }\n         };\n-\n-        bitflags! {\n-            $($t)*\n-        }\n-    };\n-    () => {};\n+    }\n }\n \n #[macro_use]\n","version":"2.1","repo":"bitflags\/bitflags","environment_setup_commit":"dc971042c8132a5381ab3e2165983ee7f9d44c63"}
{"problem_statement":"Support bytemuck\nFrom #310\r\n\r\nAdd a `bytemuck` Cargo feature that derives `bytemuck` traits on the generated inner flags type so end-users can then `#[derive(bytemuck::*)]` traits on their own flags types.\n","test_patch":"diff --git a\/Cargo.toml b\/Cargo.toml\n--- a\/Cargo.toml\n+++ b\/Cargo.toml\n@@ -22,6 +22,7 @@ exclude = [\"tests\", \".github\"]\n [dependencies]\n serde = { version = \"1.0\", optional = true, default-features = false }\n arbitrary = { version = \"1.0\", optional = true }\n+bytemuck = { version = \"1.0\", optional = true }\n core = { version = \"1.0.0\", optional = true, package = \"rustc-std-workspace-core\" }\n compiler_builtins = { version = \"0.1.2\", optional = true }\n \ndiff --git a\/Cargo.toml b\/Cargo.toml\n--- a\/Cargo.toml\n+++ b\/Cargo.toml\n@@ -32,6 +33,7 @@ serde_derive = \"1.0\"\n serde_json = \"1.0\"\n serde_test = \"1.0\"\n arbitrary = { version = \"1.0\", features = [\"derive\"] }\n+bytemuck = { version = \"1.0\", features = [\"derive\"] }\n \n [features]\n std = []\ndiff --git \/dev\/null b\/src\/external\/bytemuck_support.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/src\/external\/bytemuck_support.rs\n@@ -0,0 +1,19 @@\n+#[cfg(test)]\n+mod tests {\n+    use bytemuck::{Pod, Zeroable};\n+    \n+    bitflags! {\n+        #[derive(Pod, Zeroable, Clone, Copy)]\n+        #[repr(transparent)]\n+        struct Color: u32 {\n+            const RED = 0x1;\n+            const GREEN = 0x2;\n+            const BLUE = 0x4;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_bytemuck() {\n+        assert_eq!(0x1, bytemuck::cast::<Color, u32>(Color::RED));\n+    }\n+}\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -394,8 +394,9 @@\n \/\/! example docs.\n \n #![cfg_attr(not(any(feature = \"std\", test)), no_std)]\n+#![cfg_attr(not(test), forbid(unsafe_code))]\n+\n #![doc(html_root_url = \"https:\/\/docs.rs\/bitflags\/2.1.0\")]\n-#![forbid(unsafe_code)]\n \n #[doc(inline)]\n pub use traits::BitFlags;\n","hints_text":"","base_commit":"597d40749224d3eee125a6ea9d6ac4c92b898ee8","issue_numbers":["311"],"created_at":"2023-04-11T01:30:12Z","pull_number":336,"instance_id":"bitflags__bitflags-336","patch":"diff --git a\/src\/external.rs b\/src\/external.rs\n--- a\/src\/external.rs\n+++ b\/src\/external.rs\n@@ -1,10 +1,83 @@\n \/\/! Conditional trait implementations for external libraries.\n \n+\/*\n+How do I support a new external library?\n+\n+Let's say we want to add support for `my_library`.\n+\n+First, we define a macro like so:\n+\n+```rust\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+#[cfg(feature = \"serde\")]\n+macro_rules! __impl_external_bitflags_my_library {\n+    (\n+        $InternalBitFlags:ident: $T:ty {\n+            $(\n+                $(#[$attr:ident $($args:tt)*])*\n+                $Flag:ident;\n+            )*\n+        }\n+    ) => {\n+        \/\/ Implementation goes here\n+    };\n+}\n+\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+#[cfg(not(feature = \"my_library\"))]\n+macro_rules! __impl_external_bitflags_my_library {\n+    (\n+        $InternalBitFlags:ident: $T:ty {\n+            $(\n+                $(#[$attr:ident $($args:tt)*])*\n+                $Flag:ident;\n+            )*\n+        }\n+    ) => {};\n+}\n+```\n+\n+Note that the macro is actually defined twice; once for when the `my_library` feature\n+is available, and once for when it's not. This is because the `__impl_external_bitflags_my_library`\n+macro is called in an end-user's library, not in `bitflags`. In an end-user's library we don't\n+know whether or not a particular feature of `bitflags` is enabled, so we unconditionally call\n+the macro, where the body of that macro depends on the feature flag.\n+\n+Now, we add our macro call to the `__impl_external_bitflags` macro body:\n+\n+```rust\n+__impl_external_bitflags_my_library! {\n+    $InternalBitFlags: $T {\n+        $(\n+            $(#[$attr $($args)*])*\n+            $Flag;\n+        )*\n+    }\n+}\n+```\n+\n+What about libraries that _must_ be supported through `#[derive]`?\n+\n+In these cases, the attributes will need to be added to the `__declare_internal_bitflags` macro when\n+the internal type is declared.\n+*\/\n+\n #[cfg(feature = \"serde\")]\n pub mod serde_support;\n+#[cfg(feature = \"serde\")]\n+pub use serde;\n \n #[cfg(feature = \"arbitrary\")]\n pub mod arbitrary_support;\n+#[cfg(feature = \"arbitrary\")]\n+pub use arbitrary;\n+\n+#[cfg(feature = \"bytemuck\")]\n+pub mod bytemuck_support;\n+#[cfg(feature = \"bytemuck\")]\n+pub use bytemuck;\n \n \/\/\/ Implements traits from external libraries for the internal bitflags type.\n #[macro_export(local_inner_macros)]\ndiff --git a\/src\/external.rs b\/src\/external.rs\n--- a\/src\/external.rs\n+++ b\/src\/external.rs\n@@ -39,6 +112,15 @@ macro_rules! __impl_external_bitflags {\n                 )*\n             }\n         }\n+\n+        __impl_external_bitflags_bytemuck! {\n+            $InternalBitFlags: $T {\n+                $(\n+                    $(#[$attr $($args)*])*\n+                    $Flag;\n+                )*\n+            }\n+        }\n     };\n }\n \ndiff --git a\/src\/external.rs b\/src\/external.rs\n--- a\/src\/external.rs\n+++ b\/src\/external.rs\n@@ -129,3 +211,50 @@ macro_rules! __impl_external_bitflags_arbitrary {\n             }\n     ) => {};\n }\n+\n+\/\/\/ Implement `Pod` and `Zeroable` for the internal bitflags type.\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+#[cfg(feature = \"bytemuck\")]\n+macro_rules! __impl_external_bitflags_bytemuck {\n+    (\n+        $InternalBitFlags:ident: $T:ty {\n+            $(\n+                $(#[$attr:ident $($args:tt)*])*\n+                    $Flag:ident;\n+                )*\n+        }\n+    ) => {\n+        \/\/ SAFETY: $InternalBitFlags is guaranteed to have the same ABI as $T,\n+        \/\/ and $T implements Pod\n+        unsafe impl $crate::__private::bytemuck::Pod for $InternalBitFlags\n+        where\n+            $T: $crate::__private::bytemuck::Pod,\n+        {\n+\n+        }\n+\n+        \/\/ SAFETY: $InternalBitFlags is guaranteed to have the same ABI as $T,\n+        \/\/ and $T implements Zeroable\n+        unsafe impl $crate::__private::bytemuck::Zeroable for $InternalBitFlags\n+        where\n+            $T: $crate::__private::bytemuck::Zeroable,\n+        {\n+\n+        }\n+    };\n+}\n+\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+#[cfg(not(feature = \"bytemuck\"))]\n+macro_rules! __impl_external_bitflags_bytemuck {\n+    (\n+        $InternalBitFlags:ident: $T:ty {\n+            $(\n+                $(#[$attr:ident $($args:tt)*])*\n+                    $Flag:ident;\n+                )*\n+        }\n+    ) => {};\n+}\ndiff --git a\/src\/internal.rs b\/src\/internal.rs\n--- a\/src\/internal.rs\n+++ b\/src\/internal.rs\n@@ -14,6 +14,9 @@ macro_rules! __declare_internal_bitflags {\n         $iter_vis:vis struct $Iter:ident;\n         $iter_names_vis:vis struct $IterNames:ident;\n     ) => {\n+        \/\/ NOTE: The ABI of this type is _guaranteed_ to be the same as `T`\n+        \/\/ This is relied on by some external libraries like `bytemuck` to make\n+        \/\/ its `unsafe` trait impls sound.\n         #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n         #[repr(transparent)]\n         $vis struct $InternalBitFlags {\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -408,12 +409,6 @@ pub mod __private {\n     pub use crate::{external::*, traits::*};\n \n     pub use core;\n-\n-    #[cfg(feature = \"serde\")]\n-    pub use serde;\n-\n-    #[cfg(feature = \"arbitrary\")]\n-    pub use arbitrary;\n }\n \n \/*\ndiff --git a\/src\/public.rs b\/src\/public.rs\n--- a\/src\/public.rs\n+++ b\/src\/public.rs\n@@ -14,7 +14,7 @@ macro_rules! __declare_public_bitflags {\n         $vis:vis struct $BitFlags:ident;\n     ) => {\n         $(#[$outer])*\n-        $vis struct $BitFlags(<Self as $crate::__private::PublicFlags>::Internal);\n+        $vis struct $BitFlags(<$BitFlags as $crate::__private::PublicFlags>::Internal);\n     };\n }\n \n","version":"2.1","repo":"bitflags\/bitflags","environment_setup_commit":"dc971042c8132a5381ab3e2165983ee7f9d44c63"}
{"problem_statement":"Clarify means of printing human-readable string in 2.0.0\nIn bitflags 1.3, the automatic `Debug` implementation produced a concise human-readable string like \"`A | B`\"; in bitflags 2.0 it produces a string like \"`NameOfTheStruct(A | B)`\". This is an entirely reasonable change for `Debug`, since `Debug` is generally \u201cno promises\u201d, but if I want the previous string, it's not obvious how to get it. I dug around the examples and found in https:\/\/github.com\/bitflags\/bitflags\/blob\/main\/examples\/fmt.rs the remark that \r\n\r\n```rust\r\n        \/\/ You can `#[derive]` the `Debug` trait, but implementing it manually\r\n        \/\/ can produce output like `A | B` instead of `Flags(A | B)`.\r\n    ...\r\n    impl fmt::Debug for Flags {\r\n        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\r\n            fmt::Debug::fmt(&self.0, f)\r\n        }\r\n    }\r\n```\r\n\r\nbut it would be nice if this were in the library documentation under  \u201cDisplay and Debug\u201d, especially since the changelog said \u201cThe representation of generated flags types has changed from a struct with the single field bits to a newtype. That means you can't refer to the underlying bits using the .bits field.\u201d which led me to believe that `self.0` wasn't usable (though on further thought, the Rust privacy rules mean that it would be unlikely for that to be the case, since the type is defined in the user's module).\r\n\r\nThe existence of the `parser` module and the remark that \u201cThis library defines a standard text-based representation for flags that generated flags types can use.\u201d suggests that there should be an way to print that representation, but it doesn't go on to explain how.\r\n\r\nTherefore, I suggest the following changes:\r\n\r\n* Document that `self.0` implements `Display` and what the format of that is, at <https:\/\/docs.rs\/bitflags\/latest\/bitflags\/#debug-and-display>, and in the changelog for migration purposes.\r\n    * Put the \u201c`fmt(&self.0`\u201d trick in the documentation, not just an example.\r\n* Document all the other characteristics of `self.0` (what type is it? what properties does that type have?) if it is intended to be used.\n","test_patch":"diff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -342,6 +379,19 @@\n \/\/!\n \/\/! assert_eq!(2, count_unset_flags(&Flags::B));\n \/\/! ```\n+\/\/!\n+\/\/! # The internal field\n+\/\/!\n+\/\/! This library generates newtypes like:\n+\/\/!\n+\/\/! ```\n+\/\/! # pub struct Field0;\n+\/\/! pub struct Flags(Field0);\n+\/\/! ```\n+\/\/!\n+\/\/! You can freely use methods and trait implementations on this internal field as `.0`.\n+\/\/! For details on exactly what's generated for it, see the [`Field0`](example_generated\/struct.Field0.html)\n+\/\/! example docs.\n \n #![cfg_attr(not(any(feature = \"std\", test)), no_std)]\n #![doc(html_root_url = \"https:\/\/docs.rs\/bitflags\/2.0.2\")]\n","hints_text":"Thanks for the feedback @kpreid :+1:\r\n\r\nAny improvements we can make to the documentation would be worthwhile. We do [include generated docs for the internal `.0` field](https:\/\/docs.rs\/bitflags\/latest\/bitflags\/example_generated\/struct.Field0.html), but should call this out more so it's more obvious what it is.","base_commit":"11640f19a7644f3967631733f33ec87b9f911951","issue_numbers":["323"],"created_at":"2023-04-02T23:23:12Z","pull_number":328,"instance_id":"bitflags__bitflags-328","patch":"diff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -274,6 +274,43 @@\n \/\/! text-based representation for flags that generated flags types can use. For details on the exact\n \/\/! grammar, see the [`parser`] module.\n \/\/!\n+\/\/! To support formatting and parsing your generated flags types using that representation, you can implement\n+\/\/! the standard `Display` and `FromStr` traits in this fashion:\n+\/\/!\n+\/\/! ```\n+\/\/! use bitflags::bitflags;\n+\/\/! use std::{fmt, str};\n+\/\/!\n+\/\/! bitflags::bitflags! {\n+\/\/!     pub struct Flags: u32 {\n+\/\/!         const A = 1;\n+\/\/!         const B = 2;\n+\/\/!         const C = 4;\n+\/\/!         const D = 8;\n+\/\/!     }\n+\/\/! }\n+\/\/!\n+\/\/! impl fmt::Debug for Flags {\n+\/\/!     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+\/\/!         fmt::Debug::fmt(&self.0, f)\n+\/\/!     }\n+\/\/! }\n+\/\/!\n+\/\/! impl fmt::Display for Flags {\n+\/\/!     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+\/\/!         fmt::Display::fmt(&self.0, f)\n+\/\/!     }\n+\/\/! }\n+\/\/!\n+\/\/! impl str::FromStr for Flags {\n+\/\/!     type Err = bitflags::parser::ParseError;\n+\/\/!\n+\/\/!     fn from_str(flags: &str) -> Result<Self, Self::Err> {\n+\/\/!         Ok(Self(flags.parse()?))\n+\/\/!     }\n+\/\/! }\n+\/\/! ```\n+\/\/!\n \/\/! ## `PartialEq` and `PartialOrd`\n \/\/!\n \/\/! Equality and ordering can be derived for a reasonable implementation, or implemented manually\n","version":"2.0","repo":"bitflags\/bitflags","environment_setup_commit":"11640f19a7644f3967631733f33ec87b9f911951"}
{"problem_statement":"Implement Arbitrary for bitflags?\nWould it be worth it to have an optional implementation of [`Arbitrary`](https:\/\/docs.rs\/arbitrary\/1.0.1\/arbitrary\/trait.Arbitrary.html) (in the [arbitrary crate](https:\/\/crates.io\/crates\/arbitrary)) for bitflags types, to make it easier to use them in fuzzing?\r\n\r\nI'm imagining something along the lines of this, added to the macro expansion when `cfg(feature = \"arbitrary\")` or so:\r\n\r\n```rust\r\nimpl arbitrary::Arbitrary for $BitFlags {\r\n    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {\r\n         Self::from_bits(u.arbitrary()).ok_or_else(|| arbitrary::Error::IncorrectFormat)\r\n    }\r\n}\r\n```\r\n\n","test_patch":"diff --git a\/.github\/workflows\/rust.yml b\/.github\/workflows\/rust.yml\n--- a\/.github\/workflows\/rust.yml\n+++ b\/.github\/workflows\/rust.yml\n@@ -49,7 +49,7 @@ jobs:\n       run: cargo install cargo-hack\n \n     - name: Powerset\n-      run: cargo hack test --feature-powerset --lib --optional-deps \"std serde\" --depth 3 --skip rustc-dep-of-std\n+      run: cargo hack test --feature-powerset --lib --optional-deps --depth 3 --skip \"compiler_builtins core rustc-dep-of-std\"\n \n     - name: Docs\n       run: cargo doc --features example_generated\ndiff --git a\/Cargo.toml b\/Cargo.toml\n--- a\/Cargo.toml\n+++ b\/Cargo.toml\n@@ -21,6 +21,7 @@ exclude = [\"tests\", \".github\"]\n \n [dependencies]\n serde = { version = \"1.0\", optional = true, default-features = false }\n+arbitrary = { version = \"1.0\", optional = true }\n core = { version = \"1.0.0\", optional = true, package = \"rustc-std-workspace-core\" }\n compiler_builtins = { version = \"0.1.2\", optional = true }\n \ndiff --git a\/Cargo.toml b\/Cargo.toml\n--- a\/Cargo.toml\n+++ b\/Cargo.toml\n@@ -30,6 +31,7 @@ rustversion = \"1.0\"\n serde_derive = \"1.0\"\n serde_json = \"1.0\"\n serde_test = \"1.0\"\n+arbitrary = { version = \"1.0\", features = [\"derive\"] }\n \n [features]\n std = []\ndiff --git \/dev\/null b\/src\/external\/arbitrary_support.rs\nnew file mode 100644\n--- \/dev\/null\n+++ b\/src\/external\/arbitrary_support.rs\n@@ -0,0 +1,19 @@\n+#[cfg(test)]\n+mod tests {\n+    use arbitrary::Arbitrary;\n+\n+    bitflags! {\n+        #[derive(Arbitrary)]\n+        struct Color: u32 {\n+            const RED = 0x1;\n+            const GREEN = 0x2;\n+            const BLUE = 0x4;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_arbitrary() {\n+        let mut unstructured = arbitrary::Unstructured::new(&[0_u8; 256]);\n+        let _color = Color::arbitrary(&mut unstructured);\n+    }\n+}\n","hints_text":"Can we think of any other implementation for `Arbitrary` that a consumer might want to add themselves? If not then this seems like a reasonable addition to me, since as I understand it, `Arbitrary` is meant to be a general API that different fuzzer implementations can lean on. Anything that makes fuzzing easier to get started with is worth doing! \ud83d\ude01 \nI've now submitted #260 implementing this.\nWe've recently published `2.0.0` that reworks the library internals to support new external trait implementations without breaking consumers. We should now be able to add an implementation for `arbitrary` following the support for `serde` as an example.","base_commit":"11640f19a7644f3967631733f33ec87b9f911951","issue_numbers":["248"],"created_at":"2023-03-25T01:34:21Z","pull_number":324,"instance_id":"bitflags__bitflags-324","patch":"diff --git a\/src\/external.rs b\/src\/external.rs\n--- a\/src\/external.rs\n+++ b\/src\/external.rs\n@@ -3,6 +3,9 @@\n #[cfg(feature = \"serde\")]\n pub mod serde_support;\n \n+#[cfg(feature = \"arbitrary\")]\n+pub mod arbitrary_support;\n+\n \/\/\/ Implements traits from external libraries for the internal bitflags type.\n #[macro_export(local_inner_macros)]\n #[doc(hidden)]\ndiff --git a\/src\/external.rs b\/src\/external.rs\n--- a\/src\/external.rs\n+++ b\/src\/external.rs\n@@ -27,6 +30,15 @@ macro_rules! __impl_external_bitflags {\n                 )*\n             }\n         }\n+\n+        __impl_external_bitflags_arbitrary! {\n+            $InternalBitFlags: $T {\n+                $(\n+                    $(#[$attr $($args)*])*\n+                    $Flag;\n+                )*\n+            }\n+        }\n     };\n }\n \ndiff --git a\/src\/external.rs b\/src\/external.rs\n--- a\/src\/external.rs\n+++ b\/src\/external.rs\n@@ -80,3 +92,40 @@ macro_rules! __impl_external_bitflags_serde {\n         }\n     ) => {};\n }\n+\n+\/\/\/ Implement `Arbitrary` for the internal bitflags type.\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+#[cfg(feature = \"arbitrary\")]\n+macro_rules! __impl_external_bitflags_arbitrary {\n+    (\n+            $InternalBitFlags:ident: $T:ty {\n+                $(\n+                    $(#[$attr:ident $($args:tt)*])*\n+                    $Flag:ident;\n+                )*\n+            }\n+    ) => {\n+        impl<'a> $crate::__private::arbitrary::Arbitrary<'a> for $InternalBitFlags {\n+            fn arbitrary(\n+                u: &mut $crate::__private::arbitrary::Unstructured<'a>,\n+            ) -> $crate::__private::arbitrary::Result<Self> {\n+                Self::from_bits(u.arbitrary()?).ok_or_else(|| $crate::__private::arbitrary::Error::IncorrectFormat)\n+            }\n+        }\n+    };\n+}\n+\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+#[cfg(not(feature = \"arbitrary\"))]\n+macro_rules! __impl_external_bitflags_arbitrary {\n+    (\n+            $InternalBitFlags:ident: $T:ty {\n+                $(\n+                    $(#[$attr:ident $($args:tt)*])*\n+                    $Flag:ident;\n+                )*\n+            }\n+    ) => {};\n+}\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -361,6 +361,9 @@ pub mod __private {\n \n     #[cfg(feature = \"serde\")]\n     pub use serde;\n+\n+    #[cfg(feature = \"arbitrary\")]\n+    pub use arbitrary;\n }\n \n \/*\n","version":"2.0","repo":"bitflags\/bitflags","environment_setup_commit":"11640f19a7644f3967631733f33ec87b9f911951"}
