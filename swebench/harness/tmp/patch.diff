diff --git a/src/bitflags_trait.rs b/src/bitflags_trait.rs
--- a/src/bitflags_trait.rs
+++ b/src/bitflags_trait.rs
@@ -1,8 +1,5 @@
 use core::ops::{BitAnd, BitAndAssign, BitOr, BitOrAssign, BitXor, BitXorAssign, Not};
 
-#[doc(hidden)]
-pub trait ImplementedByBitFlagsMacro {}
-
 /// A trait that is automatically implemented for all bitflags.
 ///
 /// It should not be implemented manually.
diff --git a/src/bitflags_trait.rs b/src/bitflags_trait.rs
--- a/src/bitflags_trait.rs
+++ b/src/bitflags_trait.rs
@@ -25,16 +22,7 @@ pub trait BitFlags: ImplementedByBitFlagsMacro {
     fn from_bits_truncate(bits: Self::Bits) -> Self;
     /// Convert from underlying bit representation, preserving all
     /// bits (even those not corresponding to a defined flag).
-    ///
-    /// # Safety
-    ///
-    /// The caller of the `bitflags!` macro can chose to allow or
-    /// disallow extra bits for their bitflags type.
-    ///
-    /// The caller of `from_bits_unchecked()` has to ensure that
-    /// all bits correspond to a defined flag or that extra bits
-    /// are valid for this bitflags type.
-    unsafe fn from_bits_unchecked(bits: Self::Bits) -> Self;
+    fn from_bits_retain(bits: Self::Bits) -> Self;
     /// Returns `true` if no flags are currently stored.
     fn is_empty(&self) -> bool;
     /// Returns `true` if all flags are currently set.
diff --git a/src/bitflags_trait.rs b/src/bitflags_trait.rs
--- a/src/bitflags_trait.rs
+++ b/src/bitflags_trait.rs
@@ -53,9 +41,22 @@ pub trait BitFlags: ImplementedByBitFlagsMacro {
     fn set(&mut self, other: Self, value: bool);
 }
 
+/// A marker trait that signals that an implementation of `BitFlags` came from the `bitflags!` macro.
+///
+/// There's nothing stopping an end-user from implementing this trait, but we don't guarantee their
+/// manual implementations won't break between non-breaking releases.
+#[doc(hidden)]
+pub trait ImplementedByBitFlagsMacro {}
+
 // Not re-exported
 pub trait Sealed {}
 
+// Private implementation details
+//
+// The `Bits`, `PublicFlags`, and `InternalFlags` traits are implementation details of the `bitflags!`
+// macro that we're free to change here. They work with the `bitflags!` macro to separate the generated
+// code that belongs to end-users, and the generated code that belongs to this library.
+
 /// A private trait that encodes the requirements of underlying bits types that can hold flags.
 ///
 /// This trait may be made public at some future point, but it presents a compatibility hazard
diff --git a/src/bitflags_trait.rs b/src/bitflags_trait.rs
--- a/src/bitflags_trait.rs
+++ b/src/bitflags_trait.rs
@@ -107,3 +108,11 @@ impl_bits! {
     u64, i64,
     u128, i128,
 }
+
+pub trait PublicFlags {
+    type InternalFlags;
+}
+
+pub trait InternalFlags {
+    type PublicFlags;
+}
diff --git a/src/example_generated.rs b/src/example_generated.rs
--- a/src/example_generated.rs
+++ b/src/example_generated.rs
@@ -9,6 +9,35 @@ bitflags! {
         const A = 0b00000001;
         const B = 0b00000010;
         const C = 0b00000100;
-        const ABC = Self::A.bits | Self::B.bits | Self::C.bits;
+        const ABC = Self::A.bits() | Self::B.bits() | Self::C.bits();
     }
 }
+
+/// This is the same internal field available as `self.0` on bitflags types.
+/// These types aren't reachable by callers of `bitflags!`, they don't appear in the API of your
+/// crate, but you can still interact with them through `self.0` in the module that defines the
+/// bitflags type.
+///
+/// You can use this example as a reference for what methods are available to all internal bitflags
+/// fields if you want to add custom functionality to your bitflags types.
+///
+/// Note that this struct is just for documentation purposes only, it must not be used outside
+/// this crate.
+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
+#[repr(transparent)]
+pub struct FlagsField {
+    bits: u32,
+}
+
+__impl_internal_bitflags! {
+    FlagsField: u32 {
+        A;
+        B;
+        C;
+        ABC;
+    }
+}
+
+impl crate::__private::InternalFlags for FlagsField {
+    type PublicFlags = Flags;
+}
diff --git a/src/lib.rs b/src/lib.rs
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -21,11 +21,12 @@
 //! use bitflags::bitflags;
 //!
 //! bitflags! {
+//!     #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
 //!     struct Flags: u32 {
 //!         const A = 0b00000001;
 //!         const B = 0b00000010;
 //!         const C = 0b00000100;
-//!         const ABC = Self::A.bits | Self::B.bits | Self::C.bits;
+//!         const ABC = Self::A.bits() | Self::B.bits() | Self::C.bits();
 //!     }
 //! }
 //!
diff --git a/src/lib.rs b/src/lib.rs
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -51,6 +52,7 @@
 //! use bitflags::bitflags;
 //!
 //! bitflags! {
+//!     #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
 //!     struct Flags: u32 {
 //!         const A = 0b00000001;
 //!         const B = 0b00000010;
diff --git a/src/lib.rs b/src/lib.rs
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -59,14 +61,7 @@
 //!
 //! impl Flags {
 //!     pub fn clear(&mut self) {
-//!         self.bits = 0;  // The `bits` field can be accessed from within the
-//!                         // same module where the `bitflags!` macro was invoked.
-//!     }
-//! }
-//!
-//! impl fmt::Display for Flags {
-//!     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
-//!         write!(f, "hi!")
+//!         *self.0.bits_mut() = 0;
 //!     }
 //! }
 //!
diff --git a/src/lib.rs b/src/lib.rs
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -74,9 +69,8 @@
 //!     let mut flags = Flags::A | Flags::B;
 //!     flags.clear();
 //!     assert!(flags.is_empty());
-//!     assert_eq!(format!("{}", flags), "hi!");
-//!     assert_eq!(format!("{:?}", Flags::A | Flags::B), "A | B");
-//!     assert_eq!(format!("{:?}", Flags::B), "B");
+//!     assert_eq!(format!("{:?}", Flags::A | Flags::B), "Flags(A | B)");
+//!     assert_eq!(format!("{:?}", Flags::B), "Flags(B)");
 //! }
 //! ```
 //!
diff --git a/src/lib.rs b/src/lib.rs
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -91,10 +85,12 @@
 //!     use bitflags::bitflags;
 //!
 //!     bitflags! {
+//!         #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
 //!         pub struct Flags1: u32 {
 //!             const A = 0b00000001;
 //!         }
 //!
+//!         #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
 //! #       pub
 //!         struct Flags2: u32 {
 //!             const B = 0b00000010;
diff --git a/src/lib.rs b/src/lib.rs
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -123,6 +119,7 @@
 //!
 //! bitflags! {
 //!     #[repr(transparent)]
+//!     #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
 //!     struct Flags: u32 {
 //!         const A = 0b00000001;
 //!         const B = 0b00000010;
diff --git a/src/lib.rs b/src/lib.rs
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -133,13 +130,8 @@
 //!
 //! # Trait implementations
 //!
-//! The `Copy`, `Clone`, `PartialEq`, `Eq`, `PartialOrd`, `Ord` and `Hash`
-//! traits are automatically derived for the `struct`s using the `derive` attribute.
-//! Additional traits can be derived by providing an explicit `derive`
-//! attribute on `struct`.
-//!
-//! The `Extend` and `FromIterator` traits are implemented for the `struct`s,
-//! too: `Extend` adds the union of the instances of the `struct` iterated over,
+//! The `Extend` and `FromIterator` traits are implemented for the `struct`s.
+//! `Extend` adds the union of the instances of the `struct` iterated over,
 //! while `FromIterator` calculates the union.
 //!
 //! The `Binary`, `Debug`, `LowerHex`, `Octal` and `UpperHex` traits are also
diff --git a/src/lib.rs b/src/lib.rs
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -167,7 +159,7 @@
 //!                defined flag
 //! - `from_bits_truncate`: convert from underlying bit representation, dropping
 //!                         any bits that do not correspond to defined flags
-//! - `from_bits_unchecked`: convert from underlying bit representation, keeping
+//! - `from_bits_retain`: convert from underlying bit representation, keeping
 //!                          all bits (even those not corresponding to defined
 //!                          flags)
 //! - `is_empty`: `true` if no flags are currently stored
diff --git a/src/lib.rs b/src/lib.rs
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -204,7 +196,7 @@
 //!
 //! bitflags! {
 //!     // Results in default value with bits: 0
-//!     #[derive(Default)]
+//!     #[derive(Default, Clone, Copy, Debug, PartialEq, Eq, Hash)]
 //!     struct Flags: u32 {
 //!         const A = 0b00000001;
 //!         const B = 0b00000010;
diff --git a/src/lib.rs b/src/lib.rs
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -224,6 +216,7 @@
 //! use bitflags::bitflags;
 //!
 //! bitflags! {
+//!     #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
 //!     struct Flags: u32 {
 //!         const A = 0b00000001;
 //!         const B = 0b00000010;
diff --git a/src/lib.rs b/src/lib.rs
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -252,6 +245,7 @@
 //! use bitflags::bitflags;
 //!
 //! bitflags! {
+//!     #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
 //!     struct Flags: u32 {
 //!         const NONE = 0b00000000;
 //!         const SOME = 0b00000001;
diff --git a/src/lib.rs b/src/lib.rs
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -285,10 +279,62 @@ mod bitflags_trait;
 
 #[doc(hidden)]
 pub mod __private {
-    pub use crate::bitflags_trait::{Bits, ImplementedByBitFlagsMacro};
+    pub use crate::bitflags_trait::{Bits, ImplementedByBitFlagsMacro, InternalFlags, PublicFlags};
     pub use core;
+
+    #[cfg(feature = "serde")]
+    pub use serde;
 }
 
+/*
+How does the bitflags crate work?
+
+This library generates `struct`s in the end-user's crate with a bunch of constants on it that represent flags.
+The difference between `bitflags` and a lot of other libraries is that we don't actually control the generated `struct` in the end.
+It's part of the end-user's crate, so it belongs to them. That makes it difficult to extend `bitflags` with new functionality
+because we could end up breaking valid code that was already written.
+
+Our solution is to split the type we generate into two: the public struct owned by the end-user, and an internal struct owned by `bitflags` (us).
+To give you an example, let's say we had a crate that called `bitflags!`:
+
+```rust
+bitflags! {
+    pub struct MyFlags: u32 {
+        const A = 1;
+        const B = 2;
+    }
+}
+```
+
+What they'd end up with looks something like this:
+
+```rust
+pub struct MyFlags(<MyFlags as PublicFlags>::InternalFlags);
+
+const _: () = {
+    #[repr(transparent)]
+    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
+    pub struct MyInternalFlags {
+        bits: u32,
+    }
+
+    impl PublicFlags for MyFlags {
+        type InternalFlags = InternalFlags;
+    }
+
+    impl InternalFlags for MyInternalFlags {
+        type PublicFlags = MyFlags;
+    }
+};
+```
+
+If we want to expose something like a new trait impl for generated flags types, we add it to our generated `MyInternalFlags`,
+and let `#[derive]` on `MyFlags` pick up that implementation, if an end-user chooses to add one.
+
+The public API is generated in the `__impl_bitflags_public!` macro, and the internal API is generated in
+the `__impl_bitflags_internal!` macro.
+*/
+
 /// The macro used to generate the flag structure.
 ///
 /// See the [crate level docs](../bitflags/index.html) for complete documentation.
diff --git a/src/lib.rs b/src/lib.rs
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -299,11 +345,12 @@ pub mod __private {
 /// use bitflags::bitflags;
 ///
 /// bitflags! {
+///     #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
 ///     struct Flags: u32 {
 ///         const A = 0b00000001;
 ///         const B = 0b00000010;
 ///         const C = 0b00000100;
-///         const ABC = Self::A.bits | Self::B.bits | Self::C.bits;
+///         const ABC = Self::A.bits() | Self::B.bits() | Self::C.bits();
 ///     }
 /// }
 ///
diff --git a/src/lib.rs b/src/lib.rs
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -326,6 +373,7 @@ pub mod __private {
 /// use bitflags::bitflags;
 ///
 /// bitflags! {
+///     #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
 ///     struct Flags: u32 {
 ///         const A = 0b00000001;
 ///         const B = 0b00000010;
diff --git a/src/lib.rs b/src/lib.rs
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -334,14 +382,7 @@ pub mod __private {
 ///
 /// impl Flags {
 ///     pub fn clear(&mut self) {
-///         self.bits = 0;  // The `bits` field can be accessed from within the
-///                         // same module where the `bitflags!` macro was invoked.
-///     }
-/// }
-///
-/// impl fmt::Display for Flags {
-///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
-///         write!(f, "hi!")
+///         *self.0.bits_mut() = 0;
 ///     }
 /// }
 ///
diff --git a/src/lib.rs b/src/lib.rs
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -349,9 +390,8 @@ pub mod __private {
 ///     let mut flags = Flags::A | Flags::B;
 ///     flags.clear();
 ///     assert!(flags.is_empty());
-///     assert_eq!(format!("{}", flags), "hi!");
-///     assert_eq!(format!("{:?}", Flags::A | Flags::B), "A | B");
-///     assert_eq!(format!("{:?}", Flags::B), "B");
+///     assert_eq!(format!("{:?}", Flags::A | Flags::B), "Flags(A | B)");
+///     assert_eq!(format!("{:?}", Flags::B), "Flags(B)");
 /// }
 /// ```
 #[macro_export(local_inner_macros)]
diff --git a/src/lib.rs b/src/lib.rs
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -368,12 +408,9 @@ macro_rules! bitflags {
         $($t:tt)*
     ) => {
         $(#[$outer])*
-        #[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]
-        $vis struct $BitFlags {
-            bits: $T,
-        }
+        $vis struct $BitFlags(<$BitFlags as $crate::__private::PublicFlags>::InternalFlags);
 
-        __impl_bitflags! {
+        __impl_public_bitflags! {
             $BitFlags: $T {
                 $(
                     $(#[$inner $($args)*])*
diff --git a/src/lib.rs b/src/lib.rs
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -382,6 +419,31 @@ macro_rules! bitflags {
             }
         }
 
+        const _: () = {
+            #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
+            #[repr(transparent)]
+            $vis struct InternalFlags {
+                bits: $T,
+            }
+
+            __impl_internal_bitflags! {
+                InternalFlags: $T {
+                    $(
+                        $(#[$inner $($args)*])*
+                        $Flag;
+                    )*
+                }
+            }
+
+            impl $crate::__private::InternalFlags for InternalFlags {
+                type PublicFlags = $BitFlags;
+            }
+
+            impl $crate::__private::PublicFlags for $BitFlags {
+                type InternalFlags = InternalFlags;
+            }
+        };
+
         bitflags! {
             $($t)*
         }
diff --git a/src/lib.rs b/src/lib.rs
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -389,70 +451,42 @@ macro_rules! bitflags {
     () => {};
 }
 
+/// Implement functions on the public (user-facing) bitflags type.
+///
+/// We need to be careful about adding new methods and trait implementations here because they
+/// could conflict with items added by the end-user.
 #[macro_export(local_inner_macros)]
 #[doc(hidden)]
-macro_rules! __impl_bitflags {
+macro_rules! __impl_public_bitflags {
     (
-        $BitFlags:ident: $T:ty {
+        $PublicBitFlags:ident: $T:ty {
             $(
                 $(#[$attr:ident $($args:tt)*])*
                 $Flag:ident = $value:expr;
             )*
         }
     ) => {
-        impl $crate::__private::core::fmt::Debug for $BitFlags {
+        impl $crate::__private::core::fmt::Binary for $PublicBitFlags {
             fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {
-                // Iterate over the valid flags
-                let mut first = true;
-                for (name, _) in self.iter() {
-                    if !first {
-                        f.write_str(" | ")?;
-                    }
-
-                    first = false;
-                    f.write_str(name)?;
-                }
-
-                // Append any extra bits that correspond to flags to the end of the format
-                let extra_bits = self.bits & !Self::all().bits();
-
-                if extra_bits != <$T as $crate::__private::Bits>::EMPTY {
-                    if !first {
-                        f.write_str(" | ")?;
-                    }
-                    first = false;
-                    $crate::__private::core::write!(f, "{:#x}", extra_bits)?;
-                }
-
-                if first {
-                    f.write_str("(empty)")?;
-                }
-
-                $crate::__private::core::fmt::Result::Ok(())
-            }
-        }
-
-        impl $crate::__private::core::fmt::Binary for $BitFlags {
-            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {
-                $crate::__private::core::fmt::Binary::fmt(&self.bits, f)
+                $crate::__private::core::fmt::Binary::fmt(&self.0, f)
             }
         }
 
-        impl $crate::__private::core::fmt::Octal for $BitFlags {
+        impl $crate::__private::core::fmt::Octal for $PublicBitFlags {
             fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {
-                $crate::__private::core::fmt::Octal::fmt(&self.bits, f)
+                $crate::__private::core::fmt::Octal::fmt(&self.0, f)
             }
         }
 
-        impl $crate::__private::core::fmt::LowerHex for $BitFlags {
+        impl $crate::__private::core::fmt::LowerHex for $PublicBitFlags {
             fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {
-                $crate::__private::core::fmt::LowerHex::fmt(&self.bits, f)
+                $crate::__private::core::fmt::LowerHex::fmt(&self.0, f)
             }
         }
 
-        impl $crate::__private::core::fmt::UpperHex for $BitFlags {
+        impl $crate::__private::core::fmt::UpperHex for $PublicBitFlags {
             fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {
-                $crate::__private::core::fmt::UpperHex::fmt(&self.bits, f)
+                $crate::__private::core::fmt::UpperHex::fmt(&self.0, f)
             }
         }
 
diff --git a/src/lib.rs b/src/lib.rs
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -464,40 +498,37 @@ macro_rules! __impl_bitflags {
             unused_mut,
             non_upper_case_globals
         )]
-        impl $BitFlags {
+        impl $PublicBitFlags {
             $(
                 $(#[$attr $($args)*])*
-                pub const $Flag: Self = Self { bits: $value };
+                pub const $Flag: Self = Self::from_bits_retain($value);
             )*
 
             /// Returns an empty set of flags.
             #[inline]
             pub const fn empty() -> Self {
-                Self { bits: <$T as $crate::__private::Bits>::EMPTY }
+                Self(<$PublicBitFlags as $crate::__private::PublicFlags>::InternalFlags::empty())
             }
 
             /// Returns the set containing all flags.
             #[inline]
             pub const fn all() -> Self {
-                Self::from_bits_truncate(<$T as $crate::__private::Bits>::ALL)
+                Self(<$PublicBitFlags as $crate::__private::PublicFlags>::InternalFlags::all())
             }
 
             /// Returns the raw value of the flags currently stored.
             #[inline]
             pub const fn bits(&self) -> $T {
-                self.bits
+                self.0.bits()
             }
 
             /// Convert from underlying bit representation, unless that
             /// representation contains bits that do not correspond to a flag.
             #[inline]
             pub const fn from_bits(bits: $T) -> $crate::__private::core::option::Option<Self> {
-                let truncated = Self::from_bits_truncate(bits).bits;
-
-                if truncated == bits {
-                    $crate::__private::core::option::Option::Some(Self { bits })
-                } else {
-                    $crate::__private::core::option::Option::None
+                match <$PublicBitFlags as $crate::__private::PublicFlags>::InternalFlags::from_bits(bits) {
+                    $crate::__private::core::option::Option::Some(bits) => $crate::__private::core::option::Option::Some(Self(bits)),
+                    $crate::__private::core::option::Option::None => $crate::__private::core::option::Option::None,
                 }
             }
 
diff --git a/src/lib.rs b/src/lib.rs
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -505,20 +536,7 @@ macro_rules! __impl_bitflags {
             /// that do not correspond to flags.
             #[inline]
             pub const fn from_bits_truncate(bits: $T) -> Self {
-                if bits == <$T as $crate::__private::Bits>::EMPTY {
-                    return Self { bits }
-                }
-
-                let mut truncated = <$T as $crate::__private::Bits>::EMPTY;
-
-                $(
-                    $(#[$attr $($args)*])*
-                    if bits & Self::$Flag.bits == Self::$Flag.bits {
-                        truncated |= Self::$Flag.bits
-                    }
-                )*
-
-                Self { bits: truncated }
+                Self(<$PublicBitFlags as $crate::__private::PublicFlags>::InternalFlags::from_bits_truncate(bits))
             }
 
             /// Convert from underlying bit representation, preserving all
diff --git a/src/lib.rs b/src/lib.rs
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -529,64 +547,60 @@ macro_rules! __impl_bitflags {
             /// The caller of the `bitflags!` macro can choose to allow or
             /// disallow extra bits for their bitflags type.
             ///
-            /// The caller of `from_bits_unchecked()` has to ensure that
+            /// The caller of `from_bits_retain()` has to ensure that
             /// all bits correspond to a defined flag or that extra bits
             /// are valid for this bitflags type.
             #[inline]
-            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {
-                Self { bits }
+            pub const fn from_bits_retain(bits: $T) -> Self {
+                Self(<$PublicBitFlags as $crate::__private::PublicFlags>::InternalFlags::from_bits_retain(bits))
             }
 
             /// Returns `true` if no flags are currently stored.
             #[inline]
             pub const fn is_empty(&self) -> bool {
-                self.bits() == Self::empty().bits()
+                self.0.is_empty()
             }
 
             /// Returns `true` if all flags are currently set.
             #[inline]
             pub const fn is_all(&self) -> bool {
-                Self::all().bits | self.bits == self.bits
+                self.0.is_all()
             }
 
             /// Returns `true` if there are flags common to both `self` and `other`.
             #[inline]
             pub const fn intersects(&self, other: Self) -> bool {
-                !(Self { bits: self.bits & other.bits}).is_empty()
+                self.0.intersects(other.0)
             }
 
             /// Returns `true` if all of the flags in `other` are contained within `self`.
             #[inline]
             pub const fn contains(&self, other: Self) -> bool {
-                (self.bits & other.bits) == other.bits
+                self.0.contains(other.0)
             }
 
             /// Inserts the specified flags in-place.
             #[inline]
             pub fn insert(&mut self, other: Self) {
-                self.bits |= other.bits;
+                self.0.insert(other.0)
             }
 
             /// Removes the specified flags in-place.
             #[inline]
             pub fn remove(&mut self, other: Self) {
-                self.bits &= !other.bits;
+                self.0.remove(other.0)
             }
 
             /// Toggles the specified flags in-place.
             #[inline]
             pub fn toggle(&mut self, other: Self) {
-                self.bits ^= other.bits;
+                self.0.toggle(other.0)
             }
 
             /// Inserts or removes the specified flags depending on the passed value.
             #[inline]
             pub fn set(&mut self, other: Self, value: bool) {
-                if value {
-                    self.insert(other);
-                } else {
-                    self.remove(other);
-                }
+                self.0.set(other.0, value)
             }
 
             /// Returns the intersection between the flags in `self` and
diff --git a/src/lib.rs b/src/lib.rs
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -602,7 +616,7 @@ macro_rules! __impl_bitflags {
             #[inline]
             #[must_use]
             pub const fn intersection(self, other: Self) -> Self {
-                Self { bits: self.bits & other.bits }
+                Self(self.0.intersection(other.0))
             }
 
             /// Returns the union of between the flags in `self` and `other`.
diff --git a/src/lib.rs b/src/lib.rs
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -619,7 +633,7 @@ macro_rules! __impl_bitflags {
             #[inline]
             #[must_use]
             pub const fn union(self, other: Self) -> Self {
-                Self { bits: self.bits | other.bits }
+                Self(self.0.union(other.0))
             }
 
             /// Returns the difference between the flags in `self` and `other`.
diff --git a/src/lib.rs b/src/lib.rs
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -637,7 +651,7 @@ macro_rules! __impl_bitflags {
             #[inline]
             #[must_use]
             pub const fn difference(self, other: Self) -> Self {
-                Self { bits: self.bits & !other.bits }
+                Self(self.0.difference(other.0))
             }
 
             /// Returns the [symmetric difference][sym-diff] between the flags
diff --git a/src/lib.rs b/src/lib.rs
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -656,7 +670,7 @@ macro_rules! __impl_bitflags {
             #[inline]
             #[must_use]
             pub const fn symmetric_difference(self, other: Self) -> Self {
-                Self { bits: self.bits ^ other.bits }
+                Self(self.0.symmetric_difference(other.0))
             }
 
             /// Returns the complement of this set of flags.
diff --git a/src/lib.rs b/src/lib.rs
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -675,159 +689,101 @@ macro_rules! __impl_bitflags {
             #[inline]
             #[must_use]
             pub const fn complement(self) -> Self {
-                Self::from_bits_truncate(!self.bits)
+                Self(self.0.complement())
             }
 
             /// Returns an iterator over set flags and their names.
             pub fn iter(self) -> impl $crate::__private::core::iter::Iterator<Item = (&'static str, Self)> {
                 use $crate::__private::core::iter::Iterator as _;
 
-                const NUM_FLAGS: usize = {
-                    let mut num_flags = 0;
-
-                    $(
-                        $(#[$attr $($args)*])*
-                        {
-                            num_flags += 1;
-                        }
-                    )*
-
-                    num_flags
-                };
-
-                const OPTIONS: [$BitFlags; NUM_FLAGS] = [
-                    $(
-                        $(#[$attr $($args)*])*
-                        $BitFlags::$Flag,
-                    )*
-                ];
-
-                const OPTIONS_NAMES: [&'static str; NUM_FLAGS] = [
-                    $(
-                        $(#[$attr $($args)*])*
-                        $crate::__private::core::stringify!($Flag),
-                    )*
-                ];
-
-                let mut start = 0;
-                let mut state = self;
-
-                $crate::__private::core::iter::from_fn(move || {
-                    if state.is_empty() || NUM_FLAGS == 0 {
-                        $crate::__private::core::option::Option::None
-                    } else {
-                        for (flag, flag_name) in OPTIONS[start..NUM_FLAGS].iter().copied()
-                            .zip(OPTIONS_NAMES[start..NUM_FLAGS].iter().copied())
-                        {
-                            start += 1;
-
-                            // NOTE: We check whether the flag exists in self, but remove it from
-                            // a different value. This ensure that overlapping flags are handled
-                            // properly. Take the following example:
-                            //
-                            // const A: 0b00000001;
-                            // const B: 0b00000101;
-                            //
-                            // Given the bits 0b00000101, both A and B are set. But if we removed A
-                            // as we encountered it we'd be left with 0b00000100, which doesn't
-                            // correspond to a valid flag on its own.
-                            if self.contains(flag) {
-                                state.remove(flag);
-
-                                return $crate::__private::core::option::Option::Some((flag_name, flag))
-                            }
-                        }
-
-                        $crate::__private::core::option::Option::None
-                    }
-                })
+                self.0.iter().map(|(name, bits)| (name, Self::from_bits_retain(bits)))
             }
 
         }
 
-        impl $crate::__private::core::ops::BitOr for $BitFlags {
+        impl $crate::__private::core::ops::BitOr for $PublicBitFlags {
             type Output = Self;
 
             /// Returns the union of the two sets of flags.
             #[inline]
-            fn bitor(self, other: $BitFlags) -> Self {
-                Self { bits: self.bits | other.bits }
+            fn bitor(self, other: $PublicBitFlags) -> Self {
+                self.union(other)
             }
         }
 
-        impl $crate::__private::core::ops::BitOrAssign for $BitFlags {
+        impl $crate::__private::core::ops::BitOrAssign for $PublicBitFlags {
             /// Adds the set of flags.
             #[inline]
             fn bitor_assign(&mut self, other: Self) {
-                self.bits |= other.bits;
+                self.0 = self.0.union(other.0);
             }
         }
 
-        impl $crate::__private::core::ops::BitXor for $BitFlags {
+        impl $crate::__private::core::ops::BitXor for $PublicBitFlags {
             type Output = Self;
 
             /// Returns the left flags, but with all the right flags toggled.
             #[inline]
             fn bitxor(self, other: Self) -> Self {
-                Self { bits: self.bits ^ other.bits }
+                self.symmetric_difference(other)
             }
         }
 
-        impl $crate::__private::core::ops::BitXorAssign for $BitFlags {
+        impl $crate::__private::core::ops::BitXorAssign for $PublicBitFlags {
             /// Toggles the set of flags.
             #[inline]
             fn bitxor_assign(&mut self, other: Self) {
-                self.bits ^= other.bits;
+                self.0 = self.0.symmetric_difference(other.0);
             }
         }
 
-        impl $crate::__private::core::ops::BitAnd for $BitFlags {
+        impl $crate::__private::core::ops::BitAnd for $PublicBitFlags {
             type Output = Self;
 
             /// Returns the intersection between the two sets of flags.
             #[inline]
             fn bitand(self, other: Self) -> Self {
-                Self { bits: self.bits & other.bits }
+                self.intersection(other)
             }
         }
 
-        impl $crate::__private::core::ops::BitAndAssign for $BitFlags {
+        impl $crate::__private::core::ops::BitAndAssign for $PublicBitFlags {
             /// Disables all flags disabled in the set.
             #[inline]
             fn bitand_assign(&mut self, other: Self) {
-                self.bits &= other.bits;
+                self.0 = self.0.intersection(other.0);
             }
         }
 
-        impl $crate::__private::core::ops::Sub for $BitFlags {
+        impl $crate::__private::core::ops::Sub for $PublicBitFlags {
             type Output = Self;
 
             /// Returns the set difference of the two sets of flags.
             #[inline]
             fn sub(self, other: Self) -> Self {
-                Self { bits: self.bits & !other.bits }
+                self.difference(other)
             }
         }
 
-        impl $crate::__private::core::ops::SubAssign for $BitFlags {
+        impl $crate::__private::core::ops::SubAssign for $PublicBitFlags {
             /// Disables all flags enabled in the set.
             #[inline]
             fn sub_assign(&mut self, other: Self) {
-                self.bits &= !other.bits;
+                self.0 = self.0.difference(other.0);
             }
         }
 
-        impl $crate::__private::core::ops::Not for $BitFlags {
+        impl $crate::__private::core::ops::Not for $PublicBitFlags {
             type Output = Self;
 
             /// Returns the complement of this set of flags.
             #[inline]
             fn not(self) -> Self {
-                Self { bits: !self.bits } & Self::all()
+                self.complement()
             }
         }
 
-        impl $crate::__private::core::iter::Extend<$BitFlags> for $BitFlags {
+        impl $crate::__private::core::iter::Extend<$PublicBitFlags> for $PublicBitFlags {
             fn extend<T: $crate::__private::core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {
                 for item in iterator {
                     self.insert(item)
diff --git a/src/lib.rs b/src/lib.rs
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -835,7 +791,7 @@ macro_rules! __impl_bitflags {
             }
         }
 
-        impl $crate::__private::core::iter::FromIterator<$BitFlags> for $BitFlags {
+        impl $crate::__private::core::iter::FromIterator<$PublicBitFlags> for $PublicBitFlags {
             fn from_iter<T: $crate::__private::core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {
                 use $crate::__private::core::iter::Extend;
 
