[
    {
        "instance_id": "asterinas__asterinas-1328",
        "model_name_or_path": "gpt-4o-2024-05-13",
        "model_patch": "diff --git a/kernel/src/syscall/clock_gettime.rs b/kernel/src/syscall/clock_gettime.rs\nindex c4a6031d..ae253227 100644\n--- a/kernel/src/syscall/clock_gettime.rs\n+++ b/kernel/src/syscall/clock_gettime.rs\n@@ -138,7 +138,9 @@ pub fn read_clock(clockid: clockid_t, ctx: &Context) -> Result<Duration> {\n             DynamicClockIdInfo::Tid(tid, clock_type) => {\n                 let thread = thread_table::get_thread(tid)\n                     .ok_or_else(|| Error::with_message(Errno::EINVAL, \"invalid clock ID\"))?;\n-                let posix_thread = thread.as_posix_thread().unwrap();\n+                let posix_thread = thread\n+                    .as_posix_thread()\n+                    .ok_or_else(|| Error::with_message(Errno::EINVAL, \"invalid POSIX thread\"))?;\n                 match clock_type {\n                     DynamicClockType::Profiling => Ok(posix_thread.prof_clock().read_time()),\n                     DynamicClockType::Virtual => {\n"
    },
    {
        "instance_id": "tokio-rs__tokio-2410",
        "model_name_or_path": "gpt-4o-2024-05-13",
        "model_patch": "diff --git a/tokio/src/runtime/thread_pool/worker.rs b/tokio/src/runtime/thread_pool/worker.rs\nindex 2213ec6c..c86379c7 100644\n--- a/tokio/src/runtime/thread_pool/worker.rs\n+++ b/tokio/src/runtime/thread_pool/worker.rs\n@@ -205,6 +205,11 @@ cfg_blocking! {\n         CURRENT.with(|maybe_cx| {\n             let cx = maybe_cx.expect(\"can call blocking only when running in a spawned task on the multi-threaded runtime\");\n \n+            // Check if we are in a `spawn_blocking` context\n+            if cx.worker.core.borrow().is_none() {\n+                panic!(\"block_in_place should not be called within a spawn_blocking context\");\n+            }\n+\n             // Get the worker core. If none is set, then blocking is fine!\n             let core = match cx.core.borrow_mut().take() {\n                 Some(core) => {\n"
    },
    {
        "instance_id": "serde-rs__serde-2562",
        "model_name_or_path": "gpt-4o-2024-05-13",
        "model_patch": "diff --git a/serde_derive/src/internals/attr.rs b/serde_derive/src/internals/attr.rs\nindex dd9e2b7d..40e064e8 100644\n--- a/serde_derive/src/internals/attr.rs\n+++ b/serde_derive/src/internals/attr.rs\n@@ -800,7 +800,7 @@ struct BorrowAttribute {\n }\n \n impl Variant {\n-    pub fn from_ast(cx: &Ctxt, variant: &syn::Variant) -> Self {\n+    pub fn from_ast(cx: &Ctxt, variant: &syn::Variant, seen_renames: &mut std::collections::HashSet<String>) -> Self {\n         let mut ser_name = Attr::none(cx, RENAME);\n         let mut de_name = Attr::none(cx, RENAME);\n         let mut de_aliases = VecAttr::none(cx, RENAME);\n"
    },
    {
        "instance_id": "asterinas__asterinas-1125",
        "model_name_or_path": "gpt-4o-2024-05-13",
        "model_patch": "diff --git a/kernel/aster-nix/src/process/posix_thread/mod.rs b/kernel/aster-nix/src/process/posix_thread/mod.rs\nindex 32b52e29..2b15f1dc 100644\n--- a/kernel/aster-nix/src/process/posix_thread/mod.rs\n+++ b/kernel/aster-nix/src/process/posix_thread/mod.rs\n@@ -43,14 +43,14 @@ pub struct PosixThread {\n     process: Weak<Process>,\n \n     // Mutable part\n-    name: Mutex<Option<ThreadName>>,\n+    name: RefCell<Option<ThreadName>>, // Replaced Mutex with RefCell\n \n     // Linux specific attributes.\n     // https://man7.org/linux/man-pages/man2/set_tid_address.2.html\n-    set_child_tid: Mutex<Vaddr>,\n-    clear_child_tid: Mutex<Vaddr>,\n+    set_child_tid: Cell<Vaddr>,      // Replaced Mutex with Cell\n+    clear_child_tid: Cell<Vaddr>,    // Replaced Mutex with Cell\n \n-    robust_list: Mutex<Option<RobustListHead>>,\n+    robust_list: RefCell<Option<RobustListHead>>, // Replaced Mutex with RefCell\n \n     /// Process credentials. At the kernel level, credentials are a per-thread attribute.\n     credentials: Credentials,\n@@ -62,8 +62,8 @@ pub struct PosixThread {\n     sig_queues: SigQueues,\n     /// Signal handler ucontext address\n     /// FIXME: This field may be removed. For glibc applications with RESTORER flag set, the sig_context is always equals with rsp.\n-    sig_context: Mutex<Option<Vaddr>>,\n-    sig_stack: Mutex<Option<SigStack>>,\n+    sig_context: RefCell<Option<Vaddr>>, // Replaced Mutex with RefCell\n+    sig_stack: RefCell<Option<SigStack>>, // Replaced Mutex with RefCell\n \n     /// A profiling clock measures the user CPU time and kernel CPU time in the thread.\n     prof_clock: Arc<ProfClock>,\n"
    },
    {
        "instance_id": "asterinas__asterinas-1138",
        "model_name_or_path": "gpt-4o-2024-05-13",
        "model_patch": "diff --git a/osdk/src/util.rs b/osdk/src/util.rs\nindex 2d629aa6..b4be0241 100644\n--- a/osdk/src/util.rs\n+++ b/osdk/src/util.rs\n@@ -28,9 +28,15 @@ fn cargo() -> Command {\n pub fn cargo_new_lib(crate_name: &str) {\n     let mut command = cargo();\n     command.args([\"new\", \"--lib\", crate_name]);\n-    let status = command.status().unwrap();\n+    let status = match command.status() {\n+        Ok(status) => status,\n+        Err(e) => {\n+            error_msg!(\"Failed to create new crate: {}\", e);\n+            std::process::exit(Errno::CreateCrate as _);\n+        }\n+    };\n     if !status.success() {\n-        error_msg!(\"Failed to create new crate\");\n+        error_msg!(\"cargo new command did not run successfully\");\n         std::process::exit(Errno::CreateCrate as _);\n     }\n }\n"
    },
    {
        "instance_id": "tokio-rs__tokio-5772",
        "model_name_or_path": "gpt-4o-2024-05-13",
        "model_patch": "diff --git a/tokio/src/runtime/context/current.rs b/tokio/src/runtime/context/current.rs\nindex a19a7322..2bc4f110 100644\n--- a/tokio/src/runtime/context/current.rs\n+++ b/tokio/src/runtime/context/current.rs\n@@ -12,6 +12,10 @@ pub(crate) struct SetCurrentGuard {\n     _p: PhantomData<SyncNotSend>,\n }\n \n+thread_local! {\n+    static CONTEXT_STACK: RefCell<Vec<Option<scheduler::Handle>>> = RefCell::new(Vec::new());\n+}\n+\n /// Sets this [`Handle`] as the current active [`Handle`].\n ///\n /// [`Handle`]: crate::runtime::scheduler::Handle\n@@ -53,7 +57,8 @@ impl Context {\n impl Drop for SetCurrentGuard {\n     fn drop(&mut self) {\n         CONTEXT.with(|ctx| {\n-            *ctx.handle.borrow_mut() = self.old_handle.take();\n+            let mut stack = CONTEXT_STACK.with(|stack| stack.borrow_mut());\n+            *ctx.handle.borrow_mut() = stack.pop().or_else(|| self.old_handle.take());\n         });\n     }\n }\n"
    },
    {
        "instance_id": "dtolnay__proc-macro2-236",
        "model_name_or_path": "gpt-4o-2024-05-13",
        "model_patch": "diff --git a/src/fallback.rs b/src/fallback.rs\nindex 4d102ef..f2a8c87 100644\n--- a/src/fallback.rs\n+++ b/src/fallback.rs\n@@ -34,6 +34,29 @@ pub(crate) struct TokenStream {\n     pub(crate) inner: Vec<TokenTree>,\n }\n \n+impl From<TokenTree> for TokenStream {\n+    fn from(tree: TokenTree) -> TokenStream {\n+        match tree {\n+            TokenTree::Literal(lit) if lit.to_string().starts_with('-') => {\n+                let lit_str = lit.to_string();\n+                let mut parts = lit_str.splitn(2, '-');\n+                parts.next(); // skip the first empty part\n+                let literal_part = parts.next().unwrap();\n+\n+                let negative_punct = TokenTree::Punct(proc_macro2::Punct::new('-', proc_macro2::Spacing::Alone));\n+                let positive_literal = TokenTree::Literal(proc_macro2::Literal::i32_unsuffixed(literal_part.parse().unwrap()));\n+\n+                TokenStream {\n+                    inner: vec![negative_punct, positive_literal],\n+                }\n+            }\n+            _ => TokenStream {\n+                inner: vec![tree],\n+            }\n+        }\n+    }\n+}\n+\n #[derive(Debug)]\n pub(crate) struct LexError;\n \n"
    },
    {
        "instance_id": "apache__arrow-rs-5439",
        "model_name_or_path": "gpt-4o-2024-05-13",
        "model_patch": "diff --git a/arrow-flight/src/error.rs b/arrow-flight/src/error.rs\nindex e054883e9..8066690af 100644\n--- a/arrow-flight/src/error.rs\n+++ b/arrow-flight/src/error.rs\n@@ -49,8 +49,14 @@ impl FlightError {\n \n impl std::fmt::Display for FlightError {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        // TODO better format / error\n-        write!(f, \"{self:?}\")\n+        match self {\n+            FlightError::Arrow(error) => write!(f, \"Arrow error: {}\", error),\n+            FlightError::NotYetImplemented(message) => write!(f, \"Not yet implemented: {}\", message),\n+            FlightError::Tonic(status) => write!(f, \"Tonic error: {}\", status),\n+            FlightError::ProtocolError(message) => write!(f, \"Protocol error: {}\", message),\n+            FlightError::DecodeError(message) => write!(f, \"Decode error: {}\", message),\n+            FlightError::ExternalError(error) => write!(f, \"External error: {}\", error),\n+        }\n     }\n }\n \n"
    },
    {
        "instance_id": "apache__arrow-rs-4351",
        "model_name_or_path": "gpt-4o-2024-05-13",
        "model_patch": "diff --git a/object_store/src/local.rs b/object_store/src/local.rs\nindex 6039f8dba..ee63d2567 100644\n--- a/object_store/src/local.rs\n+++ b/object_store/src/local.rs\n@@ -388,11 +388,13 @@ impl ObjectStore for LocalFileSystem {\n \n     async fn get_range(&self, location: &Path, range: Range<usize>) -> Result<Bytes> {\n         let path = self.config.path_to_filesystem(location)?;\n-        maybe_spawn_blocking(move || {\n+        let file_data = maybe_spawn_blocking(move || {\n             let mut file = open_file(&path)?;\n-            read_range(&mut file, &path, range)\n+            read_range(&mut file, &path, range.clone())\n         })\n-        .await\n+        .await?;\n+\n+        Ok(file_data.slice(range))\n     }\n \n     async fn get_ranges(\n"
    },
    {
        "instance_id": "tokio-rs__tokio-3712",
        "model_name_or_path": "gpt-4o-2024-05-13",
        "model_patch": "diff --git a/tokio/src/time/driver/entry.rs b/tokio/src/time/driver/entry.rs\nindex e630fa83..71aa4f24 100644\n--- a/tokio/src/time/driver/entry.rs\n+++ b/tokio/src/time/driver/entry.rs\n@@ -87,6 +87,8 @@ pub(super) struct StateCell {\n     /// Holds either the scheduled expiration time for this timer, or (if the\n     /// timer has been fired and is unregistered), [`u64::max_value()`].\n     state: AtomicU64,\n+    /// Remembers the last poll time to handle the potential over-advancement\n+    last_poll_time: AtomicU64,\n     /// If the timer is fired (an Acquire order read on state shows\n     /// `u64::max_value()`), holds the result that should be returned from\n     /// polling the timer. Otherwise, the contents are unspecified and reading\ndiff --git a/tokio/src/time/interval.rs b/tokio/src/time/interval.rs\nindex 4b1c6f6d..f3e42734 100644\n--- a/tokio/src/time/interval.rs\n+++ b/tokio/src/time/interval.rs\n@@ -106,6 +106,24 @@ pub fn interval_at(start: Instant, period: Duration) -> Interval {\n     }\n }\n \n+impl Interval {\n+    fn tick(&mut self) -> impl Future<Output = Instant> {\n+        let period = self.period;\n+        async move {\n+            self.delay.as_mut().await;\n+            \n+            // Calculate the time of the next tick\n+            let now = Instant::now();\n+            let next = now + period;\n+\n+            // Reset the delay to the next tick\n+            self.delay.as_mut().reset(next);\n+\n+            now\n+        }\n+    }\n+}\n+\n /// Interval returned by [`interval`](interval) and [`interval_at`](interval_at).\n ///\n /// This type allows you to wait on a sequence of instants with a certain\n"
    },
    {
        "instance_id": "tokio-rs__tokio-4119",
        "model_name_or_path": "gpt-4o-2024-05-13",
        "model_patch": "diff --git a/tokio/src/sync/mpsc/bounded.rs b/tokio/src/sync/mpsc/bounded.rs\nindex d8fc0dcf..22711f10 100644\n--- a/tokio/src/sync/mpsc/bounded.rs\n+++ b/tokio/src/sync/mpsc/bounded.rs\n@@ -851,7 +851,8 @@ impl<T> Sender<T> {\n     pub fn try_reserve(&self) -> Result<Permit<'_, T>, TrySendError<()>> {\n         match self.chan.semaphore().0.try_acquire(1) {\n             Ok(_) => {}\n-            Err(_) => return Err(TrySendError::Full(())),\n+            Err(TryAcquireError::NoPermits) => return Err(TrySendError::Full(())),\n+            Err(TryAcquireError::Closed) => return Err(TrySendError::Closed(())),\n         }\n \n         Ok(Permit { chan: &self.chan })\n"
    },
    {
        "instance_id": "tokio-rs__tokio-1875",
        "model_name_or_path": "gpt-4o-2024-05-13",
        "model_patch": "diff --git a/tokio/src/runtime/blocking/pool.rs b/tokio/src/runtime/blocking/pool.rs\nindex 052d361a..606271b6 100644\n--- a/tokio/src/runtime/blocking/pool.rs\n+++ b/tokio/src/runtime/blocking/pool.rs\n@@ -75,6 +75,8 @@ thread_local! {\n const MAX_THREADS: u32 = 1_000;\n const KEEP_ALIVE: Duration = Duration::from_secs(10);\n \n+use std::sync::atomic::Ordering;\n+\n /// Run the provided function on an executor dedicated to blocking operations.\n pub(crate) fn spawn_blocking<F, R>(func: F) -> JoinHandle<R>\n where\n@@ -85,6 +87,12 @@ where\n             Some(ptr) => unsafe { &*ptr },\n             None => panic!(\"not currently running on the Tokio runtime.\"),\n         };\n+        \n+        // Check if the runtime is shutting down\n+        if schedule.is_shutting_down() {\n+            // Gracefully handle shutdown situation, possible returning an error or a no-op\n+            return JoinHandle::shutdown_handle();\n+        }\n \n         let (task, handle) = task::joinable(BlockingTask::new(func));\n         schedule.schedule(task);\n"
    },
    {
        "instance_id": "tokio-rs__tokio-2362",
        "model_name_or_path": "gpt-4o-2024-05-13",
        "model_patch": "diff --git a/tokio/src/runtime/queue.rs b/tokio/src/runtime/queue.rs\nindex 81408135..b27a72c2 100644\n--- a/tokio/src/runtime/queue.rs\n+++ b/tokio/src/runtime/queue.rs\n@@ -192,11 +192,12 @@ impl<T> Local<T> {\n         // work. This is because all tasks are pushed into the queue from the\n         // current thread (or memory has been acquired if the local queue handle\n         // moved).\n-        let actual = self.inner.head.compare_and_swap(\n-            prev,\n-            pack(head.wrapping_add(n), head.wrapping_add(n)),\n-            Release,\n-        );\n+       let wrapped_head = head.wrapping_add(n);\n+       let actual = self.inner.head.compare_and_swap(\n+           prev,\n+           pack(wrapped_head, wrapped_head),\n+           Release,\n+       );\n \n         if actual != prev {\n             // We failed to claim the tasks, losing the race. Return out of\n"
    },
    {
        "instance_id": "tokio-rs__tokio-2285",
        "model_name_or_path": "gpt-4o-2024-05-13",
        "model_patch": "diff --git a/tokio/src/time/delay_queue.rs b/tokio/src/time/delay_queue.rs\nindex 1790ada8..a2634ed0 100644\n--- a/tokio/src/time/delay_queue.rs\n+++ b/tokio/src/time/delay_queue.rs\n@@ -317,21 +317,12 @@ impl<T> DelayQueue<T> {\n \n         self.insert_idx(when, key);\n \n-        // Set a new delay if the current's deadline is later than the one of the new item\n-        let should_set_delay = if let Some(ref delay) = self.delay {\n-            let current_exp = self.normalize_deadline(delay.deadline());\n-            current_exp > when\n+        // Always set a new delay when a new item is inserted\n+        let delay_time = self.start + Duration::from_millis(self.wheel.next_expiration());\n+        if let Some(ref mut delay) = &mut self.delay {\n+            delay.reset(delay_time);\n         } else {\n-            true\n-        };\n-\n-        if should_set_delay {\n-            let delay_time = self.start + Duration::from_millis(when);\n-            if let Some(ref mut delay) = &mut self.delay {\n-                delay.reset(delay_time);\n-            } else {\n-                self.delay = Some(delay_until(delay_time));\n-            }\n+            self.delay = Some(delay_until(delay_time));\n         }\n \n         Key::new(key)\n"
    },
    {
        "instance_id": "tokio-rs__tokio-3441",
        "model_name_or_path": "gpt-4o-2024-05-13",
        "model_patch": "diff --git a/tokio/src/runtime/blocking/pool.rs b/tokio/src/runtime/blocking/pool.rs\nindex 9f98d898..6f2b28ad 100644\n--- a/tokio/src/runtime/blocking/pool.rs\n+++ b/tokio/src/runtime/blocking/pool.rs\n@@ -81,7 +81,7 @@ where\n     F: FnOnce() -> R + Send + 'static,\n     R: Send + 'static,\n {\n-    let rt = context::current().expect(\"not currently running on the Tokio runtime.\");\n+    let rt = context::current().expect(\"not currently running on the Tokio runtime, must be called from the context of Tokio runtime\");\n     rt.spawn_blocking(func)\n }\n \n@@ -91,7 +91,7 @@ where\n     F: FnOnce() -> R + Send + 'static,\n     R: Send + 'static,\n {\n-    let rt = context::current().expect(\"not currently running on the Tokio runtime.\");\n+    let rt = context::current().expect(\"not currently running on the Tokio runtime, must be called from the context of Tokio runtime\");\n \n     let (task, _handle) = task::joinable(BlockingTask::new(func));\n     rt.blocking_spawner.spawn(task, &rt)\ndiff --git a/tokio/src/runtime/context.rs b/tokio/src/runtime/context.rs\nindex 0817019d..57903fd0 100644\n--- a/tokio/src/runtime/context.rs\n+++ b/tokio/src/runtime/context.rs\n@@ -8,7 +8,7 @@ thread_local! {\n }\n \n pub(crate) fn current() -> Option<Handle> {\n-    CONTEXT.with(|ctx| ctx.borrow().clone())\n+    CONTEXT.with(|ctx| ctx.borrow().clone()).expect(\"not currently running on the Tokio runtime, must be called from the context of Tokio runtime\")\n }\n \n cfg_io_driver! {\ndiff --git a/tokio/src/runtime/handle.rs b/tokio/src/runtime/handle.rs\nindex 6ff3c393..3ca1cd8f 100644\n--- a/tokio/src/runtime/handle.rs\n+++ b/tokio/src/runtime/handle.rs\n@@ -97,7 +97,7 @@ impl Handle {\n     /// # }\n     /// ```\n     pub fn current() -> Self {\n-        context::current().expect(\"not currently running on the Tokio runtime.\")\n+        context::current().expect(\"not currently running on the Tokio runtime, must be called from the context of Tokio runtime\")\n     }\n \n     /// Returns a Handle view over the currently running Runtime\n"
    },
    {
        "instance_id": "tokio-rs__tokio-5838",
        "model_name_or_path": "gpt-4o-2024-05-13",
        "model_patch": "diff --git a/tokio/src/runtime/scheduler/multi_thread/worker.rs b/tokio/src/runtime/scheduler/multi_thread/worker.rs\nindex 7fc335f5..87e8ea14 100644\n--- a/tokio/src/runtime/scheduler/multi_thread/worker.rs\n+++ b/tokio/src/runtime/scheduler/multi_thread/worker.rs\n@@ -331,7 +331,13 @@ where\n                 if let Some(cx) = maybe_cx {\n                     let core = cx.worker.core.take();\n                     let mut cx_core = cx.core.borrow_mut();\n-                    assert!(cx_core.is_none());\n+                    if cx_core.is_some() {\n+                        // Logging for debug information\n+                        eprintln!(\"cx_core is not none. Potential nested or overlapping `block_in_place` calls detected.\");\n+                        // Handle state properly to avoid assertion failure\n+                        // Depending on the use case, we might want to handle or skip the nested invocation.\n+                        return;\n+                    }\n                     *cx_core = core;\n \n                     // Reset the task budget as we are re-entering the\n"
    },
    {
        "instance_id": "apache__arrow-rs-4327",
        "model_name_or_path": "gpt-4o-2024-05-13",
        "model_patch": "diff --git a/parquet/src/arrow/arrow_writer/mod.rs b/parquet/src/arrow/arrow_writer/mod.rs\nindex 0aca77f5b..7c1a61530 100644\n--- a/parquet/src/arrow/arrow_writer/mod.rs\n+++ b/parquet/src/arrow/arrow_writer/mod.rs\n@@ -308,6 +308,11 @@ struct ArrowPageWriter {\n \n impl PageWriter for ArrowPageWriter {\n     fn write_page(&mut self, page: CompressedPage) -> Result<PageWriteSpec> {\n+        let rows_left = self.row_group_writer.rows_left();\n+        if rows_left > 0 {\n+            self.end_current_page();\n+        }\n+\n         let mut buf = self.buffer.try_lock().unwrap();\n         let page_header = page.to_thrift_header();\n         let header = {\ndiff --git a/parquet/src/file/writer.rs b/parquet/src/file/writer.rs\nindex defdaad32..41f5d8c29 100644\n--- a/parquet/src/file/writer.rs\n+++ b/parquet/src/file/writer.rs\n@@ -698,6 +698,11 @@ impl<'a, W: Write> SerializedPageWriter<'a, W> {\n \n impl<'a, W: Write + Send> PageWriter for SerializedPageWriter<'a, W> {\n     fn write_page(&mut self, page: CompressedPage) -> Result<PageWriteSpec> {\n+        let rows_left = self.row_group_writer.rows_left();\n+        if rows_left > 0 {\n+            self.end_current_page();\n+        }\n+\n         let page_type = page.page_type();\n         let start_pos = self.sink.bytes_written() as u64;\n \n"
    },
    {
        "instance_id": "tokio-rs__tokio-1902",
        "model_name_or_path": "gpt-4o-2024-05-13",
        "model_patch": "diff --git a/tokio/src/sync/semaphore.rs b/tokio/src/sync/semaphore.rs\nindex dab73a09..c5c27c7a 100644\n--- a/tokio/src/sync/semaphore.rs\n+++ b/tokio/src/sync/semaphore.rs\n@@ -543,6 +543,8 @@ impl Permit {\n             }\n             Pending => {\n                 self.state = PermitState::Waiting;\n+                // Register a waker to clean up state if the future is cancelled\n+                cx.waker().wake_by_ref();\n                 Pending\n             }\n         }\n"
    },
    {
        "instance_id": "tokio-rs__tokio-2006",
        "model_name_or_path": "gpt-4o-2024-05-13",
        "model_patch": "diff --git a/tokio/src/runtime/blocking/pool.rs b/tokio/src/runtime/blocking/pool.rs\nindex 6c23daec..178f390d 100644\n--- a/tokio/src/runtime/blocking/pool.rs\n+++ b/tokio/src/runtime/blocking/pool.rs\n@@ -83,7 +83,11 @@ where\n     BLOCKING.with(|cell| {\n         let schedule = match cell.get() {\n             Some(ptr) => unsafe { &*ptr },\n-            None => panic!(\"not currently running on the Tokio runtime.\"),\n+            None => {\n+                let spawner = Spawner::current();\n+                cell.set(Some(spawner as *const _));\n+                spawner\n+            }\n         };\n \n         let (task, handle) = task::joinable(BlockingTask::new(func));\n"
    },
    {
        "instance_id": "apache__arrow-rs-4343",
        "model_name_or_path": "gpt-4o-2024-05-13",
        "model_patch": "diff --git a/arrow-select/src/concat.rs b/arrow-select/src/concat.rs\nindex 0bf4c97ff..242b70ede 100644\n--- a/arrow-select/src/concat.rs\n+++ b/arrow-select/src/concat.rs\n@@ -78,7 +78,9 @@ pub fn concat(arrays: &[&dyn Array]) -> Result<ArrayRef, ArrowError> {\n         DataType::LargeUtf8 => binary_capacity::<LargeUtf8Type>(arrays),\n         DataType::Binary => binary_capacity::<BinaryType>(arrays),\n         DataType::LargeBinary => binary_capacity::<LargeBinaryType>(arrays),\n-        _ => Capacities::Array(arrays.iter().map(|a| a.len()).sum()),\n+        DataType::List(_) | DataType::LargeList(_) => {\n+            Capacities::Array(arrays.iter().map(|a| a.len()).sum::<usize>() + 500) // Added 500 as a margin\n+        },\n     };\n \n     let array_data: Vec<_> = arrays.iter().map(|a| a.to_data()).collect::<Vec<_>>();\n"
    },
    {
        "instance_id": "serde-rs__serde-2802",
        "model_name_or_path": "gpt-4o-2024-05-13",
        "model_patch": "diff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex 996e97e8..ab6aacc5 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -433,6 +433,14 @@ fn deserialize_unit_struct(params: &Parameters, cattrs: &attr::Container) -> Fra\n             {\n                 _serde::__private::Ok(#this_value)\n             }\n+\n+            #[inline]\n+            fn visit_none<__E>(self) -> _serde::__private::Result<Self::Value, __E>\n+            where\n+                __E: _serde::de::Error,\n+            {\n+                self.visit_unit()\n+            }\n         }\n \n         _serde::Deserializer::deserialize_unit_struct(\ndiff --git a/serde_derive/src/ser.rs b/serde_derive/src/ser.rs\nindex 35f8ca4b..f2d6129d 100644\n--- a/serde_derive/src/ser.rs\n+++ b/serde_derive/src/ser.rs\n@@ -219,7 +219,8 @@ fn serialize_unit_struct(cattrs: &attr::Container) -> Fragment {\n     let type_name = cattrs.name().serialize_name();\n \n     quote_expr! {\n-        _serde::Serializer::serialize_unit_struct(__serializer, #type_name)\n+        _serde::Serializer::serialize_unit_struct(__serializer, #type_name)?;\n+        _serde::Serializer::serialize_unit(__serializer)\n     }\n }\n \n"
    },
    {
        "instance_id": "asterinas__asterinas-1279",
        "model_name_or_path": "gpt-4o-2024-05-13",
        "model_patch": "diff --git a/kernel/src/process/sync/condvar.rs b/kernel/src/process/sync/condvar.rs\nindex 944fe070..32e986bc 100644\n--- a/kernel/src/process/sync/condvar.rs\n+++ b/kernel/src/process/sync/condvar.rs\n@@ -122,6 +122,8 @@ impl Condvar {\n                 None\n             }\n         };\n+        t.join().expect(\"Thread panicked\");\n+\n         {\n             let mut counter = self.counter.lock();\n             counter.waiter_count += 1;\n@@ -277,13 +279,13 @@ mod test {\n         let pair = Arc::new((Mutex::new(false), Condvar::new()));\n         let pair2 = Arc::clone(&pair);\n \n-        Thread::spawn_kernel_thread(ThreadOptions::new(move || {\n+        let t = Thread::spawn_kernel_thread(ThreadOptions::new(move || {\n             Thread::yield_now();\n             let (lock, cvar) = &*pair2;\n             let mut started = lock.lock();\n             *started = true;\n             cvar.notify_one();\n-        }));\n+        })).join().expect(\"Thread panicked\");\n \n         {\n             let (lock, cvar) = &*pair;\n"
    },
    {
        "instance_id": "tokio-rs__tokio-2448",
        "model_name_or_path": "gpt-4o-2024-05-13",
        "model_patch": "diff --git a/tokio/src/sync/broadcast.rs b/tokio/src/sync/broadcast.rs\nindex 05a58070..d6a5e21e 100644\n--- a/tokio/src/sync/broadcast.rs\n+++ b/tokio/src/sync/broadcast.rs\n@@ -758,8 +758,16 @@ where\n     /// }\n     /// ```\n     pub fn try_recv(&mut self) -> Result<T, TryRecvError> {\n-        let guard = self.recv_ref(false)?;\n-        guard.clone_value().ok_or(TryRecvError::Closed)\n+        let guard = self.recv_ref(true)?;\n+        if guard.is_lagging() {\n+            Err(TryRecvError::Lagged(guard.lagged().unwrap()))\n+        } else if guard.is_closed() {\n+            Err(TryRecvError::Closed)\n+        } else if guard.is_empty() {\n+            Err(TryRecvError::Empty)\n+        } else {\n+            Ok(guard.clone_value().unwrap())\n+        }\n     }\n \n     #[doc(hidden)] // TODO: document\n"
    },
    {
        "instance_id": "asterinas__asterinas-1026",
        "model_name_or_path": "gpt-4o-2024-05-13",
        "model_patch": "diff --git a/ostd/src/mm/space.rs b/ostd/src/mm/space.rs\nindex 548348f7..e0e9528e 100644\n--- a/ostd/src/mm/space.rs\n+++ b/ostd/src/mm/space.rs\n@@ -46,6 +46,7 @@ use crate::{\n #[allow(clippy::type_complexity)]\n pub struct VmSpace {\n     pt: PageTable<UserMode>,\n+    memory_set: Arc<Mutex<MemorySet>>,\n     page_fault_handler: Once<fn(&VmSpace, &CpuExceptionInfo) -> core::result::Result<(), ()>>,\n }\n \n"
    },
    {
        "instance_id": "tokio-rs__tokio-4867",
        "model_name_or_path": "gpt-4o-2024-05-13",
        "model_patch": "diff --git a/tokio/src/sync/broadcast.rs b/tokio/src/sync/broadcast.rs\nindex 69ede8f8..8e9099e8 100644\n--- a/tokio/src/sync/broadcast.rs\n+++ b/tokio/src/sync/broadcast.rs\n@@ -916,7 +916,16 @@ impl<T: Clone> Receiver<T> {\n     /// ```\n     pub fn resubscribe(&self) -> Self {\n         let shared = self.shared.clone();\n-        new_receiver(shared)\n+        \n+        // Check if the channel is closed\n+        if shared.is_closed() {\n+            // Create a receiver in a closed state\n+            let mut receiver = new_receiver(shared);\n+            receiver.next = shared.tail.load(SeqCst);\n+            receiver\n+        } else {\n+            new_receiver(shared)\n+        }\n     }\n     /// Receives the next value for this receiver.\n     ///\n"
    },
    {
        "instance_id": "tokio-rs__tokio-2457",
        "model_name_or_path": "gpt-4o-2024-05-13",
        "model_patch": "diff --git a/tokio/src/runtime/builder.rs b/tokio/src/runtime/builder.rs\nindex 56fb898a..1fb1b58f 100644\n--- a/tokio/src/runtime/builder.rs\n+++ b/tokio/src/runtime/builder.rs\n@@ -464,7 +464,10 @@ cfg_rt_threaded! {\n             use crate::runtime::{Kind, ThreadPool};\n             use crate::runtime::park::Parker;\n \n-            let core_threads = self.core_threads.unwrap_or_else(crate::loom::sys::num_cpus);\n+            let core_threads = self.core_threads.unwrap_or_else(|| {\n+                let num_cpus = crate::loom::sys::num_cpus();\n+                std::cmp::min(num_cpus, self.max_threads)\n+            });\n             assert!(core_threads <= self.max_threads, \"Core threads number cannot be above max limit\");\n \n             let clock = time::create_clock();\n"
    },
    {
        "instance_id": "tokio-rs__tokio-2354",
        "model_name_or_path": "gpt-4o-2024-05-13",
        "model_patch": "diff --git a/tokio/src/fs/copy.rs b/tokio/src/fs/copy.rs\nindex e39924c5..1d873fb7 100644\n--- a/tokio/src/fs/copy.rs\n+++ b/tokio/src/fs/copy.rs\n@@ -18,9 +18,18 @@ use std::path::Path;\n /// # }\n /// ```\n \n+use std::fs::OpenOptions;\n+use std::os::unix::fs::PermissionsExt;\n+\n pub async fn copy<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> Result<u64, std::io::Error> {\n     let from = File::open(from).await?;\n-    let to = File::create(to).await?;\n+    let to = File::create(&to).await?;\n     let (mut from, mut to) = (io::BufReader::new(from), io::BufWriter::new(to));\n-    io::copy(&mut from, &mut to).await\n+    let result = io::copy(&mut from, &mut to).await?;\n+\n+    let from_metadata = tokio::fs::metadata(from).await?;\n+    let permissions = from_metadata.permissions();\n+    tokio::fs::set_permissions(to, permissions).await?;\n+\n+    Ok(result)\n }\n"
    },
    {
        "instance_id": "tokio-rs__tokio-4430",
        "model_name_or_path": "gpt-4o-2024-05-13",
        "model_patch": "diff --git a/tokio/src/runtime/task/harness.rs b/tokio/src/runtime/task/harness.rs\nindex 0996e523..43c823d6 100644\n--- a/tokio/src/runtime/task/harness.rs\n+++ b/tokio/src/runtime/task/harness.rs\n@@ -165,8 +165,6 @@ where\n     }\n \n     pub(super) fn drop_join_handle_slow(self) {\n-        let mut maybe_panic = None;\n-\n         // Try to unset `JOIN_INTEREST`. This must be done as a first step in\n         // case the task concurrently completed.\n         if self.header().state.unset_join_interested().is_err() {\n@@ -175,21 +173,13 @@ where\n             // the scheduler or `JoinHandle`. i.e. if the output remains in the\n             // task structure until the task is deallocated, it may be dropped\n             // by a Waker on any arbitrary thread.\n-            let panic = panic::catch_unwind(panic::AssertUnwindSafe(|| {\n+            let _ = panic::catch_unwind(panic::AssertUnwindSafe(|| {\n                 self.core().stage.drop_future_or_output();\n             }));\n-\n-            if let Err(panic) = panic {\n-                maybe_panic = Some(panic);\n-            }\n         }\n-\n+    \n         // Drop the `JoinHandle` reference, possibly deallocating the task\n         self.drop_reference();\n-\n-        if let Some(panic) = maybe_panic {\n-            panic::resume_unwind(panic);\n-        }\n     }\n \n     /// Remotely aborts the task.\n"
    },
    {
        "instance_id": "tokio-rs__tokio-2145",
        "model_name_or_path": "gpt-4o-2024-05-13",
        "model_patch": "diff --git a/tokio/src/io/driver/mod.rs b/tokio/src/io/driver/mod.rs\nindex a36a40fa..a83051a9 100644\n--- a/tokio/src/io/driver/mod.rs\n+++ b/tokio/src/io/driver/mod.rs\n@@ -198,7 +198,7 @@ impl Handle {\n     ///\n     /// This function panics if there is no current reactor set.\n     pub(super) fn current() -> Self {\n-        context::io_handle().expect(\"no current reactor\")\n+        context::io_handle().expect(\"No current reactor available. Ensure that the Tokio runtime is initialized and running.\")\n     }\n \n     /// Forces a reactor blocked in a call to `turn` to wakeup, or otherwise\ndiff --git a/tokio/src/runtime/handle.rs b/tokio/src/runtime/handle.rs\nindex 3f253455..56a1b499 100644\n--- a/tokio/src/runtime/handle.rs\n+++ b/tokio/src/runtime/handle.rs\n@@ -60,7 +60,7 @@ impl Handle {\n     /// # }\n     /// ```\n     pub fn current() -> Self {\n-        context::current().expect(\"not currently running on the Tokio runtime.\")\n+        context::current().expect(\"No current reactor available. Ensure that the Tokio runtime is initialized and running.\")\n     }\n \n     /// Returns a Handle view over the currently running Runtime\ndiff --git a/tokio/src/time/driver/handle.rs b/tokio/src/time/driver/handle.rs\nindex f24eaeb6..8ac8982f 100644\n--- a/tokio/src/time/driver/handle.rs\n+++ b/tokio/src/time/driver/handle.rs\n@@ -21,7 +21,7 @@ impl Handle {\n     ///\n     /// This function panics if there is no current timer set.\n     pub(crate) fn current() -> Self {\n-        context::time_handle().expect(\"no current timer\")\n+        context::time_handle().expect(\"No current timer available. Ensure that the Tokio runtime is initialized and running.\")\n     }\n \n     /// Try to return a strong ref to the inner\ndiff --git a/tokio/src/time/error.rs b/tokio/src/time/error.rs\nindex 994eec1f..205bc8f4 100644\n--- a/tokio/src/time/error.rs\n+++ b/tokio/src/time/error.rs\n@@ -64,7 +64,7 @@ impl fmt::Display for Error {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         use self::Kind::*;\n         let descr = match self.0 {\n-            Shutdown => \"timer is shutdown\",\n+            Shutdown => \"Timer error: The timer is shut down. Ensure that the Tokio runtime is active and running.\",\n             AtCapacity => \"timer is at capacity and cannot create a new entry\",\n         };\n         write!(fmt, \"{}\", descr)\n"
    },
    {
        "instance_id": "hyperium__hyper-3261",
        "model_name_or_path": "gpt-4o-2024-05-13",
        "model_patch": "diff --git a/src/server/conn/http1.rs b/src/server/conn/http1.rs\nindex 530082e9..ae630bc4 100644\n--- a/src/server/conn/http1.rs\n+++ b/src/server/conn/http1.rs\n@@ -422,7 +422,9 @@ mod upgrades {\n         /// This `Connection` should continue to be polled until shutdown\n         /// can finish.\n         pub fn graceful_shutdown(mut self: Pin<&mut Self>) {\n-            Pin::new(self.inner.as_mut().unwrap()).graceful_shutdown()\n+            if let Some(ref mut inner) = self.inner.as_mut() {\n+                Pin::new(inner).graceful_shutdown();\n+            }\n         }\n     }\n \n"
    },
    {
        "instance_id": "tokio-rs__tokio-3860",
        "model_name_or_path": "gpt-4o-2024-05-13",
        "model_patch": "diff --git a/tokio/src/time/clock.rs b/tokio/src/time/clock.rs\nindex c5ef86be..0b14af5a 100644\n--- a/tokio/src/time/clock.rs\n+++ b/tokio/src/time/clock.rs\n@@ -123,8 +123,16 @@ cfg_test_util! {\n         let clock = clock().expect(\"time cannot be frozen from outside the Tokio runtime\");\n         let until = clock.now() + duration;\n         clock.advance(duration);\n-\n-        crate::time::sleep_until(until).await;\n+    \n+        if duration <= Duration::from_micros(999) {\n+            // Sleep for the specified sub-millisecond duration by spinning\n+            let target = std::time::Instant::now() + duration.to_std().unwrap();\n+            while std::time::Instant::now() < target {\n+                std::hint::spin_loop();\n+            }\n+        } else {\n+            crate::time::sleep_until(until).await;\n+        }\n     }\n \n     /// Return the current instant, factoring in frozen time.\n"
    },
    {
        "instance_id": "hyperium__hyper-3275",
        "model_name_or_path": "gpt-4o-2024-05-13",
        "model_patch": "diff --git a/src/proto/h2/mod.rs b/src/proto/h2/mod.rs\nindex 2002edeb..af8481f5 100644\n--- a/src/proto/h2/mod.rs\n+++ b/src/proto/h2/mod.rs\n@@ -405,7 +405,13 @@ where\n     }\n \n     fn poll_reset(&mut self, cx: &mut Context<'_>) -> Poll<Result<h2::Reason, h2::Error>> {\n-        unsafe { self.as_inner_unchecked().poll_reset(cx) }\n+        match unsafe { self.as_inner_unchecked().poll_reset(cx) } {\n+            Poll::Ready(Ok(h2::Reason::NO_ERROR)) => {\n+                // Stop sending the body and continue processing the response\n+                Poll::Ready(Ok(h2::Reason::NO_ERROR))\n+            },\n+            other => other,\n+        }\n     }\n \n     fn write(&mut self, buf: &[u8], end_of_stream: bool) -> Result<(), std::io::Error> {\n"
    },
    {
        "instance_id": "tokio-rs__tokio-3965",
        "model_name_or_path": "gpt-4o-2024-05-13",
        "model_patch": "diff --git a/tokio/src/runtime/task/join.rs b/tokio/src/runtime/task/join.rs\nindex 2fe40a72..a843f957 100644\n--- a/tokio/src/runtime/task/join.rs\n+++ b/tokio/src/runtime/task/join.rs\n@@ -190,8 +190,8 @@ impl<T> JoinHandle<T> {\n     ///    }\n     /// }\n     /// ```\n-    pub fn abort(&self) {\n-        if let Some(raw) = self.raw {\n+    pub fn abort(&mut self) {\n+        if let Some(raw) = self.raw.take() {\n             raw.remote_abort();\n         }\n     }\n@@ -240,11 +240,13 @@ impl<T> Future for JoinHandle<T> {\n \n impl<T> Drop for JoinHandle<T> {\n     fn drop(&mut self) {\n-        if let Some(raw) = self.raw.take() {\n+        if let Some(mut raw) = self.raw.take() {\n+            raw.remote_abort();\n+    \n             if raw.header().state.drop_join_handle_fast().is_ok() {\n                 return;\n             }\n-\n+    \n             raw.drop_join_handle_slow();\n         }\n     }\n"
    }
]